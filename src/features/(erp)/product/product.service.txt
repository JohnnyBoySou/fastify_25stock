import { fetchAuth } from "@/services/http/fetch";
import { z } from "zod";
// === INTERFACES PARA PRODUCT ===


export const ProductSchema = z.object({
    name: z
        .string()
        .min(1, "O nome do produto é obrigatório")
        .min(2, "O nome deve ter pelo menos 2 caracteres")
        .max(100, "O nome deve ter no máximo 100 caracteres"),

    description: z
        .string()
        .min(1, "A descrição é obrigatória")
        .min(5, "A descrição deve ter pelo menos 5 caracteres")
        .max(500, "A descrição deve ter no máximo 500 caracteres"),

    referencePrice: z
        .string()
        .min(1, "O preço de referência é obrigatório")
        .refine((val) => !isNaN(parseFloat(val)), "Por favor, insira um preço válido")
        .refine((val) => parseFloat(val) >= 0, "O preço não pode ser negativo"),

    unitOfMeasure: z.enum(['UNIDADE', 'KG', 'L', 'ML', 'M', 'CM', 'MM', 'UN', 'DZ', 'CX', 'PCT', 'KIT', 'PAR', 'H', 'D']),

    categoryIds: z.array(z.string()).min(1, "Selecione pelo menos uma categoria"),

    stockMin: z
        .string()
        .min(1, "O estoque mínimo é obrigatório")
        .refine((val) => !isNaN(parseInt(val)), "Por favor, insira um valor válido")
        .refine((val) => parseInt(val) >= 0, "O estoque mínimo não pode ser negativo"),

    stockMax: z
        .string()
        .min(1, "O estoque máximo é obrigatório")
        .refine((val) => !isNaN(parseInt(val)), "Por favor, insira um valor válido")
        .refine((val) => parseInt(val) >= 0, "O estoque máximo não pode ser negativo"),

    alertPercentage: z
        .string()
        .min(1, "O percentual de alerta é obrigatório")
        .refine((val) => !isNaN(parseInt(val)), "Por favor, insira um valor válido")
        .refine((val) => parseInt(val) >= 0 && parseInt(val) <= 100, "O percentual deve estar entre 0 e 100"),

    status: z.boolean()
});

export type ProductFormData = z.infer<typeof ProductSchema>;

// Schema para edição (com categorias opcionais)
export const ProductEditSchema = z.object({
    name: z
        .string()
        .min(1, "O nome do produto é obrigatório")
        .min(2, "O nome deve ter pelo menos 2 caracteres")
        .max(100, "O nome deve ter no máximo 100 caracteres"),

    description: z
        .string()
        .min(1, "A descrição é obrigatória")
        .min(5, "A descrição deve ter pelo menos 5 caracteres")
        .max(500, "A descrição deve ter no máximo 500 caracteres"),

    referencePrice: z
        .string()
        .min(1, "O preço de referência é obrigatório")
        .refine((val) => !isNaN(parseFloat(val)), "Por favor, insira um preço válido")
        .refine((val) => parseFloat(val) >= 0, "O preço não pode ser negativo"),

    unitOfMeasure: z.enum(['UNIDADE', 'KG', 'L', 'ML', 'M', 'CM', 'MM', 'UN', 'DZ', 'CX', 'PCT', 'KIT', 'PAR', 'H', 'D']),

    categoryIds: z.array(z.string()).optional(),

    stockMin: z
        .string()
        .min(1, "O estoque mínimo é obrigatório")
        .refine((val) => !isNaN(parseInt(val)), "Por favor, insira um valor válido")
        .refine((val) => parseInt(val) >= 0, "O estoque mínimo não pode ser negativo"),

    stockMax: z
        .string()
        .min(1, "O estoque máximo é obrigatório")
        .refine((val) => !isNaN(parseInt(val)), "Por favor, insira um valor válido")
        .refine((val) => parseInt(val) >= 0, "O estoque máximo não pode ser negativo"),

    alertPercentage: z
        .string()
        .min(1, "O percentual de alerta é obrigatório")
        .refine((val) => !isNaN(parseInt(val)), "Por favor, insira um valor válido")
        .refine((val) => parseInt(val) >= 0 && parseInt(val) <= 100, "O percentual deve estar entre 0 e 100"),

    status: z.boolean()
});

export type ProductEditFormData = z.infer<typeof ProductEditSchema>;


export interface Product {
    id: string;
    name: string;
    description?: string;
    unitOfMeasure: 'UNIDADE' | 'KG' | 'L' | 'ML' | 'M' | 'CM' | 'MM' | 'UN' | 'DZ' | 'CX' | 'PCT' | 'KIT' | 'PAR' | 'H' | 'D';
    referencePrice: number;
    categoryId?: string;
    categories?: Array<{
        category: {
            id: string;
            name: string;
            description?: string;
            code?: string;
            color?: string;
            icon?: string;
        };
    }>;
    supplierId?: string;
    storeId: string;
    stockMin: number;
    stockMax: number;
    alertPercentage: number;
    status: boolean;
    createdAt: string;
    updatedAt: string;
    category?: {
        id: string;
        name: string;
        description?: string;
        code?: string;
    };
    supplier?: {
        id: string;
        corporateName: string;
        cnpj: string;
        tradeName?: string;
    };
    store?: {
        id: string;
        name: string;
        cnpj: string;
    };
}

export interface Pagination {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
}

export interface ProductListResponse {
    items: Product[];
    pagination: Pagination;
}

export interface ProductCreateRequest {
    name: string;
    description?: string;
    unitOfMeasure: 'UNIDADE' | 'KG' | 'L' | 'ML' | 'M' | 'CM' | 'MM' | 'UN' | 'DZ' | 'CX' | 'PCT' | 'KIT' | 'PAR' | 'H' | 'D';
    referencePrice: number;
    categoryId?: string;
    categoryIds?: string[];
    supplierId?: string;
    stockMin: number;
    stockMax: number;
    alertPercentage: number;
    status?: boolean;
}

export interface ProductUpdateRequest {
    name?: string;
    description?: string;
    unitOfMeasure?: 'UNIDADE' | 'KG' | 'L' | 'ML' | 'M' | 'CM' | 'MM' | 'UN' | 'DZ' | 'CX' | 'PCT' | 'KIT' | 'PAR' | 'H' | 'D';
    referencePrice?: number;
    categoryId?: string;
    categories?: Array<{ categoryId: string }>;
    supplierId?: string;
    storeId?: string;
    stockMin?: number;
    stockMax?: number;
    alertPercentage?: number;
    status?: boolean;
}

export interface ProductStats {
    total: number;
    active: number;
    inactive: number;
    byCategory: Array<{
        category: string;
        _count: { id: number };
    }>;
    bySupplier: Array<{
        supplier: string;
        _count: { id: number };
    }>;
    lowStock: number;
    outOfStock: number;
}

export interface ProductStockResponse {
    id: string;
    name: string;
    currentStock: number;
    stockMin: number;
    stockMax: number;
    alertPercentage: number;
    status: 'OK' | 'LOW' | 'CRITICAL' | 'OVERSTOCK';
    lastMovement?: {
        type: string;
        quantity: number;
        date: string;
    };
}

export interface ProductMovement {
    id: string;
    type: 'ENTRADA' | 'SAIDA' | 'PERDA';
    quantity: number;
    batch?: string;
    expiration?: string;
    price?: number;
    note?: string;
    balanceAfter?: number;
    createdAt: string;
    supplier?: {
        id: string;
        corporateName: string;
        cnpj: string;
    };
    user?: {
        id: string;
        name: string;
        email: string;
    };
}

export interface ProductMovementListResponse {
    movements: ProductMovement[];
    pagination: Pagination;
}

export interface CreateProductMovementRequest {
    type: 'ENTRADA' | 'SAIDA' | 'PERDA';
    quantity: number;
    supplierId?: string;
    batch?: string;
    expiration?: string;
    price?: number;
    note?: string;
}

export interface UpdateStockRequest {
    quantity: number;
    type: 'ENTRADA' | 'SAIDA' | 'PERDA';
    note?: string;
}

export interface ProductAnalytics {
    productId: string;
    productName: string;
    totalMovements: number;
    totalIn: number;
    totalOut: number;
    totalLoss: number;
    averagePrice: number;
    lastMovement: string;
    stockTrend: 'INCREASING' | 'DECREASING' | 'STABLE';
    turnoverRate: number;
    profitMargin: number;
}

export interface SkuVerification {
    available: boolean;
    message: string;
}

const URI = "/products";

export const ProductService = {
    // === CRUD BÁSICO ===
    create: (params: ProductCreateRequest): Promise<Product> => 
        fetchAuth(URI, { method: "POST", data: params as unknown as Record<string, unknown> }) as Promise<Product>,
    
    list: (params?: { 
        page?: number; 
        limit?: number; 
        search?: string; 
        status?: boolean; 
        categoryId?: string; 
        supplierId?: string; 
        storeId?: string 
    }): Promise<ProductListResponse> => 
        fetchAuth(URI, { method: "GET", params }) as Promise<ProductListResponse>,
    
    single: (id: string): Promise<Product> => 
        fetchAuth(`${URI}/${id}`, { method: "GET" }) as Promise<Product>,
    
    update: (id: string, params: ProductUpdateRequest): Promise<Product> => 
        fetchAuth(`${URI}/${id}`, { method: "PUT", data: params as unknown as Record<string, unknown> }) as Promise<Product>,
    
    delete: (id: string): Promise<void> => 
        fetchAuth(`${URI}/${id}`, { method: "DELETE" }) as Promise<void>,

    // === CONSULTAS ESPECÍFICAS ===
    getActive: (): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/active`, { method: "GET" }) as Promise<{ items: Product[] }>,
    
    getStats: (): Promise<ProductStats> => 
        fetchAuth(`${URI}/stats`, { method: "GET" }) as Promise<ProductStats>,
    
    search: (q: string, limit?: number): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/search`, { method: "GET", params: { q, limit } }) as Promise<{ items: Product[] }>,
    
    getByCategory: (categoryId: string): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/category/${categoryId}`, { method: "GET" }) as Promise<{ items: Product[] }>,
    
    getBySupplier: (supplierId: string): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/supplier/${supplierId}`, { method: "GET" }) as Promise<{ items: Product[] }>,
    
    getByStore: (storeId: string): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/store/${storeId}`, { method: "GET" }) as Promise<{ items: Product[] }>,

    // === GERENCIAMENTO DE STATUS ===
    updateStatus: (id: string, status: boolean): Promise<Product> => 
        fetchAuth(`${URI}/${id}/status`, { method: "PATCH", data: { status } }) as Promise<Product>,

    // === GERENCIAMENTO DE ESTOQUE ===
    getStock: (id: string): Promise<ProductStockResponse> => 
        fetchAuth(`${URI}/${id}/stock`, { method: "GET" }) as Promise<ProductStockResponse>,
    
    updateStock: (id: string, params: UpdateStockRequest): Promise<ProductStockResponse> => 
        fetchAuth(`${URI}/${id}/stock`, { method: "PATCH", data: params as unknown as Record<string, unknown> }) as Promise<ProductStockResponse>,
    
    getStockHistory: (id: string, limit?: number): Promise<{ history: ProductStockResponse[] }> => 
        fetchAuth(`${URI}/${id}/stock/history`, { method: "GET", params: { limit } }) as Promise<{ history: ProductStockResponse[] }>,
    
    getLowStock: (storeId?: string): Promise<{ items: ProductStockResponse[] }> => 
        fetchAuth(`${URI}/low-stock`, { method: "GET", params: { storeId } }) as Promise<{ items: ProductStockResponse[] }>,

    // === MOVIMENTAÇÕES DE ESTOQUE ===
    getMovements: (id: string, params?: {
        page?: number;
        limit?: number;
        type?: 'ENTRADA' | 'SAIDA' | 'PERDA';
        startDate?: string;
        endDate?: string;
    }): Promise<ProductMovementListResponse> => 
        fetchAuth(`${URI}/${id}/movements`, { method: "GET", params }) as Promise<ProductMovementListResponse>,
    
    createMovement: (id: string, params: CreateProductMovementRequest): Promise<ProductMovement> => 
        fetchAuth(`${URI}/${id}/movements`, { method: "POST", data: params as unknown as Record<string, unknown> }) as Promise<ProductMovement>,

    // === ANÁLISES E RELATÓRIOS ===
    getAnalytics: (id: string): Promise<ProductAnalytics> => 
        fetchAuth(`${URI}/${id}/analytics`, { method: "GET" }) as Promise<ProductAnalytics>,
    
    getRecent: (limit?: number): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/recent`, { method: "GET", params: { limit } }) as Promise<{ items: Product[] }>,

    // === VALIDAÇÕES ===
    verifySku: (id: string, sku: string): Promise<SkuVerification> => 
        fetchAuth(`${URI}/${id}/verify-sku`, { method: "POST", data: { sku } }) as Promise<SkuVerification>,

    // === FUNÇÕES DE BUSCA AVANÇADA ===
    getByPriceRange: (minPrice: number, maxPrice: number, storeId?: string): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/price-range`, { method: "GET", params: { minPrice, maxPrice, storeId } }) as Promise<{ items: Product[] }>,
    
    getByStockStatus: (status: 'OK' | 'LOW' | 'CRITICAL' | 'OVERSTOCK', storeId?: string): Promise<{ items: ProductStockResponse[] }> => 
        fetchAuth(`${URI}/stock-status`, { method: "GET", params: { status, storeId } }) as Promise<{ items: ProductStockResponse[] }>,
    
    getExpiringSoon: (days: number = 30, storeId?: string): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/expiring-soon`, { method: "GET", params: { days, storeId } }) as Promise<{ items: Product[] }>,

    // === RELATÓRIOS DE PERFORMANCE ===
    getTopSelling: (storeId?: string, limit?: number): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/top-selling`, { method: "GET", params: { storeId, limit } }) as Promise<{ items: Product[] }>,
    
    getSlowMoving: (storeId?: string, days?: number): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/slow-moving`, { method: "GET", params: { storeId, days } }) as Promise<{ items: Product[] }>,
    
    getZeroStock: (storeId?: string): Promise<{ items: Product[] }> => 
        fetchAuth(`${URI}/zero-stock`, { method: "GET", params: { storeId } }) as Promise<{ items: Product[] }>,

    // === UTILITÁRIOS ===
    bulkUpdate: (updates: Array<{ id: string; data: ProductUpdateRequest }>): Promise<{ updated: number; errors: string[] }> => 
        fetchAuth(`${URI}/bulk-update`, { method: "POST", data: { updates } as unknown as Record<string, unknown> }) as Promise<{ updated: number; errors: string[] }>,
    
    bulkDelete: (ids: string[]): Promise<{ deleted: number; errors: string[] }> => 
        fetchAuth(`${URI}/bulk-delete`, { method: "POST", data: { ids } as unknown as Record<string, unknown> }) as Promise<{ deleted: number; errors: string[] }>,
    
    export: (filters?: {
        storeId?: string;
        categoryId?: string;
        supplierId?: string;
        status?: boolean;
        format?: 'csv' | 'xlsx';
    }): Promise<{ downloadUrl: string }> => 
        fetchAuth(`${URI}/export`, { method: "POST", data: filters }) as Promise<{ downloadUrl: string }>,

    keys: {
        list: (page: number) => ["products", "list", page.toString()],
        single: (id: string) => ["product", "single", id],
        create: ["products"],
        update: ["product"],
        delete: ["product"],
        search: (q: string) => ["products", "search", q],
        stats: ["products", "stats"],
        active: ["products", "active"],
        byCategory: ["products", "byCategory"],
        bySupplier: ["products", "bySupplier"],
        byStore: ["products", "byStore"],
        stock: ["products", "stock"],
        lowStock: ["products", "lowStock"],
        movements: ["products", "movements"],
        analytics: ["products", "analytics"],
        recent: ["products", "recent"],
        topSelling: ["products", "topSelling"],
        slowMoving: ["products", "slowMoving"],
        zeroStock: ["products", "zeroStock"],
        expiringSoon: ["products", "expiringSoon"],
        byPriceRange: ["products", "byPriceRange"],
        byStockStatus: ["products", "byStockStatus"],
        bulkUpdate: ["products", "bulkUpdate"],
        bulkDelete: ["products", "bulkDelete"],
        export: ["products", "export"],
    }
};