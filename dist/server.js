var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/generated/prisma/runtime/library.js
var require_library = __commonJS({
  "src/generated/prisma/runtime/library.js"(exports2, module2) {
    "use strict";
    var yu = Object.create;
    var jt = Object.defineProperty;
    var bu = Object.getOwnPropertyDescriptor;
    var Eu = Object.getOwnPropertyNames;
    var wu = Object.getPrototypeOf;
    var xu = Object.prototype.hasOwnProperty;
    var Do = (e, r) => () => (e && (r = e(e = 0)), r);
    var ue = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
    var tr = (e, r) => {
      for (var t in r) jt(e, t, { get: r[t], enumerable: true });
    };
    var Oo = (e, r, t, n) => {
      if (r && typeof r == "object" || typeof r == "function") for (let i of Eu(r)) !xu.call(e, i) && i !== t && jt(e, i, { get: () => r[i], enumerable: !(n = bu(r, i)) || n.enumerable });
      return e;
    };
    var O = (e, r, t) => (t = e != null ? yu(wu(e)) : {}, Oo(r || !e || !e.__esModule ? jt(t, "default", { value: e, enumerable: true }) : t, e));
    var vu = (e) => Oo(jt({}, "__esModule", { value: true }), e);
    var hi = ue((_g, is) => {
      "use strict";
      is.exports = (e, r = process.argv) => {
        let t = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = r.indexOf(t + e), i = r.indexOf("--");
        return n !== -1 && (i === -1 || n < i);
      };
    });
    var as = ue((Ng, ss) => {
      "use strict";
      var Fc = require("os"), os3 = require("tty"), de = hi(), { env: G } = process, Qe;
      de("no-color") || de("no-colors") || de("color=false") || de("color=never") ? Qe = 0 : (de("color") || de("colors") || de("color=true") || de("color=always")) && (Qe = 1);
      "FORCE_COLOR" in G && (G.FORCE_COLOR === "true" ? Qe = 1 : G.FORCE_COLOR === "false" ? Qe = 0 : Qe = G.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(G.FORCE_COLOR, 10), 3));
      function yi(e) {
        return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
      }
      function bi(e, r) {
        if (Qe === 0) return 0;
        if (de("color=16m") || de("color=full") || de("color=truecolor")) return 3;
        if (de("color=256")) return 2;
        if (e && !r && Qe === void 0) return 0;
        let t = Qe || 0;
        if (G.TERM === "dumb") return t;
        if (process.platform === "win32") {
          let n = Fc.release().split(".");
          return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in G) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => n in G) || G.CI_NAME === "codeship" ? 1 : t;
        if ("TEAMCITY_VERSION" in G) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION) ? 1 : 0;
        if (G.COLORTERM === "truecolor") return 3;
        if ("TERM_PROGRAM" in G) {
          let n = parseInt((G.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (G.TERM_PROGRAM) {
            case "iTerm.app":
              return n >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(G.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM) || "COLORTERM" in G ? 1 : t;
      }
      function Mc(e) {
        let r = bi(e, e && e.isTTY);
        return yi(r);
      }
      ss.exports = { supportsColor: Mc, stdout: yi(bi(true, os3.isatty(1))), stderr: yi(bi(true, os3.isatty(2))) };
    });
    var cs = ue((Lg, us) => {
      "use strict";
      var $c = as(), br = hi();
      function ls(e) {
        if (/^\d{3,4}$/.test(e)) {
          let t = /(\d{1,2})(\d{2})/.exec(e) || [];
          return { major: 0, minor: parseInt(t[1], 10), patch: parseInt(t[2], 10) };
        }
        let r = (e || "").split(".").map((t) => parseInt(t, 10));
        return { major: r[0], minor: r[1], patch: r[2] };
      }
      function Ei(e) {
        let { CI: r, FORCE_HYPERLINK: t, NETLIFY: n, TEAMCITY_VERSION: i, TERM_PROGRAM: o, TERM_PROGRAM_VERSION: s, VTE_VERSION: a, TERM: l } = process.env;
        if (t) return !(t.length > 0 && parseInt(t, 10) === 0);
        if (br("no-hyperlink") || br("no-hyperlinks") || br("hyperlink=false") || br("hyperlink=never")) return false;
        if (br("hyperlink=true") || br("hyperlink=always") || n) return true;
        if (!$c.supportsColor(e) || e && !e.isTTY) return false;
        if ("WT_SESSION" in process.env) return true;
        if (process.platform === "win32" || r || i) return false;
        if (o) {
          let u = ls(s || "");
          switch (o) {
            case "iTerm.app":
              return u.major === 3 ? u.minor >= 1 : u.major > 3;
            case "WezTerm":
              return u.major >= 20200620;
            case "vscode":
              return u.major > 1 || u.major === 1 && u.minor >= 72;
            case "ghostty":
              return true;
          }
        }
        if (a) {
          if (a === "0.50.0") return false;
          let u = ls(a);
          return u.major > 0 || u.minor >= 50;
        }
        switch (l) {
          case "alacritty":
            return true;
        }
        return false;
      }
      us.exports = { supportsHyperlink: Ei, stdout: Ei(process.stdout), stderr: Ei(process.stderr) };
    });
    var ps = ue((Kg, qc) => {
      qc.exports = { name: "@prisma/internals", version: "6.16.2", description: "This package is intended for Prisma's internal use", main: "dist/index.js", types: "dist/index.d.ts", repository: { type: "git", url: "https://github.com/prisma/prisma.git", directory: "packages/internals" }, homepage: "https://www.prisma.io", author: "Tim Suchanek <suchanek@prisma.io>", bugs: "https://github.com/prisma/prisma/issues", license: "Apache-2.0", scripts: { dev: "DEV=true tsx helpers/build.ts", build: "tsx helpers/build.ts", test: "dotenv -e ../../.db.env -- jest --silent", prepublishOnly: "pnpm run build" }, files: ["README.md", "dist", "!**/libquery_engine*", "!dist/get-generators/engines/*", "scripts"], devDependencies: { "@babel/helper-validator-identifier": "7.25.9", "@opentelemetry/api": "1.9.0", "@swc/core": "1.11.5", "@swc/jest": "0.2.37", "@types/babel__helper-validator-identifier": "7.15.2", "@types/jest": "29.5.14", "@types/node": "18.19.76", "@types/resolve": "1.20.6", archiver: "6.0.2", "checkpoint-client": "1.1.33", "cli-truncate": "4.0.0", dotenv: "16.5.0", empathic: "2.0.0", "escape-string-regexp": "5.0.0", execa: "5.1.1", "fast-glob": "3.3.3", "find-up": "7.0.0", "fp-ts": "2.16.9", "fs-extra": "11.3.0", "fs-jetpack": "5.1.0", "global-directory": "4.0.0", globby: "11.1.0", "identifier-regex": "1.0.0", "indent-string": "4.0.0", "is-windows": "1.0.2", "is-wsl": "3.1.0", jest: "29.7.0", "jest-junit": "16.0.0", kleur: "4.1.5", "mock-stdin": "1.0.0", "new-github-issue-url": "0.2.1", "node-fetch": "3.3.2", "npm-packlist": "5.1.3", open: "7.4.2", "p-map": "4.0.0", resolve: "1.22.10", "string-width": "7.2.0", "strip-indent": "4.0.0", "temp-dir": "2.0.0", tempy: "1.0.1", "terminal-link": "4.0.0", tmp: "0.2.3", "ts-pattern": "5.6.2", "ts-toolbelt": "9.6.0", typescript: "5.4.5", yarn: "1.22.22" }, dependencies: { "@prisma/config": "workspace:*", "@prisma/debug": "workspace:*", "@prisma/dmmf": "workspace:*", "@prisma/driver-adapter-utils": "workspace:*", "@prisma/engines": "workspace:*", "@prisma/fetch-engine": "workspace:*", "@prisma/generator": "workspace:*", "@prisma/generator-helper": "workspace:*", "@prisma/get-platform": "workspace:*", "@prisma/prisma-schema-wasm": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43", "@prisma/schema-engine-wasm": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43", "@prisma/schema-files-loader": "workspace:*", arg: "5.0.2", prompts: "2.4.2" }, peerDependencies: { typescript: ">=5.1.0" }, peerDependenciesMeta: { typescript: { optional: true } }, sideEffects: false };
    });
    var Ti = ue((gh, Qc) => {
      Qc.exports = { name: "@prisma/engines-version", version: "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "1c57fdcd7e44b29b9313256c76699e91c3ac3c43" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.76", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
    });
    var on = ue((nn) => {
      "use strict";
      Object.defineProperty(nn, "__esModule", { value: true });
      nn.enginesVersion = void 0;
      nn.enginesVersion = Ti().prisma.enginesVersion;
    });
    var hs = ue((Ih, gs) => {
      "use strict";
      gs.exports = (e) => {
        let r = e.match(/^[ \t]*(?=\S)/gm);
        return r ? r.reduce((t, n) => Math.min(t, n.length), 1 / 0) : 0;
      };
    });
    var Di = ue((kh, Es) => {
      "use strict";
      Es.exports = (e, r = 1, t) => {
        if (t = { indent: " ", includeEmptyLines: false, ...t }, typeof e != "string") throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
        if (typeof r != "number") throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);
        if (typeof t.indent != "string") throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);
        if (r === 0) return e;
        let n = t.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return e.replace(n, t.indent.repeat(r));
      };
    });
    var vs = ue((jh, tp) => {
      tp.exports = { name: "dotenv", version: "16.5.0", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, homepage: "https://github.com/motdotla/dotenv#readme", funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
    });
    var As = ue((Bh, _e4) => {
      "use strict";
      var Fi = require("fs"), Mi = require("path"), np = require("os"), ip = require("crypto"), op = vs(), Ts = op.version, sp = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
      function ap(e) {
        let r = {}, t = e.toString();
        t = t.replace(/\r\n?/mg, `
`);
        let n;
        for (; (n = sp.exec(t)) != null; ) {
          let i = n[1], o = n[2] || "";
          o = o.trim();
          let s = o[0];
          o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), r[i] = o;
        }
        return r;
      }
      function lp(e) {
        let r = Rs(e), t = B.configDotenv({ path: r });
        if (!t.parsed) {
          let s = new Error(`MISSING_DATA: Cannot parse ${r} for an unknown reason`);
          throw s.code = "MISSING_DATA", s;
        }
        let n = Ss(e).split(","), i = n.length, o;
        for (let s = 0; s < i; s++) try {
          let a = n[s].trim(), l = cp(t, a);
          o = B.decrypt(l.ciphertext, l.key);
          break;
        } catch (a) {
          if (s + 1 >= i) throw a;
        }
        return B.parse(o);
      }
      function up(e) {
        console.log(`[dotenv@${Ts}][WARN] ${e}`);
      }
      function ot(e) {
        console.log(`[dotenv@${Ts}][DEBUG] ${e}`);
      }
      function Ss(e) {
        return e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0 ? e.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
      }
      function cp(e, r) {
        let t;
        try {
          t = new URL(r);
        } catch (a) {
          if (a.code === "ERR_INVALID_URL") {
            let l = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
            throw l.code = "INVALID_DOTENV_KEY", l;
          }
          throw a;
        }
        let n = t.password;
        if (!n) {
          let a = new Error("INVALID_DOTENV_KEY: Missing key part");
          throw a.code = "INVALID_DOTENV_KEY", a;
        }
        let i = t.searchParams.get("environment");
        if (!i) {
          let a = new Error("INVALID_DOTENV_KEY: Missing environment part");
          throw a.code = "INVALID_DOTENV_KEY", a;
        }
        let o = `DOTENV_VAULT_${i.toUpperCase()}`, s = e.parsed[o];
        if (!s) {
          let a = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);
          throw a.code = "NOT_FOUND_DOTENV_ENVIRONMENT", a;
        }
        return { ciphertext: s, key: n };
      }
      function Rs(e) {
        let r = null;
        if (e && e.path && e.path.length > 0) if (Array.isArray(e.path)) for (let t of e.path) Fi.existsSync(t) && (r = t.endsWith(".vault") ? t : `${t}.vault`);
        else r = e.path.endsWith(".vault") ? e.path : `${e.path}.vault`;
        else r = Mi.resolve(process.cwd(), ".env.vault");
        return Fi.existsSync(r) ? r : null;
      }
      function Ps(e) {
        return e[0] === "~" ? Mi.join(np.homedir(), e.slice(1)) : e;
      }
      function pp(e) {
        !!(e && e.debug) && ot("Loading env from encrypted .env.vault");
        let t = B._parseVault(e), n = process.env;
        return e && e.processEnv != null && (n = e.processEnv), B.populate(n, t, e), { parsed: t };
      }
      function dp(e) {
        let r = Mi.resolve(process.cwd(), ".env"), t = "utf8", n = !!(e && e.debug);
        e && e.encoding ? t = e.encoding : n && ot("No encoding is specified. UTF-8 is used by default");
        let i = [r];
        if (e && e.path) if (!Array.isArray(e.path)) i = [Ps(e.path)];
        else {
          i = [];
          for (let l of e.path) i.push(Ps(l));
        }
        let o, s = {};
        for (let l of i) try {
          let u = B.parse(Fi.readFileSync(l, { encoding: t }));
          B.populate(s, u, e);
        } catch (u) {
          n && ot(`Failed to load ${l} ${u.message}`), o = u;
        }
        let a = process.env;
        return e && e.processEnv != null && (a = e.processEnv), B.populate(a, s, e), o ? { parsed: s, error: o } : { parsed: s };
      }
      function mp(e) {
        if (Ss(e).length === 0) return B.configDotenv(e);
        let r = Rs(e);
        return r ? B._configVault(e) : (up(`You set DOTENV_KEY but you are missing a .env.vault file at ${r}. Did you forget to build it?`), B.configDotenv(e));
      }
      function fp(e, r) {
        let t = Buffer.from(r.slice(-64), "hex"), n = Buffer.from(e, "base64"), i = n.subarray(0, 12), o = n.subarray(-16);
        n = n.subarray(12, -16);
        try {
          let s = ip.createDecipheriv("aes-256-gcm", t, i);
          return s.setAuthTag(o), `${s.update(n)}${s.final()}`;
        } catch (s) {
          let a = s instanceof RangeError, l = s.message === "Invalid key length", u = s.message === "Unsupported state or unable to authenticate data";
          if (a || l) {
            let c = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
            throw c.code = "INVALID_DOTENV_KEY", c;
          } else if (u) {
            let c = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
            throw c.code = "DECRYPTION_FAILED", c;
          } else throw s;
        }
      }
      function gp(e, r, t = {}) {
        let n = !!(t && t.debug), i = !!(t && t.override);
        if (typeof r != "object") {
          let o = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
          throw o.code = "OBJECT_REQUIRED", o;
        }
        for (let o of Object.keys(r)) Object.prototype.hasOwnProperty.call(e, o) ? (i === true && (e[o] = r[o]), n && ot(i === true ? `"${o}" is already defined and WAS overwritten` : `"${o}" is already defined and was NOT overwritten`)) : e[o] = r[o];
      }
      var B = { configDotenv: dp, _configVault: pp, _parseVault: lp, config: mp, decrypt: fp, parse: ap, populate: gp };
      _e4.exports.configDotenv = B.configDotenv;
      _e4.exports._configVault = B._configVault;
      _e4.exports._parseVault = B._parseVault;
      _e4.exports.config = B.config;
      _e4.exports.decrypt = B.decrypt;
      _e4.exports.parse = B.parse;
      _e4.exports.populate = B.populate;
      _e4.exports = B;
    });
    var Os = ue((Kh, cn) => {
      "use strict";
      cn.exports = (e = {}) => {
        let r;
        if (e.repoUrl) r = e.repoUrl;
        else if (e.user && e.repo) r = `https://github.com/${e.user}/${e.repo}`;
        else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
        let t = new URL(`${r}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
        for (let i of n) {
          let o = e[i];
          if (o !== void 0) {
            if (i === "labels" || i === "projects") {
              if (!Array.isArray(o)) throw new TypeError(`The \`${i}\` option should be an array`);
              o = o.join(",");
            }
            t.searchParams.set(i, o);
          }
        }
        return t.toString();
      };
      cn.exports.default = cn.exports;
    });
    var Ki = ue((vb, ea) => {
      "use strict";
      ea.exports = /* @__PURE__ */ (function() {
        function e(r, t, n, i, o) {
          return r < t || n < t ? r > n ? n + 1 : r + 1 : i === o ? t : t + 1;
        }
        return function(r, t) {
          if (r === t) return 0;
          if (r.length > t.length) {
            var n = r;
            r = t, t = n;
          }
          for (var i = r.length, o = t.length; i > 0 && r.charCodeAt(i - 1) === t.charCodeAt(o - 1); ) i--, o--;
          for (var s = 0; s < i && r.charCodeAt(s) === t.charCodeAt(s); ) s++;
          if (i -= s, o -= s, i === 0 || o < 3) return o;
          var a = 0, l, u, c, p, d, f, h, g, I, T, S, b, D = [];
          for (l = 0; l < i; l++) D.push(l + 1), D.push(r.charCodeAt(s + l));
          for (var me = D.length - 1; a < o - 3; ) for (I = t.charCodeAt(s + (u = a)), T = t.charCodeAt(s + (c = a + 1)), S = t.charCodeAt(s + (p = a + 2)), b = t.charCodeAt(s + (d = a + 3)), f = a += 4, l = 0; l < me; l += 2) h = D[l], g = D[l + 1], u = e(h, u, c, I, g), c = e(u, c, p, T, g), p = e(c, p, d, S, g), f = e(p, d, f, b, g), D[l] = f, d = p, p = c, c = u, u = h;
          for (; a < o; ) for (I = t.charCodeAt(s + (u = a)), f = ++a, l = 0; l < me; l += 2) h = D[l], D[l] = f = e(h, u, f, I, D[l + 1]), u = h;
          return f;
        };
      })();
    });
    var oa = Do(() => {
      "use strict";
    });
    var sa = Do(() => {
      "use strict";
    });
    var jf = {};
    tr(jf, { DMMF: () => ct, Debug: () => N, Decimal: () => Fe, Extensions: () => ni, MetricsClient: () => Lr, PrismaClientInitializationError: () => P, PrismaClientKnownRequestError: () => z, PrismaClientRustPanicError: () => ae, PrismaClientUnknownRequestError: () => V, PrismaClientValidationError: () => Z, Public: () => ii, Sql: () => ie, createParam: () => va, defineDmmfProperty: () => Ca, deserializeJsonResponse: () => Vr, deserializeRawResult: () => Xn, dmmfToRuntimeDataModel: () => Ns, empty: () => Oa, getPrismaClient: () => fu, getRuntime: () => Kn, join: () => Da, makeStrictEnum: () => gu, makeTypedQueryFactory: () => Ia, objectEnumValues: () => On, raw: () => no, serializeJsonQuery: () => $n, skip: () => Mn, sqltag: () => io, warnEnvConflicts: () => hu, warnOnce: () => at });
    module2.exports = vu(jf);
    var ni = {};
    tr(ni, { defineExtension: () => ko, getExtensionContext: () => _o });
    function ko(e) {
      return typeof e == "function" ? e : (r) => r.$extends(e);
    }
    function _o(e) {
      return e;
    }
    var ii = {};
    tr(ii, { validator: () => No });
    function No(...e) {
      return (r) => r;
    }
    var Bt = {};
    tr(Bt, { $: () => qo, bgBlack: () => ku, bgBlue: () => Fu, bgCyan: () => $u, bgGreen: () => Nu, bgMagenta: () => Mu, bgRed: () => _u, bgWhite: () => qu, bgYellow: () => Lu, black: () => Cu, blue: () => nr, bold: () => W, cyan: () => De, dim: () => Ce, gray: () => Hr, green: () => qe, grey: () => Ou, hidden: () => Ru, inverse: () => Su, italic: () => Tu, magenta: () => Iu, red: () => ce, reset: () => Pu, strikethrough: () => Au, underline: () => Y, white: () => Du, yellow: () => Ie });
    var oi;
    var Lo;
    var Fo;
    var Mo;
    var $o = true;
    typeof process < "u" && ({ FORCE_COLOR: oi, NODE_DISABLE_COLORS: Lo, NO_COLOR: Fo, TERM: Mo } = process.env || {}, $o = process.stdout && process.stdout.isTTY);
    var qo = { enabled: !Lo && Fo == null && Mo !== "dumb" && (oi != null && oi !== "0" || $o) };
    function F(e, r) {
      let t = new RegExp(`\\x1b\\[${r}m`, "g"), n = `\x1B[${e}m`, i = `\x1B[${r}m`;
      return function(o) {
        return !qo.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(t, i + n) : o) + i;
      };
    }
    var Pu = F(0, 0);
    var W = F(1, 22);
    var Ce = F(2, 22);
    var Tu = F(3, 23);
    var Y = F(4, 24);
    var Su = F(7, 27);
    var Ru = F(8, 28);
    var Au = F(9, 29);
    var Cu = F(30, 39);
    var ce = F(31, 39);
    var qe = F(32, 39);
    var Ie = F(33, 39);
    var nr = F(34, 39);
    var Iu = F(35, 39);
    var De = F(36, 39);
    var Du = F(37, 39);
    var Hr = F(90, 39);
    var Ou = F(90, 39);
    var ku = F(40, 49);
    var _u = F(41, 49);
    var Nu = F(42, 49);
    var Lu = F(43, 49);
    var Fu = F(44, 49);
    var Mu = F(45, 49);
    var $u = F(46, 49);
    var qu = F(47, 49);
    var Vu = 100;
    var Vo = ["green", "yellow", "blue", "magenta", "cyan", "red"];
    var Yr = [];
    var jo = Date.now();
    var ju = 0;
    var si = typeof process < "u" ? process.env : {};
    globalThis.DEBUG ?? (globalThis.DEBUG = si.DEBUG ?? "");
    globalThis.DEBUG_COLORS ?? (globalThis.DEBUG_COLORS = si.DEBUG_COLORS ? si.DEBUG_COLORS === "true" : true);
    var zr = { enable(e) {
      typeof e == "string" && (globalThis.DEBUG = e);
    }, disable() {
      let e = globalThis.DEBUG;
      return globalThis.DEBUG = "", e;
    }, enabled(e) {
      let r = globalThis.DEBUG.split(",").map((i) => i.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), t = r.some((i) => i === "" || i[0] === "-" ? false : e.match(RegExp(i.split("*").join(".*") + "$"))), n = r.some((i) => i === "" || i[0] !== "-" ? false : e.match(RegExp(i.slice(1).split("*").join(".*") + "$")));
      return t && !n;
    }, log: (...e) => {
      let [r, t, ...n] = e;
      (console.warn ?? console.log)(`${r} ${t}`, ...n);
    }, formatters: {} };
    function Bu(e) {
      let r = { color: Vo[ju++ % Vo.length], enabled: zr.enabled(e), namespace: e, log: zr.log, extend: () => {
      } }, t = (...n) => {
        let { enabled: i, namespace: o, color: s, log: a } = r;
        if (n.length !== 0 && Yr.push([o, ...n]), Yr.length > Vu && Yr.shift(), zr.enabled(o) || i) {
          let l = n.map((c) => typeof c == "string" ? c : Uu(c)), u = `+${Date.now() - jo}ms`;
          jo = Date.now(), globalThis.DEBUG_COLORS ? a(Bt[s](W(o)), ...l, Bt[s](u)) : a(o, ...l, u);
        }
      };
      return new Proxy(t, { get: (n, i) => r[i], set: (n, i, o) => r[i] = o });
    }
    var N = new Proxy(Bu, { get: (e, r) => zr[r], set: (e, r, t) => zr[r] = t });
    function Uu(e, r = 2) {
      let t = /* @__PURE__ */ new Set();
      return JSON.stringify(e, (n, i) => {
        if (typeof i == "object" && i !== null) {
          if (t.has(i)) return "[Circular *]";
          t.add(i);
        } else if (typeof i == "bigint") return i.toString();
        return i;
      }, r);
    }
    function Bo(e = 7500) {
      let r = Yr.map(([t, ...n]) => `${t} ${n.map((i) => typeof i == "string" ? i : JSON.stringify(i)).join(" ")}`).join(`
`);
      return r.length < e ? r : r.slice(-e);
    }
    function Uo() {
      Yr.length = 0;
    }
    var gr = N;
    var Go = O(require("fs"));
    function ai() {
      let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
      if (!(e && Go.default.existsSync(e)) && process.arch === "ia32") throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
    }
    var li = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
    var Ut = "libquery_engine";
    function Gt(e, r) {
      let t = r === "url";
      return e.includes("windows") ? t ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? t ? `${Ut}.dylib.node` : `${Ut}-${e}.dylib.node` : t ? `${Ut}.so.node` : `${Ut}-${e}.so.node`;
    }
    var Ko = O(require("child_process"));
    var mi = O(require("fs/promises"));
    var Ht = O(require("os"));
    var Oe = Symbol.for("@ts-pattern/matcher");
    var Gu = Symbol.for("@ts-pattern/isVariadic");
    var Wt = "@ts-pattern/anonymous-select-key";
    var ui = (e) => !!(e && typeof e == "object");
    var Qt = (e) => e && !!e[Oe];
    var Ee = (e, r, t) => {
      if (Qt(e)) {
        let n = e[Oe](), { matched: i, selections: o } = n.match(r);
        return i && o && Object.keys(o).forEach((s) => t(s, o[s])), i;
      }
      if (ui(e)) {
        if (!ui(r)) return false;
        if (Array.isArray(e)) {
          if (!Array.isArray(r)) return false;
          let n = [], i = [], o = [];
          for (let s of e.keys()) {
            let a = e[s];
            Qt(a) && a[Gu] ? o.push(a) : o.length ? i.push(a) : n.push(a);
          }
          if (o.length) {
            if (o.length > 1) throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
            if (r.length < n.length + i.length) return false;
            let s = r.slice(0, n.length), a = i.length === 0 ? [] : r.slice(-i.length), l = r.slice(n.length, i.length === 0 ? 1 / 0 : -i.length);
            return n.every((u, c) => Ee(u, s[c], t)) && i.every((u, c) => Ee(u, a[c], t)) && (o.length === 0 || Ee(o[0], l, t));
          }
          return e.length === r.length && e.every((s, a) => Ee(s, r[a], t));
        }
        return Reflect.ownKeys(e).every((n) => {
          let i = e[n];
          return (n in r || Qt(o = i) && o[Oe]().matcherType === "optional") && Ee(i, r[n], t);
          var o;
        });
      }
      return Object.is(r, e);
    };
    var Ge = (e) => {
      var r, t, n;
      return ui(e) ? Qt(e) ? (r = (t = (n = e[Oe]()).getSelectionKeys) == null ? void 0 : t.call(n)) != null ? r : [] : Array.isArray(e) ? Zr(e, Ge) : Zr(Object.values(e), Ge) : [];
    };
    var Zr = (e, r) => e.reduce((t, n) => t.concat(r(n)), []);
    function pe(e) {
      return Object.assign(e, { optional: () => Qu(e), and: (r) => q(e, r), or: (r) => Wu(e, r), select: (r) => r === void 0 ? Qo(e) : Qo(r, e) });
    }
    function Qu(e) {
      return pe({ [Oe]: () => ({ match: (r) => {
        let t = {}, n = (i, o) => {
          t[i] = o;
        };
        return r === void 0 ? (Ge(e).forEach((i) => n(i, void 0)), { matched: true, selections: t }) : { matched: Ee(e, r, n), selections: t };
      }, getSelectionKeys: () => Ge(e), matcherType: "optional" }) });
    }
    function q(...e) {
      return pe({ [Oe]: () => ({ match: (r) => {
        let t = {}, n = (i, o) => {
          t[i] = o;
        };
        return { matched: e.every((i) => Ee(i, r, n)), selections: t };
      }, getSelectionKeys: () => Zr(e, Ge), matcherType: "and" }) });
    }
    function Wu(...e) {
      return pe({ [Oe]: () => ({ match: (r) => {
        let t = {}, n = (i, o) => {
          t[i] = o;
        };
        return Zr(e, Ge).forEach((i) => n(i, void 0)), { matched: e.some((i) => Ee(i, r, n)), selections: t };
      }, getSelectionKeys: () => Zr(e, Ge), matcherType: "or" }) });
    }
    function A(e) {
      return { [Oe]: () => ({ match: (r) => ({ matched: !!e(r) }) }) };
    }
    function Qo(...e) {
      let r = typeof e[0] == "string" ? e[0] : void 0, t = e.length === 2 ? e[1] : typeof e[0] == "string" ? void 0 : e[0];
      return pe({ [Oe]: () => ({ match: (n) => {
        let i = { [r ?? Wt]: n };
        return { matched: t === void 0 || Ee(t, n, (o, s) => {
          i[o] = s;
        }), selections: i };
      }, getSelectionKeys: () => [r ?? Wt].concat(t === void 0 ? [] : Ge(t)) }) });
    }
    function ye(e) {
      return typeof e == "number";
    }
    function Ve(e) {
      return typeof e == "string";
    }
    function je(e) {
      return typeof e == "bigint";
    }
    var eg = pe(A(function(e) {
      return true;
    }));
    var Be = (e) => Object.assign(pe(e), { startsWith: (r) => {
      return Be(q(e, (t = r, A((n) => Ve(n) && n.startsWith(t)))));
      var t;
    }, endsWith: (r) => {
      return Be(q(e, (t = r, A((n) => Ve(n) && n.endsWith(t)))));
      var t;
    }, minLength: (r) => Be(q(e, ((t) => A((n) => Ve(n) && n.length >= t))(r))), length: (r) => Be(q(e, ((t) => A((n) => Ve(n) && n.length === t))(r))), maxLength: (r) => Be(q(e, ((t) => A((n) => Ve(n) && n.length <= t))(r))), includes: (r) => {
      return Be(q(e, (t = r, A((n) => Ve(n) && n.includes(t)))));
      var t;
    }, regex: (r) => {
      return Be(q(e, (t = r, A((n) => Ve(n) && !!n.match(t)))));
      var t;
    } });
    var rg = Be(A(Ve));
    var be = (e) => Object.assign(pe(e), { between: (r, t) => be(q(e, ((n, i) => A((o) => ye(o) && n <= o && i >= o))(r, t))), lt: (r) => be(q(e, ((t) => A((n) => ye(n) && n < t))(r))), gt: (r) => be(q(e, ((t) => A((n) => ye(n) && n > t))(r))), lte: (r) => be(q(e, ((t) => A((n) => ye(n) && n <= t))(r))), gte: (r) => be(q(e, ((t) => A((n) => ye(n) && n >= t))(r))), int: () => be(q(e, A((r) => ye(r) && Number.isInteger(r)))), finite: () => be(q(e, A((r) => ye(r) && Number.isFinite(r)))), positive: () => be(q(e, A((r) => ye(r) && r > 0))), negative: () => be(q(e, A((r) => ye(r) && r < 0))) });
    var tg = be(A(ye));
    var Ue = (e) => Object.assign(pe(e), { between: (r, t) => Ue(q(e, ((n, i) => A((o) => je(o) && n <= o && i >= o))(r, t))), lt: (r) => Ue(q(e, ((t) => A((n) => je(n) && n < t))(r))), gt: (r) => Ue(q(e, ((t) => A((n) => je(n) && n > t))(r))), lte: (r) => Ue(q(e, ((t) => A((n) => je(n) && n <= t))(r))), gte: (r) => Ue(q(e, ((t) => A((n) => je(n) && n >= t))(r))), positive: () => Ue(q(e, A((r) => je(r) && r > 0))), negative: () => Ue(q(e, A((r) => je(r) && r < 0))) });
    var ng = Ue(A(je));
    var ig = pe(A(function(e) {
      return typeof e == "boolean";
    }));
    var og = pe(A(function(e) {
      return typeof e == "symbol";
    }));
    var sg = pe(A(function(e) {
      return e == null;
    }));
    var ag = pe(A(function(e) {
      return e != null;
    }));
    var ci = class extends Error {
      constructor(r) {
        let t;
        try {
          t = JSON.stringify(r);
        } catch {
          t = r;
        }
        super(`Pattern matching error: no pattern matches value ${t}`), this.input = void 0, this.input = r;
      }
    };
    var pi = { matched: false, value: void 0 };
    function hr(e) {
      return new di(e, pi);
    }
    var di = class e {
      constructor(r, t) {
        this.input = void 0, this.state = void 0, this.input = r, this.state = t;
      }
      with(...r) {
        if (this.state.matched) return this;
        let t = r[r.length - 1], n = [r[0]], i;
        r.length === 3 && typeof r[1] == "function" ? i = r[1] : r.length > 2 && n.push(...r.slice(1, r.length - 1));
        let o = false, s = {}, a = (u, c) => {
          o = true, s[u] = c;
        }, l = !n.some((u) => Ee(u, this.input, a)) || i && !i(this.input) ? pi : { matched: true, value: t(o ? Wt in s ? s[Wt] : s : this.input, this.input) };
        return new e(this.input, l);
      }
      when(r, t) {
        if (this.state.matched) return this;
        let n = !!r(this.input);
        return new e(this.input, n ? { matched: true, value: t(this.input, this.input) } : pi);
      }
      otherwise(r) {
        return this.state.matched ? this.state.value : r(this.input);
      }
      exhaustive() {
        if (this.state.matched) return this.state.value;
        throw new ci(this.input);
      }
      run() {
        return this.exhaustive();
      }
      returnType() {
        return this;
      }
    };
    var Ho = require("util");
    var Ju = { warn: Ie("prisma:warn") };
    var Ku = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
    function Jt(e, ...r) {
      Ku.warn() && console.warn(`${Ju.warn} ${e}`, ...r);
    }
    var Hu = (0, Ho.promisify)(Ko.default.exec);
    var ee = gr("prisma:get-platform");
    var Yu = ["1.0.x", "1.1.x", "3.0.x"];
    async function Yo() {
      let e = Ht.default.platform(), r = process.arch;
      if (e === "freebsd") {
        let s = await Yt("freebsd-version");
        if (s && s.trim().length > 0) {
          let l = /^(\d+)\.?/.exec(s);
          if (l) return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: r };
        }
      }
      if (e !== "linux") return { platform: e, arch: r };
      let t = await Zu(), n = await sc(), i = ec({ arch: r, archFromUname: n, familyDistro: t.familyDistro }), { libssl: o } = await rc(i);
      return { platform: "linux", libssl: o, arch: r, archFromUname: n, ...t };
    }
    function zu(e) {
      let r = /^ID="?([^"\n]*)"?$/im, t = /^ID_LIKE="?([^"\n]*)"?$/im, n = r.exec(e), i = n && n[1] && n[1].toLowerCase() || "", o = t.exec(e), s = o && o[1] && o[1].toLowerCase() || "", a = hr({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: void 0, familyDistro: void 0, originalDistro: l }));
      return ee(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
    }
    async function Zu() {
      let e = "/etc/os-release";
      try {
        let r = await mi.default.readFile(e, { encoding: "utf-8" });
        return zu(r);
      } catch {
        return { targetDistro: void 0, familyDistro: void 0, originalDistro: void 0 };
      }
    }
    function Xu(e) {
      let r = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
      if (r) {
        let t = `${r[1]}.x`;
        return zo(t);
      }
    }
    function Wo(e) {
      let r = /libssl\.so\.(\d)(\.\d)?/.exec(e);
      if (r) {
        let t = `${r[1]}${r[2] ?? ".0"}.x`;
        return zo(t);
      }
    }
    function zo(e) {
      let r = (() => {
        if (Xo(e)) return e;
        let t = e.split(".");
        return t[1] = "0", t.join(".");
      })();
      if (Yu.includes(r)) return r;
    }
    function ec(e) {
      return hr(e).with({ familyDistro: "musl" }, () => (ee('Trying platform-specific paths for "alpine"'), ["/lib", "/usr/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: r }) => (ee('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${r}-linux-gnu`, `/lib/${r}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ee('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: r, arch: t, archFromUname: n }) => (ee(`Don't know any platform-specific paths for "${r}" on ${t} (${n})`), []));
    }
    async function rc(e) {
      let r = 'grep -v "libssl.so.0"', t = await Jo(e);
      if (t) {
        ee(`Found libssl.so file using platform-specific paths: ${t}`);
        let o = Wo(t);
        if (ee(`The parsed libssl version is: ${o}`), o) return { libssl: o, strategy: "libssl-specific-path" };
      }
      ee('Falling back to "ldconfig" and other generic paths');
      let n = await Yt(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${r}`);
      if (n || (n = await Jo(["/lib64", "/usr/lib64", "/lib", "/usr/lib"])), n) {
        ee(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
        let o = Wo(n);
        if (ee(`The parsed libssl version is: ${o}`), o) return { libssl: o, strategy: "ldconfig" };
      }
      let i = await Yt("openssl version -v");
      if (i) {
        ee(`Found openssl binary with version: ${i}`);
        let o = Xu(i);
        if (ee(`The parsed openssl version is: ${o}`), o) return { libssl: o, strategy: "openssl-binary" };
      }
      return ee("Couldn't find any version of libssl or OpenSSL in the system"), {};
    }
    async function Jo(e) {
      for (let r of e) {
        let t = await tc(r);
        if (t) return t;
      }
    }
    async function tc(e) {
      try {
        return (await mi.default.readdir(e)).find((t) => t.startsWith("libssl.so.") && !t.startsWith("libssl.so.0"));
      } catch (r) {
        if (r.code === "ENOENT") return;
        throw r;
      }
    }
    async function ir() {
      let { binaryTarget: e } = await Zo();
      return e;
    }
    function nc(e) {
      return e.binaryTarget !== void 0;
    }
    async function fi() {
      let { memoized: e, ...r } = await Zo();
      return r;
    }
    var Kt = {};
    async function Zo() {
      if (nc(Kt)) return Promise.resolve({ ...Kt, memoized: true });
      let e = await Yo(), r = ic(e);
      return Kt = { ...e, binaryTarget: r }, { ...Kt, memoized: false };
    }
    function ic(e) {
      let { platform: r, arch: t, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a } = e;
      r === "linux" && !["x64", "arm64"].includes(t) && Jt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${t}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
      let l = "1.1.x";
      if (r === "linux" && i === void 0) {
        let c = hr({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
        Jt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
      }
      let u = "debian";
      if (r === "linux" && o === void 0 && ee(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`), r === "darwin" && t === "arm64") return "darwin-arm64";
      if (r === "darwin") return "darwin";
      if (r === "win32") return "windows";
      if (r === "freebsd") return o;
      if (r === "openbsd") return "openbsd";
      if (r === "netbsd") return "netbsd";
      if (r === "linux" && o === "nixos") return "linux-nixos";
      if (r === "linux" && t === "arm64") return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
      if (r === "linux" && t === "arm") return `linux-arm-openssl-${i || l}`;
      if (r === "linux" && o === "musl") {
        let c = "linux-musl";
        return !i || Xo(i) ? c : `${c}-openssl-${i}`;
      }
      return r === "linux" && o && i ? `${o}-openssl-${i}` : (r !== "linux" && Jt(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
    }
    async function oc(e) {
      try {
        return await e();
      } catch {
        return;
      }
    }
    function Yt(e) {
      return oc(async () => {
        let r = await Hu(e);
        return ee(`Command "${e}" successfully returned "${r.stdout}"`), r.stdout;
      });
    }
    async function sc() {
      return typeof Ht.default.machine == "function" ? Ht.default.machine() : (await Yt("uname -m"))?.trim();
    }
    function Xo(e) {
      return e.startsWith("1.");
    }
    var Xt = {};
    tr(Xt, { beep: () => kc, clearScreen: () => Cc, clearTerminal: () => Ic, cursorBackward: () => mc, cursorDown: () => pc, cursorForward: () => dc, cursorGetPosition: () => hc, cursorHide: () => Ec, cursorLeft: () => ts, cursorMove: () => cc, cursorNextLine: () => yc, cursorPrevLine: () => bc, cursorRestorePosition: () => gc, cursorSavePosition: () => fc, cursorShow: () => wc, cursorTo: () => uc, cursorUp: () => rs, enterAlternativeScreen: () => Dc, eraseDown: () => Tc, eraseEndLine: () => vc, eraseLine: () => ns, eraseLines: () => xc, eraseScreen: () => gi, eraseStartLine: () => Pc, eraseUp: () => Sc, exitAlternativeScreen: () => Oc, iTerm: () => Lc, image: () => Nc, link: () => _c, scrollDown: () => Ac, scrollUp: () => Rc });
    var Zt = O(require("process"), 1);
    var zt = globalThis.window?.document !== void 0;
    var gg = globalThis.process?.versions?.node !== void 0;
    var hg = globalThis.process?.versions?.bun !== void 0;
    var yg = globalThis.Deno?.version?.deno !== void 0;
    var bg = globalThis.process?.versions?.electron !== void 0;
    var Eg = globalThis.navigator?.userAgent?.includes("jsdom") === true;
    var wg = typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
    var xg = typeof DedicatedWorkerGlobalScope < "u" && globalThis instanceof DedicatedWorkerGlobalScope;
    var vg = typeof SharedWorkerGlobalScope < "u" && globalThis instanceof SharedWorkerGlobalScope;
    var Pg = typeof ServiceWorkerGlobalScope < "u" && globalThis instanceof ServiceWorkerGlobalScope;
    var Xr = globalThis.navigator?.userAgentData?.platform;
    var Tg = Xr === "macOS" || globalThis.navigator?.platform === "MacIntel" || globalThis.navigator?.userAgent?.includes(" Mac ") === true || globalThis.process?.platform === "darwin";
    var Sg = Xr === "Windows" || globalThis.navigator?.platform === "Win32" || globalThis.process?.platform === "win32";
    var Rg = Xr === "Linux" || globalThis.navigator?.platform?.startsWith("Linux") === true || globalThis.navigator?.userAgent?.includes(" Linux ") === true || globalThis.process?.platform === "linux";
    var Ag = Xr === "iOS" || globalThis.navigator?.platform === "MacIntel" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);
    var Cg = Xr === "Android" || globalThis.navigator?.platform === "Android" || globalThis.navigator?.userAgent?.includes(" Android ") === true || globalThis.process?.platform === "android";
    var C = "\x1B[";
    var rt = "\x1B]";
    var yr = "\x07";
    var et = ";";
    var es = !zt && Zt.default.env.TERM_PROGRAM === "Apple_Terminal";
    var ac = !zt && Zt.default.platform === "win32";
    var lc = zt ? () => {
      throw new Error("`process.cwd()` only works in Node.js, not the browser.");
    } : Zt.default.cwd;
    var uc = (e, r) => {
      if (typeof e != "number") throw new TypeError("The `x` argument is required");
      return typeof r != "number" ? C + (e + 1) + "G" : C + (r + 1) + et + (e + 1) + "H";
    };
    var cc = (e, r) => {
      if (typeof e != "number") throw new TypeError("The `x` argument is required");
      let t = "";
      return e < 0 ? t += C + -e + "D" : e > 0 && (t += C + e + "C"), r < 0 ? t += C + -r + "A" : r > 0 && (t += C + r + "B"), t;
    };
    var rs = (e = 1) => C + e + "A";
    var pc = (e = 1) => C + e + "B";
    var dc = (e = 1) => C + e + "C";
    var mc = (e = 1) => C + e + "D";
    var ts = C + "G";
    var fc = es ? "\x1B7" : C + "s";
    var gc = es ? "\x1B8" : C + "u";
    var hc = C + "6n";
    var yc = C + "E";
    var bc = C + "F";
    var Ec = C + "?25l";
    var wc = C + "?25h";
    var xc = (e) => {
      let r = "";
      for (let t = 0; t < e; t++) r += ns + (t < e - 1 ? rs() : "");
      return e && (r += ts), r;
    };
    var vc = C + "K";
    var Pc = C + "1K";
    var ns = C + "2K";
    var Tc = C + "J";
    var Sc = C + "1J";
    var gi = C + "2J";
    var Rc = C + "S";
    var Ac = C + "T";
    var Cc = "\x1Bc";
    var Ic = ac ? `${gi}${C}0f` : `${gi}${C}3J${C}H`;
    var Dc = C + "?1049h";
    var Oc = C + "?1049l";
    var kc = yr;
    var _c = (e, r) => [rt, "8", et, et, r, yr, e, rt, "8", et, et, yr].join("");
    var Nc = (e, r = {}) => {
      let t = `${rt}1337;File=inline=1`;
      return r.width && (t += `;width=${r.width}`), r.height && (t += `;height=${r.height}`), r.preserveAspectRatio === false && (t += ";preserveAspectRatio=0"), t + ":" + Buffer.from(e).toString("base64") + yr;
    };
    var Lc = { setCwd: (e = lc()) => `${rt}50;CurrentDir=${e}${yr}`, annotation(e, r = {}) {
      let t = `${rt}1337;`, n = r.x !== void 0, i = r.y !== void 0;
      if ((n || i) && !(n && i && r.length !== void 0)) throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e = e.replaceAll("|", ""), t += r.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", r.length > 0 ? t += (n ? [e, r.length, r.x, r.y] : [r.length, e]).join("|") : t += e, t + yr;
    } };
    var en = O(cs(), 1);
    function or(e, r, { target: t = "stdout", ...n } = {}) {
      return en.default[t] ? Xt.link(e, r) : n.fallback === false ? e : typeof n.fallback == "function" ? n.fallback(e, r) : `${e} (\u200B${r}\u200B)`;
    }
    or.isSupported = en.default.stdout;
    or.stderr = (e, r, t = {}) => or(e, r, { target: "stderr", ...t });
    or.stderr.isSupported = en.default.stderr;
    function wi(e) {
      return or(e, e, { fallback: Y });
    }
    var Vc = ps();
    var xi = Vc.version;
    function Er(e) {
      let r = jc();
      return r || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : e?.config.engineType === "client" ? "client" : Bc());
    }
    function jc() {
      let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
      return e === "library" ? "library" : e === "binary" ? "binary" : e === "client" ? "client" : void 0;
    }
    function Bc() {
      return "library";
    }
    function vi(e) {
      return e.name === "DriverAdapterError" && typeof e.cause == "object";
    }
    function rn(e) {
      return { ok: true, value: e, map(r) {
        return rn(r(e));
      }, flatMap(r) {
        return r(e);
      } };
    }
    function sr(e) {
      return { ok: false, error: e, map() {
        return sr(e);
      }, flatMap() {
        return sr(e);
      } };
    }
    var ds = N("driver-adapter-utils");
    var Pi = class {
      constructor() {
        __publicField(this, "registeredErrors", []);
      }
      consumeError(r) {
        return this.registeredErrors[r];
      }
      registerNewError(r) {
        let t = 0;
        for (; this.registeredErrors[t] !== void 0; ) t++;
        return this.registeredErrors[t] = { error: r }, t;
      }
    };
    var tn = (e, r = new Pi()) => {
      let t = { adapterName: e.adapterName, errorRegistry: r, queryRaw: ke(r, e.queryRaw.bind(e)), executeRaw: ke(r, e.executeRaw.bind(e)), executeScript: ke(r, e.executeScript.bind(e)), dispose: ke(r, e.dispose.bind(e)), provider: e.provider, startTransaction: async (...n) => (await ke(r, e.startTransaction.bind(e))(...n)).map((o) => Uc(r, o)) };
      return e.getConnectionInfo && (t.getConnectionInfo = Gc(r, e.getConnectionInfo.bind(e))), t;
    };
    var Uc = (e, r) => ({ adapterName: r.adapterName, provider: r.provider, options: r.options, queryRaw: ke(e, r.queryRaw.bind(r)), executeRaw: ke(e, r.executeRaw.bind(r)), commit: ke(e, r.commit.bind(r)), rollback: ke(e, r.rollback.bind(r)) });
    function ke(e, r) {
      return async (...t) => {
        try {
          return rn(await r(...t));
        } catch (n) {
          if (ds("[error@wrapAsync]", n), vi(n)) return sr(n.cause);
          let i = e.registerNewError(n);
          return sr({ kind: "GenericJs", id: i });
        }
      };
    }
    function Gc(e, r) {
      return (...t) => {
        try {
          return rn(r(...t));
        } catch (n) {
          if (ds("[error@wrapSync]", n), vi(n)) return sr(n.cause);
          let i = e.registerNewError(n);
          return sr({ kind: "GenericJs", id: i });
        }
      };
    }
    var Wc = O(on());
    var M = O(require("path"));
    var Jc = O(on());
    var wh = N("prisma:engines");
    function ms() {
      return M.default.join(__dirname, "../");
    }
    M.default.join(__dirname, "../query-engine-darwin");
    M.default.join(__dirname, "../query-engine-darwin-arm64");
    M.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
    M.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
    M.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
    M.default.join(__dirname, "../query-engine-linux-static-x64");
    M.default.join(__dirname, "../query-engine-linux-static-arm64");
    M.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
    M.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
    M.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
    M.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
    M.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
    M.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
    M.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
    M.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
    M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
    M.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
    M.default.join(__dirname, "../query_engine-windows.dll.node");
    var Si = O(require("fs"));
    var fs3 = gr("chmodPlusX");
    function Ri(e) {
      if (process.platform === "win32") return;
      let r = Si.default.statSync(e), t = r.mode | 64 | 8 | 1;
      if (r.mode === t) {
        fs3(`Execution permissions of ${e} are fine`);
        return;
      }
      let n = t.toString(8).slice(-3);
      fs3(`Have to call chmodPlusX on ${e}`), Si.default.chmodSync(e, n);
    }
    function Ai(e) {
      let r = e.e, t = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n = r.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${wi("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${Ce(e.id)}\`).`, s = hr({ message: r.message, code: r.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n && a.includes("libz"), () => `${t("libz")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libgcc_s"), () => `${t("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libssl"), () => {
        let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
        return `${t("libssl")}. Please install ${a} and try again.`;
      }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
      return `${o}
${s}

Details: ${r.message}`;
    }
    var ys = O(hs(), 1);
    function Ci(e) {
      let r = (0, ys.default)(e);
      if (r === 0) return e;
      let t = new RegExp(`^[ \\t]{${r}}`, "gm");
      return e.replace(t, "");
    }
    var bs = "prisma+postgres";
    var sn = `${bs}:`;
    function an(e) {
      return e?.toString().startsWith(`${sn}//`) ?? false;
    }
    function Ii(e) {
      if (!an(e)) return false;
      let { host: r } = new URL(e);
      return r.includes("localhost") || r.includes("127.0.0.1") || r.includes("[::1]");
    }
    var ws = O(Di());
    function ki(e) {
      return String(new Oi(e));
    }
    var Oi = class {
      constructor(r) {
        this.config = r;
      }
      toString() {
        let { config: r } = this, t = r.provider.fromEnvVar ? `env("${r.provider.fromEnvVar}")` : r.provider.value, n = JSON.parse(JSON.stringify({ provider: t, binaryTargets: Kc(r.binaryTargets) }));
        return `generator ${r.name} {
${(0, ws.default)(Hc(n), 2)}
}`;
      }
    };
    function Kc(e) {
      let r;
      if (e.length > 0) {
        let t = e.find((n) => n.fromEnvVar !== null);
        t ? r = `env("${t.fromEnvVar}")` : r = e.map((n) => n.native ? "native" : n.value);
      } else r = void 0;
      return r;
    }
    function Hc(e) {
      let r = Object.keys(e).reduce((t, n) => Math.max(t, n.length), 0);
      return Object.entries(e).map(([t, n]) => `${t.padEnd(r)} = ${Yc(n)}`).join(`
`);
    }
    function Yc(e) {
      return JSON.parse(JSON.stringify(e, (r, t) => Array.isArray(t) ? `[${t.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(t)));
    }
    var nt = {};
    tr(nt, { error: () => Xc, info: () => Zc, log: () => zc, query: () => ep, should: () => xs, tags: () => tt, warn: () => _i });
    var tt = { error: ce("prisma:error"), warn: Ie("prisma:warn"), info: De("prisma:info"), query: nr("prisma:query") };
    var xs = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
    function zc(...e) {
      console.log(...e);
    }
    function _i(e, ...r) {
      xs.warn() && console.warn(`${tt.warn} ${e}`, ...r);
    }
    function Zc(e, ...r) {
      console.info(`${tt.info} ${e}`, ...r);
    }
    function Xc(e, ...r) {
      console.error(`${tt.error} ${e}`, ...r);
    }
    function ep(e, ...r) {
      console.log(`${tt.query} ${e}`, ...r);
    }
    function ln(e, r) {
      if (!e) throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
    }
    function ar(e, r) {
      throw new Error(r);
    }
    function Ni({ onlyFirst: e = false } = {}) {
      let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
      return new RegExp(t, e ? void 0 : "g");
    }
    var rp = Ni();
    function wr(e) {
      if (typeof e != "string") throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
      return e.replace(rp, "");
    }
    var it = O(require("path"));
    function Li(e) {
      return it.default.sep === it.default.posix.sep ? e : e.split(it.default.sep).join(it.default.posix.sep);
    }
    var qi = O(As());
    var un = O(require("fs"));
    var xr = O(require("path"));
    function Cs(e) {
      let r = e.ignoreProcessEnv ? {} : process.env, t = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
        let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
        if (!a) return o;
        let l = a[1], u, c;
        if (l === "\\") c = a[0], u = c.replace("\\$", "$");
        else {
          let p = a[2];
          c = a[0].substring(l.length), u = Object.hasOwnProperty.call(r, p) ? r[p] : e.parsed[p] || "", u = t(u);
        }
        return o.replace(c, u);
      }, n) ?? n;
      for (let n in e.parsed) {
        let i = Object.hasOwnProperty.call(r, n) ? r[n] : e.parsed[n];
        e.parsed[n] = t(i);
      }
      for (let n in e.parsed) r[n] = e.parsed[n];
      return e;
    }
    var $i = gr("prisma:tryLoadEnv");
    function st({ rootEnvPath: e, schemaEnvPath: r }, t = { conflictCheck: "none" }) {
      let n = Is(e);
      t.conflictCheck !== "none" && hp(n, r, t.conflictCheck);
      let i = null;
      return Ds(n?.path, r) || (i = Is(r)), !n && !i && $i("No Environment variables loaded"), i?.dotenvResult.error ? console.error(ce(W("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
    }
    function hp(e, r, t) {
      let n = e?.dotenvResult.parsed, i = !Ds(e?.path, r);
      if (n && r && i && un.default.existsSync(r)) {
        let o = qi.default.parse(un.default.readFileSync(r)), s = [];
        for (let a in o) n[a] === o[a] && s.push(a);
        if (s.length > 0) {
          let a = xr.default.relative(process.cwd(), e.path), l = xr.default.relative(process.cwd(), r);
          if (t === "error") {
            let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${Y(a)} and ${Y(l)}
Conflicting env vars:
${s.map((c) => `  ${W(c)}`).join(`
`)}

We suggest to move the contents of ${Y(l)} to ${Y(a)} to consolidate your env vars.
`;
            throw new Error(u);
          } else if (t === "warn") {
            let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => W(c)).join(", ")} in ${Y(a)} and ${Y(l)}
Env vars from ${Y(l)} overwrite the ones from ${Y(a)}
      `;
            console.warn(`${Ie("warn(prisma)")} ${u}`);
          }
        }
      }
    }
    function Is(e) {
      if (yp(e)) {
        $i(`Environment variables loaded from ${e}`);
        let r = qi.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0 });
        return { dotenvResult: Cs(r), message: Ce(`Environment variables loaded from ${xr.default.relative(process.cwd(), e)}`), path: e };
      } else $i(`Environment variables not found at ${e}`);
      return null;
    }
    function Ds(e, r) {
      return e && r && xr.default.resolve(e) === xr.default.resolve(r);
    }
    function yp(e) {
      return !!(e && un.default.existsSync(e));
    }
    function Vi(e, r) {
      return Object.prototype.hasOwnProperty.call(e, r);
    }
    function pn(e, r) {
      let t = {};
      for (let n of Object.keys(e)) t[n] = r(e[n], n);
      return t;
    }
    function ji(e, r) {
      if (e.length === 0) return;
      let t = e[0];
      for (let n = 1; n < e.length; n++) r(t, e[n]) < 0 && (t = e[n]);
      return t;
    }
    function x(e, r) {
      Object.defineProperty(e, "name", { value: r, configurable: true });
    }
    var ks = /* @__PURE__ */ new Set();
    var at = (e, r, ...t) => {
      ks.has(e) || (ks.add(e), _i(r, ...t));
    };
    var P = class e extends Error {
      constructor(r, t, n) {
        super(r);
        __publicField(this, "clientVersion");
        __publicField(this, "errorCode");
        __publicField(this, "retryable");
        this.name = "PrismaClientInitializationError", this.clientVersion = t, this.errorCode = n, Error.captureStackTrace(e);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    x(P, "PrismaClientInitializationError");
    var z = class extends Error {
      constructor(r, { code: t, clientVersion: n, meta: i, batchRequestIdx: o }) {
        super(r);
        __publicField(this, "code");
        __publicField(this, "meta");
        __publicField(this, "clientVersion");
        __publicField(this, "batchRequestIdx");
        this.name = "PrismaClientKnownRequestError", this.code = t, this.clientVersion = n, this.meta = i, Object.defineProperty(this, "batchRequestIdx", { value: o, enumerable: false, writable: true });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    x(z, "PrismaClientKnownRequestError");
    var ae = class extends Error {
      constructor(r, t) {
        super(r);
        __publicField(this, "clientVersion");
        this.name = "PrismaClientRustPanicError", this.clientVersion = t;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    x(ae, "PrismaClientRustPanicError");
    var V = class extends Error {
      constructor(r, { clientVersion: t, batchRequestIdx: n }) {
        super(r);
        __publicField(this, "clientVersion");
        __publicField(this, "batchRequestIdx");
        this.name = "PrismaClientUnknownRequestError", this.clientVersion = t, Object.defineProperty(this, "batchRequestIdx", { value: n, writable: true, enumerable: false });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    x(V, "PrismaClientUnknownRequestError");
    var Z = class extends Error {
      constructor(r, { clientVersion: t }) {
        super(r);
        __publicField(this, "name", "PrismaClientValidationError");
        __publicField(this, "clientVersion");
        this.clientVersion = t;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    x(Z, "PrismaClientValidationError");
    var we = class {
      constructor() {
        __publicField(this, "_map", /* @__PURE__ */ new Map());
      }
      get(r) {
        return this._map.get(r)?.value;
      }
      set(r, t) {
        this._map.set(r, { value: t });
      }
      getOrCreate(r, t) {
        let n = this._map.get(r);
        if (n) return n.value;
        let i = t();
        return this.set(r, i), i;
      }
    };
    function We(e) {
      return e.substring(0, 1).toLowerCase() + e.substring(1);
    }
    function _s(e, r) {
      let t = {};
      for (let n of e) {
        let i = n[r];
        t[i] = n;
      }
      return t;
    }
    function lt(e) {
      let r;
      return { get() {
        return r || (r = { value: e() }), r.value;
      } };
    }
    function Ns(e) {
      return { models: Bi(e.models), enums: Bi(e.enums), types: Bi(e.types) };
    }
    function Bi(e) {
      let r = {};
      for (let { name: t, ...n } of e) r[t] = n;
      return r;
    }
    function vr(e) {
      return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
    }
    function mn(e) {
      return e.toString() !== "Invalid Date";
    }
    var Pr = 9e15;
    var Ye = 1e9;
    var Ui = "0123456789abcdef";
    var hn = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var yn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var Gi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -Pr, maxE: Pr, crypto: false };
    var $s;
    var Ne;
    var w = true;
    var En = "[DecimalError] ";
    var He = En + "Invalid argument: ";
    var qs = En + "Precision limit exceeded";
    var Vs = En + "crypto unavailable";
    var js = "[object Decimal]";
    var X = Math.floor;
    var U = Math.pow;
    var bp = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var Ep = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var wp = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var Bs = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var fe = 1e7;
    var E = 7;
    var xp = 9007199254740991;
    var vp = hn.length - 1;
    var Qi = yn.length - 1;
    var m = { toStringTag: js };
    m.absoluteValue = m.abs = function() {
      var e = new this.constructor(this);
      return e.s < 0 && (e.s = 1), y(e);
    };
    m.ceil = function() {
      return y(new this.constructor(this), this.e + 1, 2);
    };
    m.clampedTo = m.clamp = function(e, r) {
      var t, n = this, i = n.constructor;
      if (e = new i(e), r = new i(r), !e.s || !r.s) return new i(NaN);
      if (e.gt(r)) throw Error(He + r);
      return t = n.cmp(e), t < 0 ? e : n.cmp(r) > 0 ? r : new i(n);
    };
    m.comparedTo = m.cmp = function(e) {
      var r, t, n, i, o = this, s = o.d, a = (e = new o.constructor(e)).d, l = o.s, u = e.s;
      if (!s || !a) return !l || !u ? NaN : l !== u ? l : s === a ? 0 : !s ^ l < 0 ? 1 : -1;
      if (!s[0] || !a[0]) return s[0] ? l : a[0] ? -u : 0;
      if (l !== u) return l;
      if (o.e !== e.e) return o.e > e.e ^ l < 0 ? 1 : -1;
      for (n = s.length, i = a.length, r = 0, t = n < i ? n : i; r < t; ++r) if (s[r] !== a[r]) return s[r] > a[r] ^ l < 0 ? 1 : -1;
      return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
    };
    m.cosine = m.cos = function() {
      var e, r, t = this, n = t.constructor;
      return t.d ? t.d[0] ? (e = n.precision, r = n.rounding, n.precision = e + Math.max(t.e, t.sd()) + E, n.rounding = 1, t = Pp(n, Js(n, t)), n.precision = e, n.rounding = r, y(Ne == 2 || Ne == 3 ? t.neg() : t, e, r, true)) : new n(1) : new n(NaN);
    };
    m.cubeRoot = m.cbrt = function() {
      var e, r, t, n, i, o, s, a, l, u, c = this, p = c.constructor;
      if (!c.isFinite() || c.isZero()) return new p(c);
      for (w = false, o = c.s * U(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (t = J(c.d), e = c.e, (o = (e - t.length + 1) % 3) && (t += o == 1 || o == -2 ? "0" : "00"), o = U(t, 1 / 3), e = X((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? t = "5e" + e : (t = o.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), n = new p(t), n.s = c.s) : n = new p(o.toString()), s = (e = p.precision) + 3; ; ) if (a = n, l = a.times(a).times(a), u = l.plus(c), n = L(u.plus(c).times(a), u.plus(l), s + 2, 1), J(a.d).slice(0, s) === (t = J(n.d)).slice(0, s)) if (t = t.slice(s - 3, s + 1), t == "9999" || !i && t == "4999") {
        if (!i && (y(a, e + 1, 0), a.times(a).times(a).eq(c))) {
          n = a;
          break;
        }
        s += 4, i = 1;
      } else {
        (!+t || !+t.slice(1) && t.charAt(0) == "5") && (y(n, e + 1, 1), r = !n.times(n).times(n).eq(c));
        break;
      }
      return w = true, y(n, e, p.rounding, r);
    };
    m.decimalPlaces = m.dp = function() {
      var e, r = this.d, t = NaN;
      if (r) {
        if (e = r.length - 1, t = (e - X(this.e / E)) * E, e = r[e], e) for (; e % 10 == 0; e /= 10) t--;
        t < 0 && (t = 0);
      }
      return t;
    };
    m.dividedBy = m.div = function(e) {
      return L(this, new this.constructor(e));
    };
    m.dividedToIntegerBy = m.divToInt = function(e) {
      var r = this, t = r.constructor;
      return y(L(r, new t(e), 0, 1, 1), t.precision, t.rounding);
    };
    m.equals = m.eq = function(e) {
      return this.cmp(e) === 0;
    };
    m.floor = function() {
      return y(new this.constructor(this), this.e + 1, 3);
    };
    m.greaterThan = m.gt = function(e) {
      return this.cmp(e) > 0;
    };
    m.greaterThanOrEqualTo = m.gte = function(e) {
      var r = this.cmp(e);
      return r == 1 || r === 0;
    };
    m.hyperbolicCosine = m.cosh = function() {
      var e, r, t, n, i, o = this, s = o.constructor, a = new s(1);
      if (!o.isFinite()) return new s(o.s ? 1 / 0 : NaN);
      if (o.isZero()) return a;
      t = s.precision, n = s.rounding, s.precision = t + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e = Math.ceil(i / 3), r = (1 / xn(4, e)).toString()) : (e = 16, r = "2.3283064365386962890625e-10"), o = Tr(s, 1, o.times(r), new s(1), true);
      for (var l, u = e, c = new s(8); u--; ) l = o.times(o), o = a.minus(l.times(c.minus(l.times(c))));
      return y(o, s.precision = t, s.rounding = n, true);
    };
    m.hyperbolicSine = m.sinh = function() {
      var e, r, t, n, i = this, o = i.constructor;
      if (!i.isFinite() || i.isZero()) return new o(i);
      if (r = o.precision, t = o.rounding, o.precision = r + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3) i = Tr(o, 2, i, i, true);
      else {
        e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / xn(5, e)), i = Tr(o, 2, i, i, true);
        for (var s, a = new o(5), l = new o(16), u = new o(20); e--; ) s = i.times(i), i = i.times(a.plus(s.times(l.times(s).plus(u))));
      }
      return o.precision = r, o.rounding = t, y(i, r, t, true);
    };
    m.hyperbolicTangent = m.tanh = function() {
      var e, r, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 7, n.rounding = 1, L(t.sinh(), t.cosh(), n.precision = e, n.rounding = r)) : new n(t.s);
    };
    m.inverseCosine = m.acos = function() {
      var e = this, r = e.constructor, t = e.abs().cmp(1), n = r.precision, i = r.rounding;
      return t !== -1 ? t === 0 ? e.isNeg() ? xe(r, n, i) : new r(0) : new r(NaN) : e.isZero() ? xe(r, n + 4, i).times(0.5) : (r.precision = n + 6, r.rounding = 1, e = new r(1).minus(e).div(e.plus(1)).sqrt().atan(), r.precision = n, r.rounding = i, e.times(2));
    };
    m.inverseHyperbolicCosine = m.acosh = function() {
      var e, r, t = this, n = t.constructor;
      return t.lte(1) ? new n(t.eq(1) ? 0 : NaN) : t.isFinite() ? (e = n.precision, r = n.rounding, n.precision = e + Math.max(Math.abs(t.e), t.sd()) + 4, n.rounding = 1, w = false, t = t.times(t).minus(1).sqrt().plus(t), w = true, n.precision = e, n.rounding = r, t.ln()) : new n(t);
    };
    m.inverseHyperbolicSine = m.asinh = function() {
      var e, r, t = this, n = t.constructor;
      return !t.isFinite() || t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 2 * Math.max(Math.abs(t.e), t.sd()) + 6, n.rounding = 1, w = false, t = t.times(t).plus(1).sqrt().plus(t), w = true, n.precision = e, n.rounding = r, t.ln());
    };
    m.inverseHyperbolicTangent = m.atanh = function() {
      var e, r, t, n, i = this, o = i.constructor;
      return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o.precision, r = o.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? y(new o(i), e, r, true) : (o.precision = t = n - i.e, i = L(i.plus(1), new o(1).minus(i), t + e, 1), o.precision = e + 4, o.rounding = 1, i = i.ln(), o.precision = e, o.rounding = r, i.times(0.5))) : new o(NaN);
    };
    m.inverseSine = m.asin = function() {
      var e, r, t, n, i = this, o = i.constructor;
      return i.isZero() ? new o(i) : (r = i.abs().cmp(1), t = o.precision, n = o.rounding, r !== -1 ? r === 0 ? (e = xe(o, t + 4, n).times(0.5), e.s = i.s, e) : new o(NaN) : (o.precision = t + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = t, o.rounding = n, i.times(2)));
    };
    m.inverseTangent = m.atan = function() {
      var e, r, t, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding;
      if (u.isFinite()) {
        if (u.isZero()) return new c(u);
        if (u.abs().eq(1) && p + 4 <= Qi) return s = xe(c, p + 4, d).times(0.25), s.s = u.s, s;
      } else {
        if (!u.s) return new c(NaN);
        if (p + 4 <= Qi) return s = xe(c, p + 4, d).times(0.5), s.s = u.s, s;
      }
      for (c.precision = a = p + 10, c.rounding = 1, t = Math.min(28, a / E + 2 | 0), e = t; e; --e) u = u.div(u.times(u).plus(1).sqrt().plus(1));
      for (w = false, r = Math.ceil(a / E), n = 1, l = u.times(u), s = new c(u), i = u; e !== -1; ) if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[r] !== void 0) for (e = r; s.d[e] === o.d[e] && e--; ) ;
      return t && (s = s.times(2 << t - 1)), w = true, y(s, c.precision = p, c.rounding = d, true);
    };
    m.isFinite = function() {
      return !!this.d;
    };
    m.isInteger = m.isInt = function() {
      return !!this.d && X(this.e / E) > this.d.length - 2;
    };
    m.isNaN = function() {
      return !this.s;
    };
    m.isNegative = m.isNeg = function() {
      return this.s < 0;
    };
    m.isPositive = m.isPos = function() {
      return this.s > 0;
    };
    m.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    m.lessThan = m.lt = function(e) {
      return this.cmp(e) < 0;
    };
    m.lessThanOrEqualTo = m.lte = function(e) {
      return this.cmp(e) < 1;
    };
    m.logarithm = m.log = function(e) {
      var r, t, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding, f = 5;
      if (e == null) e = new c(10), r = true;
      else {
        if (e = new c(e), t = e.d, e.s < 0 || !t || !t[0] || e.eq(1)) return new c(NaN);
        r = e.eq(10);
      }
      if (t = u.d, u.s < 0 || !t || !t[0] || u.eq(1)) return new c(t && !t[0] ? -1 / 0 : u.s != 1 ? NaN : t ? 0 : 1 / 0);
      if (r) if (t.length > 1) o = true;
      else {
        for (i = t[0]; i % 10 === 0; ) i /= 10;
        o = i !== 1;
      }
      if (w = false, a = p + f, s = Ke(u, a), n = r ? bn(c, a + 10) : Ke(e, a), l = L(s, n, a, 1), ut(l.d, i = p, d)) do
        if (a += 10, s = Ke(u, a), n = r ? bn(c, a + 10) : Ke(e, a), l = L(s, n, a, 1), !o) {
          +J(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = y(l, p + 1, 0));
          break;
        }
      while (ut(l.d, i += 10, d));
      return w = true, y(l, p, d);
    };
    m.minus = m.sub = function(e) {
      var r, t, n, i, o, s, a, l, u, c, p, d, f = this, h = f.constructor;
      if (e = new h(e), !f.d || !e.d) return !f.s || !e.s ? e = new h(NaN) : f.d ? e.s = -e.s : e = new h(e.d || f.s !== e.s ? f : NaN), e;
      if (f.s != e.s) return e.s = -e.s, f.plus(e);
      if (u = f.d, d = e.d, a = h.precision, l = h.rounding, !u[0] || !d[0]) {
        if (d[0]) e.s = -e.s;
        else if (u[0]) e = new h(f);
        else return new h(l === 3 ? -0 : 0);
        return w ? y(e, a, l) : e;
      }
      if (t = X(e.e / E), c = X(f.e / E), u = u.slice(), o = c - t, o) {
        for (p = o < 0, p ? (r = u, o = -o, s = d.length) : (r = d, t = c, s = u.length), n = Math.max(Math.ceil(a / E), s) + 2, o > n && (o = n, r.length = 1), r.reverse(), n = o; n--; ) r.push(0);
        r.reverse();
      } else {
        for (n = u.length, s = d.length, p = n < s, p && (s = n), n = 0; n < s; n++) if (u[n] != d[n]) {
          p = u[n] < d[n];
          break;
        }
        o = 0;
      }
      for (p && (r = u, u = d, d = r, e.s = -e.s), s = u.length, n = d.length - s; n > 0; --n) u[s++] = 0;
      for (n = d.length; n > o; ) {
        if (u[--n] < d[n]) {
          for (i = n; i && u[--i] === 0; ) u[i] = fe - 1;
          --u[i], u[n] += fe;
        }
        u[n] -= d[n];
      }
      for (; u[--s] === 0; ) u.pop();
      for (; u[0] === 0; u.shift()) --t;
      return u[0] ? (e.d = u, e.e = wn(u, t), w ? y(e, a, l) : e) : new h(l === 3 ? -0 : 0);
    };
    m.modulo = m.mod = function(e) {
      var r, t = this, n = t.constructor;
      return e = new n(e), !t.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || t.d && !t.d[0] ? y(new n(t), n.precision, n.rounding) : (w = false, n.modulo == 9 ? (r = L(t, e.abs(), 0, 3, 1), r.s *= e.s) : r = L(t, e, 0, n.modulo, 1), r = r.times(e), w = true, t.minus(r));
    };
    m.naturalExponential = m.exp = function() {
      return Wi(this);
    };
    m.naturalLogarithm = m.ln = function() {
      return Ke(this);
    };
    m.negated = m.neg = function() {
      var e = new this.constructor(this);
      return e.s = -e.s, y(e);
    };
    m.plus = m.add = function(e) {
      var r, t, n, i, o, s, a, l, u, c, p = this, d = p.constructor;
      if (e = new d(e), !p.d || !e.d) return !p.s || !e.s ? e = new d(NaN) : p.d || (e = new d(e.d || p.s === e.s ? p : NaN)), e;
      if (p.s != e.s) return e.s = -e.s, p.minus(e);
      if (u = p.d, c = e.d, a = d.precision, l = d.rounding, !u[0] || !c[0]) return c[0] || (e = new d(p)), w ? y(e, a, l) : e;
      if (o = X(p.e / E), n = X(e.e / E), u = u.slice(), i = o - n, i) {
        for (i < 0 ? (t = u, i = -i, s = c.length) : (t = c, n = o, s = u.length), o = Math.ceil(a / E), s = o > s ? o + 1 : s + 1, i > s && (i = s, t.length = 1), t.reverse(); i--; ) t.push(0);
        t.reverse();
      }
      for (s = u.length, i = c.length, s - i < 0 && (i = s, t = c, c = u, u = t), r = 0; i; ) r = (u[--i] = u[i] + c[i] + r) / fe | 0, u[i] %= fe;
      for (r && (u.unshift(r), ++n), s = u.length; u[--s] == 0; ) u.pop();
      return e.d = u, e.e = wn(u, n), w ? y(e, a, l) : e;
    };
    m.precision = m.sd = function(e) {
      var r, t = this;
      if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(He + e);
      return t.d ? (r = Us(t.d), e && t.e + 1 > r && (r = t.e + 1)) : r = NaN, r;
    };
    m.round = function() {
      var e = this, r = e.constructor;
      return y(new r(e), e.e + 1, r.rounding);
    };
    m.sine = m.sin = function() {
      var e, r, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + Math.max(t.e, t.sd()) + E, n.rounding = 1, t = Sp(n, Js(n, t)), n.precision = e, n.rounding = r, y(Ne > 2 ? t.neg() : t, e, r, true)) : new n(NaN);
    };
    m.squareRoot = m.sqrt = function() {
      var e, r, t, n, i, o, s = this, a = s.d, l = s.e, u = s.s, c = s.constructor;
      if (u !== 1 || !a || !a[0]) return new c(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
      for (w = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (r = J(a), (r.length + l) % 2 == 0 && (r += "0"), u = Math.sqrt(r), l = X((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? r = "5e" + l : (r = u.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + l), n = new c(r)) : n = new c(u.toString()), t = (l = c.precision) + 3; ; ) if (o = n, n = o.plus(L(s, o, t + 2, 1)).times(0.5), J(o.d).slice(0, t) === (r = J(n.d)).slice(0, t)) if (r = r.slice(t - 3, t + 1), r == "9999" || !i && r == "4999") {
        if (!i && (y(o, l + 1, 0), o.times(o).eq(s))) {
          n = o;
          break;
        }
        t += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (y(n, l + 1, 1), e = !n.times(n).eq(s));
        break;
      }
      return w = true, y(n, l, c.rounding, e);
    };
    m.tangent = m.tan = function() {
      var e, r, t = this, n = t.constructor;
      return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 10, n.rounding = 1, t = t.sin(), t.s = 1, t = L(t, new n(1).minus(t.times(t)).sqrt(), e + 10, 0), n.precision = e, n.rounding = r, y(Ne == 2 || Ne == 4 ? t.neg() : t, e, r, true)) : new n(NaN);
    };
    m.times = m.mul = function(e) {
      var r, t, n, i, o, s, a, l, u, c = this, p = c.constructor, d = c.d, f = (e = new p(e)).d;
      if (e.s *= c.s, !d || !d[0] || !f || !f[0]) return new p(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : !d || !f ? e.s / 0 : e.s * 0);
      for (t = X(c.e / E) + X(e.e / E), l = d.length, u = f.length, l < u && (o = d, d = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s; n--; ) o.push(0);
      for (n = u; --n >= 0; ) {
        for (r = 0, i = l + n; i > n; ) a = o[i] + f[n] * d[i - n - 1] + r, o[i--] = a % fe | 0, r = a / fe | 0;
        o[i] = (o[i] + r) % fe | 0;
      }
      for (; !o[--s]; ) o.pop();
      return r ? ++t : o.shift(), e.d = o, e.e = wn(o, t), w ? y(e, p.precision, p.rounding) : e;
    };
    m.toBinary = function(e, r) {
      return Ji(this, 2, e, r);
    };
    m.toDecimalPlaces = m.toDP = function(e, r) {
      var t = this, n = t.constructor;
      return t = new n(t), e === void 0 ? t : (ne(e, 0, Ye), r === void 0 ? r = n.rounding : ne(r, 0, 8), y(t, e + t.e + 1, r));
    };
    m.toExponential = function(e, r) {
      var t, n = this, i = n.constructor;
      return e === void 0 ? t = ve(n, true) : (ne(e, 0, Ye), r === void 0 ? r = i.rounding : ne(r, 0, 8), n = y(new i(n), e + 1, r), t = ve(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + t : t;
    };
    m.toFixed = function(e, r) {
      var t, n, i = this, o = i.constructor;
      return e === void 0 ? t = ve(i) : (ne(e, 0, Ye), r === void 0 ? r = o.rounding : ne(r, 0, 8), n = y(new o(i), e + i.e + 1, r), t = ve(n, false, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + t : t;
    };
    m.toFraction = function(e) {
      var r, t, n, i, o, s, a, l, u, c, p, d, f = this, h = f.d, g = f.constructor;
      if (!h) return new g(f);
      if (u = t = new g(1), n = l = new g(0), r = new g(n), o = r.e = Us(h) - f.e - 1, s = o % E, r.d[0] = U(10, s < 0 ? E + s : s), e == null) e = o > 0 ? r : u;
      else {
        if (a = new g(e), !a.isInt() || a.lt(u)) throw Error(He + a);
        e = a.gt(r) ? o > 0 ? r : u : a;
      }
      for (w = false, a = new g(J(h)), c = g.precision, g.precision = o = h.length * E * 2; p = L(a, r, 0, 1, 1), i = t.plus(p.times(n)), i.cmp(e) != 1; ) t = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = r, r = a.minus(p.times(i)), a = i;
      return i = L(e.minus(t), n, 0, 1, 1), l = l.plus(i.times(u)), t = t.plus(i.times(n)), l.s = u.s = f.s, d = L(u, n, o, 1).minus(f).abs().cmp(L(l, t, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, t], g.precision = c, w = true, d;
    };
    m.toHexadecimal = m.toHex = function(e, r) {
      return Ji(this, 16, e, r);
    };
    m.toNearest = function(e, r) {
      var t = this, n = t.constructor;
      if (t = new n(t), e == null) {
        if (!t.d) return t;
        e = new n(1), r = n.rounding;
      } else {
        if (e = new n(e), r === void 0 ? r = n.rounding : ne(r, 0, 8), !t.d) return e.s ? t : e;
        if (!e.d) return e.s && (e.s = t.s), e;
      }
      return e.d[0] ? (w = false, t = L(t, e, 0, r, 1).times(e), w = true, y(t)) : (e.s = t.s, t = e), t;
    };
    m.toNumber = function() {
      return +this;
    };
    m.toOctal = function(e, r) {
      return Ji(this, 8, e, r);
    };
    m.toPower = m.pow = function(e) {
      var r, t, n, i, o, s, a = this, l = a.constructor, u = +(e = new l(e));
      if (!a.d || !e.d || !a.d[0] || !e.d[0]) return new l(U(+a, u));
      if (a = new l(a), a.eq(1)) return a;
      if (n = l.precision, o = l.rounding, e.eq(1)) return y(a, n, o);
      if (r = X(e.e / E), r >= e.d.length - 1 && (t = u < 0 ? -u : u) <= xp) return i = Gs(l, a, t, n), e.s < 0 ? new l(1).div(i) : y(i, n, o);
      if (s = a.s, s < 0) {
        if (r < e.d.length - 1) return new l(NaN);
        if ((e.d[r] & 1) == 0 && (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1) return a.s = s, a;
      }
      return t = U(+a, u), r = t == 0 || !isFinite(t) ? X(u * (Math.log("0." + J(a.d)) / Math.LN10 + a.e + 1)) : new l(t + "").e, r > l.maxE + 1 || r < l.minE - 1 ? new l(r > 0 ? s / 0 : 0) : (w = false, l.rounding = a.s = 1, t = Math.min(12, (r + "").length), i = Wi(e.times(Ke(a, n + t)), n), i.d && (i = y(i, n + 5, 1), ut(i.d, n, o) && (r = n + 10, i = y(Wi(e.times(Ke(a, r + t)), r), r + 5, 1), +J(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = y(i, n + 1, 0)))), i.s = s, w = true, l.rounding = o, y(i, n, o));
    };
    m.toPrecision = function(e, r) {
      var t, n = this, i = n.constructor;
      return e === void 0 ? t = ve(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (ne(e, 1, Ye), r === void 0 ? r = i.rounding : ne(r, 0, 8), n = y(new i(n), e, r), t = ve(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + t : t;
    };
    m.toSignificantDigits = m.toSD = function(e, r) {
      var t = this, n = t.constructor;
      return e === void 0 ? (e = n.precision, r = n.rounding) : (ne(e, 1, Ye), r === void 0 ? r = n.rounding : ne(r, 0, 8)), y(new n(t), e, r);
    };
    m.toString = function() {
      var e = this, r = e.constructor, t = ve(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
      return e.isNeg() && !e.isZero() ? "-" + t : t;
    };
    m.truncated = m.trunc = function() {
      return y(new this.constructor(this), this.e + 1, 1);
    };
    m.valueOf = m.toJSON = function() {
      var e = this, r = e.constructor, t = ve(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
      return e.isNeg() ? "-" + t : t;
    };
    function J(e) {
      var r, t, n, i = e.length - 1, o = "", s = e[0];
      if (i > 0) {
        for (o += s, r = 1; r < i; r++) n = e[r] + "", t = E - n.length, t && (o += Je(t)), o += n;
        s = e[r], n = s + "", t = E - n.length, t && (o += Je(t));
      } else if (s === 0) return "0";
      for (; s % 10 === 0; ) s /= 10;
      return o + s;
    }
    function ne(e, r, t) {
      if (e !== ~~e || e < r || e > t) throw Error(He + e);
    }
    function ut(e, r, t, n) {
      var i, o, s, a;
      for (o = e[0]; o >= 10; o /= 10) --r;
      return --r < 0 ? (r += E, i = 0) : (i = Math.ceil((r + 1) / E), r %= E), o = U(10, E - r), a = e[i] % o | 0, n == null ? r < 3 ? (r == 0 ? a = a / 100 | 0 : r == 1 && (a = a / 10 | 0), s = t < 4 && a == 99999 || t > 3 && a == 49999 || a == 5e4 || a == 0) : s = (t < 4 && a + 1 == o || t > 3 && a + 1 == o / 2) && (e[i + 1] / o / 100 | 0) == U(10, r - 2) - 1 || (a == o / 2 || a == 0) && (e[i + 1] / o / 100 | 0) == 0 : r < 4 ? (r == 0 ? a = a / 1e3 | 0 : r == 1 ? a = a / 100 | 0 : r == 2 && (a = a / 10 | 0), s = (n || t < 4) && a == 9999 || !n && t > 3 && a == 4999) : s = ((n || t < 4) && a + 1 == o || !n && t > 3 && a + 1 == o / 2) && (e[i + 1] / o / 1e3 | 0) == U(10, r - 3) - 1, s;
    }
    function fn(e, r, t) {
      for (var n, i = [0], o, s = 0, a = e.length; s < a; ) {
        for (o = i.length; o--; ) i[o] *= r;
        for (i[0] += Ui.indexOf(e.charAt(s++)), n = 0; n < i.length; n++) i[n] > t - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / t | 0, i[n] %= t);
      }
      return i.reverse();
    }
    function Pp(e, r) {
      var t, n, i;
      if (r.isZero()) return r;
      n = r.d.length, n < 32 ? (t = Math.ceil(n / 3), i = (1 / xn(4, t)).toString()) : (t = 16, i = "2.3283064365386962890625e-10"), e.precision += t, r = Tr(e, 1, r.times(i), new e(1));
      for (var o = t; o--; ) {
        var s = r.times(r);
        r = s.times(s).minus(s).times(8).plus(1);
      }
      return e.precision -= t, r;
    }
    var L = /* @__PURE__ */ (function() {
      function e(n, i, o) {
        var s, a = 0, l = n.length;
        for (n = n.slice(); l--; ) s = n[l] * i + a, n[l] = s % o | 0, a = s / o | 0;
        return a && n.unshift(a), n;
      }
      function r(n, i, o, s) {
        var a, l;
        if (o != s) l = o > s ? 1 : -1;
        else for (a = l = 0; a < o; a++) if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
        return l;
      }
      function t(n, i, o, s) {
        for (var a = 0; o--; ) n[o] -= a, a = n[o] < i[o] ? 1 : 0, n[o] = a * s + n[o] - i[o];
        for (; !n[0] && n.length > 1; ) n.shift();
      }
      return function(n, i, o, s, a, l) {
        var u, c, p, d, f, h, g, I, T, S, b, D, me, se, Kr, j, te, Ae, K, fr, Vt = n.constructor, ti = n.s == i.s ? 1 : -1, H = n.d, k = i.d;
        if (!H || !H[0] || !k || !k[0]) return new Vt(!n.s || !i.s || (H ? k && H[0] == k[0] : !k) ? NaN : H && H[0] == 0 || !k ? ti * 0 : ti / 0);
        for (l ? (f = 1, c = n.e - i.e) : (l = fe, f = E, c = X(n.e / f) - X(i.e / f)), K = k.length, te = H.length, T = new Vt(ti), S = T.d = [], p = 0; k[p] == (H[p] || 0); p++) ;
        if (k[p] > (H[p] || 0) && c--, o == null ? (se = o = Vt.precision, s = Vt.rounding) : a ? se = o + (n.e - i.e) + 1 : se = o, se < 0) S.push(1), h = true;
        else {
          if (se = se / f + 2 | 0, p = 0, K == 1) {
            for (d = 0, k = k[0], se++; (p < te || d) && se--; p++) Kr = d * l + (H[p] || 0), S[p] = Kr / k | 0, d = Kr % k | 0;
            h = d || p < te;
          } else {
            for (d = l / (k[0] + 1) | 0, d > 1 && (k = e(k, d, l), H = e(H, d, l), K = k.length, te = H.length), j = K, b = H.slice(0, K), D = b.length; D < K; ) b[D++] = 0;
            fr = k.slice(), fr.unshift(0), Ae = k[0], k[1] >= l / 2 && ++Ae;
            do
              d = 0, u = r(k, b, K, D), u < 0 ? (me = b[0], K != D && (me = me * l + (b[1] || 0)), d = me / Ae | 0, d > 1 ? (d >= l && (d = l - 1), g = e(k, d, l), I = g.length, D = b.length, u = r(g, b, I, D), u == 1 && (d--, t(g, K < I ? fr : k, I, l))) : (d == 0 && (u = d = 1), g = k.slice()), I = g.length, I < D && g.unshift(0), t(b, g, D, l), u == -1 && (D = b.length, u = r(k, b, K, D), u < 1 && (d++, t(b, K < D ? fr : k, D, l))), D = b.length) : u === 0 && (d++, b = [0]), S[p++] = d, u && b[0] ? b[D++] = H[j] || 0 : (b = [H[j]], D = 1);
            while ((j++ < te || b[0] !== void 0) && se--);
            h = b[0] !== void 0;
          }
          S[0] || S.shift();
        }
        if (f == 1) T.e = c, $s = h;
        else {
          for (p = 1, d = S[0]; d >= 10; d /= 10) p++;
          T.e = p + c * f - 1, y(T, a ? o + T.e + 1 : o, s, h);
        }
        return T;
      };
    })();
    function y(e, r, t, n) {
      var i, o, s, a, l, u, c, p, d, f = e.constructor;
      e: if (r != null) {
        if (p = e.d, !p) return e;
        for (i = 1, a = p[0]; a >= 10; a /= 10) i++;
        if (o = r - i, o < 0) o += E, s = r, c = p[d = 0], l = c / U(10, i - s - 1) % 10 | 0;
        else if (d = Math.ceil((o + 1) / E), a = p.length, d >= a) if (n) {
          for (; a++ <= d; ) p.push(0);
          c = l = 0, i = 1, o %= E, s = o - E + 1;
        } else break e;
        else {
          for (c = a = p[d], i = 1; a >= 10; a /= 10) i++;
          o %= E, s = o - E + i, l = s < 0 ? 0 : c / U(10, i - s - 1) % 10 | 0;
        }
        if (n = n || r < 0 || p[d + 1] !== void 0 || (s < 0 ? c : c % U(10, i - s - 1)), u = t < 4 ? (l || n) && (t == 0 || t == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (t == 4 || n || t == 6 && (o > 0 ? s > 0 ? c / U(10, i - s) : 0 : p[d - 1]) % 10 & 1 || t == (e.s < 0 ? 8 : 7)), r < 1 || !p[0]) return p.length = 0, u ? (r -= e.e + 1, p[0] = U(10, (E - r % E) % E), e.e = -r || 0) : p[0] = e.e = 0, e;
        if (o == 0 ? (p.length = d, a = 1, d--) : (p.length = d + 1, a = U(10, E - o), p[d] = s > 0 ? (c / U(10, i - s) % U(10, s) | 0) * a : 0), u) for (; ; ) if (d == 0) {
          for (o = 1, s = p[0]; s >= 10; s /= 10) o++;
          for (s = p[0] += a, a = 1; s >= 10; s /= 10) a++;
          o != a && (e.e++, p[0] == fe && (p[0] = 1));
          break;
        } else {
          if (p[d] += a, p[d] != fe) break;
          p[d--] = 0, a = 1;
        }
        for (o = p.length; p[--o] === 0; ) p.pop();
      }
      return w && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
    }
    function ve(e, r, t) {
      if (!e.isFinite()) return Ws(e);
      var n, i = e.e, o = J(e.d), s = o.length;
      return r ? (t && (n = t - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + Je(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o = "0." + Je(-i - 1) + o, t && (n = t - s) > 0 && (o += Je(n))) : i >= s ? (o += Je(i + 1 - s), t && (n = t - i - 1) > 0 && (o = o + "." + Je(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), t && (n = t - s) > 0 && (i + 1 === s && (o += "."), o += Je(n))), o;
    }
    function wn(e, r) {
      var t = e[0];
      for (r *= E; t >= 10; t /= 10) r++;
      return r;
    }
    function bn(e, r, t) {
      if (r > vp) throw w = true, t && (e.precision = t), Error(qs);
      return y(new e(hn), r, 1, true);
    }
    function xe(e, r, t) {
      if (r > Qi) throw Error(qs);
      return y(new e(yn), r, t, true);
    }
    function Us(e) {
      var r = e.length - 1, t = r * E + 1;
      if (r = e[r], r) {
        for (; r % 10 == 0; r /= 10) t--;
        for (r = e[0]; r >= 10; r /= 10) t++;
      }
      return t;
    }
    function Je(e) {
      for (var r = ""; e--; ) r += "0";
      return r;
    }
    function Gs(e, r, t, n) {
      var i, o = new e(1), s = Math.ceil(n / E + 4);
      for (w = false; ; ) {
        if (t % 2 && (o = o.times(r), Fs(o.d, s) && (i = true)), t = X(t / 2), t === 0) {
          t = o.d.length - 1, i && o.d[t] === 0 && ++o.d[t];
          break;
        }
        r = r.times(r), Fs(r.d, s);
      }
      return w = true, o;
    }
    function Ls(e) {
      return e.d[e.d.length - 1] & 1;
    }
    function Qs(e, r, t) {
      for (var n, i, o = new e(r[0]), s = 0; ++s < r.length; ) {
        if (i = new e(r[s]), !i.s) {
          o = i;
          break;
        }
        n = o.cmp(i), (n === t || n === 0 && o.s === t) && (o = i);
      }
      return o;
    }
    function Wi(e, r) {
      var t, n, i, o, s, a, l, u = 0, c = 0, p = 0, d = e.constructor, f = d.rounding, h = d.precision;
      if (!e.d || !e.d[0] || e.e > 17) return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
      for (r == null ? (w = false, l = h) : l = r, a = new d(0.03125); e.e > -2; ) e = e.times(a), p += 5;
      for (n = Math.log(U(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, t = o = s = new d(1), d.precision = l; ; ) {
        if (o = y(o.times(e), l, 1), t = t.times(++c), a = s.plus(L(o, t, l, 1)), J(a.d).slice(0, l) === J(s.d).slice(0, l)) {
          for (i = p; i--; ) s = y(s.times(s), l, 1);
          if (r == null) if (u < 3 && ut(s.d, l - n, f, u)) d.precision = l += 10, t = o = a = new d(1), c = 0, u++;
          else return y(s, d.precision = h, f, w = true);
          else return d.precision = h, s;
        }
        s = a;
      }
    }
    function Ke(e, r) {
      var t, n, i, o, s, a, l, u, c, p, d, f = 1, h = 10, g = e, I = g.d, T = g.constructor, S = T.rounding, b = T.precision;
      if (g.s < 0 || !I || !I[0] || !g.e && I[0] == 1 && I.length == 1) return new T(I && !I[0] ? -1 / 0 : g.s != 1 ? NaN : I ? 0 : g);
      if (r == null ? (w = false, c = b) : c = r, T.precision = c += h, t = J(I), n = t.charAt(0), Math.abs(o = g.e) < 15e14) {
        for (; n < 7 && n != 1 || n == 1 && t.charAt(1) > 3; ) g = g.times(e), t = J(g.d), n = t.charAt(0), f++;
        o = g.e, n > 1 ? (g = new T("0." + t), o++) : g = new T(n + "." + t.slice(1));
      } else return u = bn(T, c + 2, b).times(o + ""), g = Ke(new T(n + "." + t.slice(1)), c - h).plus(u), T.precision = b, r == null ? y(g, b, S, w = true) : g;
      for (p = g, l = s = g = L(g.minus(1), g.plus(1), c, 1), d = y(g.times(g), c, 1), i = 3; ; ) {
        if (s = y(s.times(d), c, 1), u = l.plus(L(s, new T(i), c, 1)), J(u.d).slice(0, c) === J(l.d).slice(0, c)) if (l = l.times(2), o !== 0 && (l = l.plus(bn(T, c + 2, b).times(o + ""))), l = L(l, new T(f), c, 1), r == null) if (ut(l.d, c - h, S, a)) T.precision = c += h, u = s = g = L(p.minus(1), p.plus(1), c, 1), d = y(g.times(g), c, 1), i = a = 1;
        else return y(l, T.precision = b, S, w = true);
        else return T.precision = b, l;
        l = u, i += 2;
      }
    }
    function Ws(e) {
      return String(e.s * e.s / 0);
    }
    function gn(e, r) {
      var t, n, i;
      for ((t = r.indexOf(".")) > -1 && (r = r.replace(".", "")), (n = r.search(/e/i)) > 0 ? (t < 0 && (t = n), t += +r.slice(n + 1), r = r.substring(0, n)) : t < 0 && (t = r.length), n = 0; r.charCodeAt(n) === 48; n++) ;
      for (i = r.length; r.charCodeAt(i - 1) === 48; --i) ;
      if (r = r.slice(n, i), r) {
        if (i -= n, e.e = t = t - n - 1, e.d = [], n = (t + 1) % E, t < 0 && (n += E), n < i) {
          for (n && e.d.push(+r.slice(0, n)), i -= E; n < i; ) e.d.push(+r.slice(n, n += E));
          r = r.slice(n), n = E - r.length;
        } else n -= i;
        for (; n--; ) r += "0";
        e.d.push(+r), w && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
      } else e.e = 0, e.d = [0];
      return e;
    }
    function Tp(e, r) {
      var t, n, i, o, s, a, l, u, c;
      if (r.indexOf("_") > -1) {
        if (r = r.replace(/(\d)_(?=\d)/g, "$1"), Bs.test(r)) return gn(e, r);
      } else if (r === "Infinity" || r === "NaN") return +r || (e.s = NaN), e.e = NaN, e.d = null, e;
      if (Ep.test(r)) t = 16, r = r.toLowerCase();
      else if (bp.test(r)) t = 2;
      else if (wp.test(r)) t = 8;
      else throw Error(He + r);
      for (o = r.search(/p/i), o > 0 ? (l = +r.slice(o + 1), r = r.substring(2, o)) : r = r.slice(2), o = r.indexOf("."), s = o >= 0, n = e.constructor, s && (r = r.replace(".", ""), a = r.length, o = a - o, i = Gs(n, new n(t), o, o * 2)), u = fn(r, t, fe), c = u.length - 1, o = c; u[o] === 0; --o) u.pop();
      return o < 0 ? new n(e.s * 0) : (e.e = wn(u, c), e.d = u, w = false, s && (e = L(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? U(2, l) : Le.pow(2, l))), w = true, e);
    }
    function Sp(e, r) {
      var t, n = r.d.length;
      if (n < 3) return r.isZero() ? r : Tr(e, 2, r, r);
      t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, r = r.times(1 / xn(5, t)), r = Tr(e, 2, r, r);
      for (var i, o = new e(5), s = new e(16), a = new e(20); t--; ) i = r.times(r), r = r.times(o.plus(i.times(s.times(i).minus(a))));
      return r;
    }
    function Tr(e, r, t, n, i) {
      var o, s, a, l, u = 1, c = e.precision, p = Math.ceil(c / E);
      for (w = false, l = t.times(t), a = new e(n); ; ) {
        if (s = L(a.times(l), new e(r++ * r++), c, 1), a = i ? n.plus(s) : n.minus(s), n = L(s.times(l), new e(r++ * r++), c, 1), s = a.plus(n), s.d[p] !== void 0) {
          for (o = p; s.d[o] === a.d[o] && o--; ) ;
          if (o == -1) break;
        }
        o = a, a = n, n = s, s = o, u++;
      }
      return w = true, s.d.length = p + 1, s;
    }
    function xn(e, r) {
      for (var t = e; --r; ) t *= e;
      return t;
    }
    function Js(e, r) {
      var t, n = r.s < 0, i = xe(e, e.precision, 1), o = i.times(0.5);
      if (r = r.abs(), r.lte(o)) return Ne = n ? 4 : 1, r;
      if (t = r.divToInt(i), t.isZero()) Ne = n ? 3 : 2;
      else {
        if (r = r.minus(t.times(i)), r.lte(o)) return Ne = Ls(t) ? n ? 2 : 3 : n ? 4 : 1, r;
        Ne = Ls(t) ? n ? 1 : 4 : n ? 3 : 2;
      }
      return r.minus(i).abs();
    }
    function Ji(e, r, t, n) {
      var i, o, s, a, l, u, c, p, d, f = e.constructor, h = t !== void 0;
      if (h ? (ne(t, 1, Ye), n === void 0 ? n = f.rounding : ne(n, 0, 8)) : (t = f.precision, n = f.rounding), !e.isFinite()) c = Ws(e);
      else {
        for (c = ve(e), s = c.indexOf("."), h ? (i = 2, r == 16 ? t = t * 4 - 3 : r == 8 && (t = t * 3 - 2)) : i = r, s >= 0 && (c = c.replace(".", ""), d = new f(1), d.e = c.length - s, d.d = fn(ve(d), 10, i), d.e = d.d.length), p = fn(c, 10, i), o = l = p.length; p[--l] == 0; ) p.pop();
        if (!p[0]) c = h ? "0p+0" : "0";
        else {
          if (s < 0 ? o-- : (e = new f(e), e.d = p, e.e = o, e = L(e, d, t, n, 0, i), p = e.d, o = e.e, u = $s), s = p[t], a = i / 2, u = u || p[t + 1] !== void 0, u = n < 4 ? (s !== void 0 || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && p[t - 1] & 1 || n === (e.s < 0 ? 8 : 7)), p.length = t, u) for (; ++p[--t] > i - 1; ) p[t] = 0, t || (++o, p.unshift(1));
          for (l = p.length; !p[l - 1]; --l) ;
          for (s = 0, c = ""; s < l; s++) c += Ui.charAt(p[s]);
          if (h) {
            if (l > 1) if (r == 16 || r == 8) {
              for (s = r == 16 ? 4 : 3, --l; l % s; l++) c += "0";
              for (p = fn(c, i, r), l = p.length; !p[l - 1]; --l) ;
              for (s = 1, c = "1."; s < l; s++) c += Ui.charAt(p[s]);
            } else c = c.charAt(0) + "." + c.slice(1);
            c = c + (o < 0 ? "p" : "p+") + o;
          } else if (o < 0) {
            for (; ++o; ) c = "0" + c;
            c = "0." + c;
          } else if (++o > l) for (o -= l; o--; ) c += "0";
          else o < l && (c = c.slice(0, o) + "." + c.slice(o));
        }
        c = (r == 16 ? "0x" : r == 2 ? "0b" : r == 8 ? "0o" : "") + c;
      }
      return e.s < 0 ? "-" + c : c;
    }
    function Fs(e, r) {
      if (e.length > r) return e.length = r, true;
    }
    function Rp(e) {
      return new this(e).abs();
    }
    function Ap(e) {
      return new this(e).acos();
    }
    function Cp(e) {
      return new this(e).acosh();
    }
    function Ip(e, r) {
      return new this(e).plus(r);
    }
    function Dp(e) {
      return new this(e).asin();
    }
    function Op(e) {
      return new this(e).asinh();
    }
    function kp(e) {
      return new this(e).atan();
    }
    function _p(e) {
      return new this(e).atanh();
    }
    function Np(e, r) {
      e = new this(e), r = new this(r);
      var t, n = this.precision, i = this.rounding, o = n + 4;
      return !e.s || !r.s ? t = new this(NaN) : !e.d && !r.d ? (t = xe(this, o, 1).times(r.s > 0 ? 0.25 : 0.75), t.s = e.s) : !r.d || e.isZero() ? (t = r.s < 0 ? xe(this, n, i) : new this(0), t.s = e.s) : !e.d || r.isZero() ? (t = xe(this, o, 1).times(0.5), t.s = e.s) : r.s < 0 ? (this.precision = o, this.rounding = 1, t = this.atan(L(e, r, o, 1)), r = xe(this, o, 1), this.precision = n, this.rounding = i, t = e.s < 0 ? t.minus(r) : t.plus(r)) : t = this.atan(L(e, r, o, 1)), t;
    }
    function Lp(e) {
      return new this(e).cbrt();
    }
    function Fp(e) {
      return y(e = new this(e), e.e + 1, 2);
    }
    function Mp(e, r, t) {
      return new this(e).clamp(r, t);
    }
    function $p(e) {
      if (!e || typeof e != "object") throw Error(En + "Object expected");
      var r, t, n, i = e.defaults === true, o = ["precision", 1, Ye, "rounding", 0, 8, "toExpNeg", -Pr, 0, "toExpPos", 0, Pr, "maxE", 0, Pr, "minE", -Pr, 0, "modulo", 0, 9];
      for (r = 0; r < o.length; r += 3) if (t = o[r], i && (this[t] = Gi[t]), (n = e[t]) !== void 0) if (X(n) === n && n >= o[r + 1] && n <= o[r + 2]) this[t] = n;
      else throw Error(He + t + ": " + n);
      if (t = "crypto", i && (this[t] = Gi[t]), (n = e[t]) !== void 0) if (n === true || n === false || n === 0 || n === 1) if (n) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[t] = true;
      else throw Error(Vs);
      else this[t] = false;
      else throw Error(He + t + ": " + n);
      return this;
    }
    function qp(e) {
      return new this(e).cos();
    }
    function Vp(e) {
      return new this(e).cosh();
    }
    function Ks(e) {
      var r, t, n;
      function i(o) {
        var s, a, l, u = this;
        if (!(u instanceof i)) return new i(o);
        if (u.constructor = i, Ms(o)) {
          u.s = o.s, w ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
          return;
        }
        if (l = typeof o, l === "number") {
          if (o === 0) {
            u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
            return;
          }
          if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
            for (s = 0, a = o; a >= 10; a /= 10) s++;
            w ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
            return;
          }
          if (o * 0 !== 0) {
            o || (u.s = NaN), u.e = NaN, u.d = null;
            return;
          }
          return gn(u, o.toString());
        }
        if (l === "string") return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a === 43 && (o = o.slice(1)), u.s = 1), Bs.test(o) ? gn(u, o) : Tp(u, o);
        if (l === "bigint") return o < 0 ? (o = -o, u.s = -1) : u.s = 1, gn(u, o.toString());
        throw Error(He + o);
      }
      if (i.prototype = m, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = $p, i.clone = Ks, i.isDecimal = Ms, i.abs = Rp, i.acos = Ap, i.acosh = Cp, i.add = Ip, i.asin = Dp, i.asinh = Op, i.atan = kp, i.atanh = _p, i.atan2 = Np, i.cbrt = Lp, i.ceil = Fp, i.clamp = Mp, i.cos = qp, i.cosh = Vp, i.div = jp, i.exp = Bp, i.floor = Up, i.hypot = Gp, i.ln = Qp, i.log = Wp, i.log10 = Kp, i.log2 = Jp, i.max = Hp, i.min = Yp, i.mod = zp, i.mul = Zp, i.pow = Xp, i.random = ed, i.round = rd, i.sign = td, i.sin = nd, i.sinh = id, i.sqrt = od, i.sub = sd, i.sum = ad, i.tan = ld, i.tanh = ud, i.trunc = cd, e === void 0 && (e = {}), e && e.defaults !== true) for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], r = 0; r < n.length; ) e.hasOwnProperty(t = n[r++]) || (e[t] = this[t]);
      return i.config(e), i;
    }
    function jp(e, r) {
      return new this(e).div(r);
    }
    function Bp(e) {
      return new this(e).exp();
    }
    function Up(e) {
      return y(e = new this(e), e.e + 1, 3);
    }
    function Gp() {
      var e, r, t = new this(0);
      for (w = false, e = 0; e < arguments.length; ) if (r = new this(arguments[e++]), r.d) t.d && (t = t.plus(r.times(r)));
      else {
        if (r.s) return w = true, new this(1 / 0);
        t = r;
      }
      return w = true, t.sqrt();
    }
    function Ms(e) {
      return e instanceof Le || e && e.toStringTag === js || false;
    }
    function Qp(e) {
      return new this(e).ln();
    }
    function Wp(e, r) {
      return new this(e).log(r);
    }
    function Jp(e) {
      return new this(e).log(2);
    }
    function Kp(e) {
      return new this(e).log(10);
    }
    function Hp() {
      return Qs(this, arguments, -1);
    }
    function Yp() {
      return Qs(this, arguments, 1);
    }
    function zp(e, r) {
      return new this(e).mod(r);
    }
    function Zp(e, r) {
      return new this(e).mul(r);
    }
    function Xp(e, r) {
      return new this(e).pow(r);
    }
    function ed(e) {
      var r, t, n, i, o = 0, s = new this(1), a = [];
      if (e === void 0 ? e = this.precision : ne(e, 1, Ye), n = Math.ceil(e / E), this.crypto) if (crypto.getRandomValues) for (r = crypto.getRandomValues(new Uint32Array(n)); o < n; ) i = r[o], i >= 429e7 ? r[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (r = crypto.randomBytes(n *= 4); o < n; ) i = r[o] + (r[o + 1] << 8) + (r[o + 2] << 16) + ((r[o + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(r, o) : (a.push(i % 1e7), o += 4);
        o = n / 4;
      } else throw Error(Vs);
      else for (; o < n; ) a[o++] = Math.random() * 1e7 | 0;
      for (n = a[--o], e %= E, n && e && (i = U(10, E - e), a[o] = (n / i | 0) * i); a[o] === 0; o--) a.pop();
      if (o < 0) t = 0, a = [0];
      else {
        for (t = -1; a[0] === 0; t -= E) a.shift();
        for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
        n < E && (t -= E - n);
      }
      return s.e = t, s.d = a, s;
    }
    function rd(e) {
      return y(e = new this(e), e.e + 1, this.rounding);
    }
    function td(e) {
      return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
    }
    function nd(e) {
      return new this(e).sin();
    }
    function id(e) {
      return new this(e).sinh();
    }
    function od(e) {
      return new this(e).sqrt();
    }
    function sd(e, r) {
      return new this(e).sub(r);
    }
    function ad() {
      var e = 0, r = arguments, t = new this(r[e]);
      for (w = false; t.s && ++e < r.length; ) t = t.plus(r[e]);
      return w = true, y(t, this.precision, this.rounding);
    }
    function ld(e) {
      return new this(e).tan();
    }
    function ud(e) {
      return new this(e).tanh();
    }
    function cd(e) {
      return y(e = new this(e), e.e + 1, 1);
    }
    m[Symbol.for("nodejs.util.inspect.custom")] = m.toString;
    m[Symbol.toStringTag] = "Decimal";
    var Le = m.constructor = Ks(Gi);
    hn = new Le(hn);
    yn = new Le(yn);
    var Fe = Le;
    function Sr(e) {
      return Le.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
    }
    var ct = {};
    tr(ct, { ModelAction: () => Rr, datamodelEnumToSchemaEnum: () => pd });
    function pd(e) {
      return { name: e.name, values: e.values.map((r) => r.name) };
    }
    var Rr = ((b) => (b.findUnique = "findUnique", b.findUniqueOrThrow = "findUniqueOrThrow", b.findFirst = "findFirst", b.findFirstOrThrow = "findFirstOrThrow", b.findMany = "findMany", b.create = "create", b.createMany = "createMany", b.createManyAndReturn = "createManyAndReturn", b.update = "update", b.updateMany = "updateMany", b.updateManyAndReturn = "updateManyAndReturn", b.upsert = "upsert", b.delete = "delete", b.deleteMany = "deleteMany", b.groupBy = "groupBy", b.count = "count", b.aggregate = "aggregate", b.findRaw = "findRaw", b.aggregateRaw = "aggregateRaw", b))(Rr || {});
    var Xs = O(Di());
    var Zs = O(require("fs"));
    var Hs = { keyword: De, entity: De, value: (e) => W(nr(e)), punctuation: nr, directive: De, function: De, variable: (e) => W(nr(e)), string: (e) => W(qe(e)), boolean: Ie, number: De, comment: Hr };
    var dd = (e) => e;
    var vn = {};
    var md = 0;
    var v = { manual: vn.Prism && vn.Prism.manual, disableWorkerMessageHandler: vn.Prism && vn.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
      if (e instanceof ge) {
        let r = e;
        return new ge(r.type, v.util.encode(r.content), r.alias);
      } else return Array.isArray(e) ? e.map(v.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }, type: function(e) {
      return Object.prototype.toString.call(e).slice(8, -1);
    }, objId: function(e) {
      return e.__id || Object.defineProperty(e, "__id", { value: ++md }), e.__id;
    }, clone: function e(r, t) {
      let n, i, o = v.util.type(r);
      switch (t = t || {}, o) {
        case "Object":
          if (i = v.util.objId(r), t[i]) return t[i];
          n = {}, t[i] = n;
          for (let s in r) r.hasOwnProperty(s) && (n[s] = e(r[s], t));
          return n;
        case "Array":
          return i = v.util.objId(r), t[i] ? t[i] : (n = [], t[i] = n, r.forEach(function(s, a) {
            n[a] = e(s, t);
          }), n);
        default:
          return r;
      }
    } }, languages: { extend: function(e, r) {
      let t = v.util.clone(v.languages[e]);
      for (let n in r) t[n] = r[n];
      return t;
    }, insertBefore: function(e, r, t, n) {
      n = n || v.languages;
      let i = n[e], o = {};
      for (let a in i) if (i.hasOwnProperty(a)) {
        if (a == r) for (let l in t) t.hasOwnProperty(l) && (o[l] = t[l]);
        t.hasOwnProperty(a) || (o[a] = i[a]);
      }
      let s = n[e];
      return n[e] = o, v.languages.DFS(v.languages, function(a, l) {
        l === s && a != e && (this[a] = o);
      }), o;
    }, DFS: function e(r, t, n, i) {
      i = i || {};
      let o = v.util.objId;
      for (let s in r) if (r.hasOwnProperty(s)) {
        t.call(r, s, r[s], n || s);
        let a = r[s], l = v.util.type(a);
        l === "Object" && !i[o(a)] ? (i[o(a)] = true, e(a, t, null, i)) : l === "Array" && !i[o(a)] && (i[o(a)] = true, e(a, t, s, i));
      }
    } }, plugins: {}, highlight: function(e, r, t) {
      let n = { code: e, grammar: r, language: t };
      return v.hooks.run("before-tokenize", n), n.tokens = v.tokenize(n.code, n.grammar), v.hooks.run("after-tokenize", n), ge.stringify(v.util.encode(n.tokens), n.language);
    }, matchGrammar: function(e, r, t, n, i, o, s) {
      for (let g in t) {
        if (!t.hasOwnProperty(g) || !t[g]) continue;
        if (g == s) return;
        let I = t[g];
        I = v.util.type(I) === "Array" ? I : [I];
        for (let T = 0; T < I.length; ++T) {
          let S = I[T], b = S.inside, D = !!S.lookbehind, me = !!S.greedy, se = 0, Kr = S.alias;
          if (me && !S.pattern.global) {
            let j = S.pattern.toString().match(/[imuy]*$/)[0];
            S.pattern = RegExp(S.pattern.source, j + "g");
          }
          S = S.pattern || S;
          for (let j = n, te = i; j < r.length; te += r[j].length, ++j) {
            let Ae = r[j];
            if (r.length > e.length) return;
            if (Ae instanceof ge) continue;
            if (me && j != r.length - 1) {
              S.lastIndex = te;
              var p = S.exec(e);
              if (!p) break;
              var c = p.index + (D ? p[1].length : 0), d = p.index + p[0].length, a = j, l = te;
              for (let k = r.length; a < k && (l < d || !r[a].type && !r[a - 1].greedy); ++a) l += r[a].length, c >= l && (++j, te = l);
              if (r[j] instanceof ge) continue;
              u = a - j, Ae = e.slice(te, l), p.index -= te;
            } else {
              S.lastIndex = 0;
              var p = S.exec(Ae), u = 1;
            }
            if (!p) {
              if (o) break;
              continue;
            }
            D && (se = p[1] ? p[1].length : 0);
            var c = p.index + se, p = p[0].slice(se), d = c + p.length, f = Ae.slice(0, c), h = Ae.slice(d);
            let K = [j, u];
            f && (++j, te += f.length, K.push(f));
            let fr = new ge(g, b ? v.tokenize(p, b) : p, Kr, p, me);
            if (K.push(fr), h && K.push(h), Array.prototype.splice.apply(r, K), u != 1 && v.matchGrammar(e, r, t, j, te, true, g), o) break;
          }
        }
      }
    }, tokenize: function(e, r) {
      let t = [e], n = r.rest;
      if (n) {
        for (let i in n) r[i] = n[i];
        delete r.rest;
      }
      return v.matchGrammar(e, t, r, 0, 0, false), t;
    }, hooks: { all: {}, add: function(e, r) {
      let t = v.hooks.all;
      t[e] = t[e] || [], t[e].push(r);
    }, run: function(e, r) {
      let t = v.hooks.all[e];
      if (!(!t || !t.length)) for (var n = 0, i; i = t[n++]; ) i(r);
    } }, Token: ge };
    v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
    v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
    v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
    v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
    v.languages.js = v.languages.javascript;
    v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
    v.languages.ts = v.languages.typescript;
    function ge(e, r, t, n, i) {
      this.type = e, this.content = r, this.alias = t, this.length = (n || "").length | 0, this.greedy = !!i;
    }
    ge.stringify = function(e, r) {
      return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(t) {
        return ge.stringify(t, r);
      }).join("") : fd(e.type)(e.content);
    };
    function fd(e) {
      return Hs[e] || dd;
    }
    function Ys(e) {
      return gd(e, v.languages.javascript);
    }
    function gd(e, r) {
      return v.tokenize(e, r).map((n) => ge.stringify(n)).join("");
    }
    function zs(e) {
      return Ci(e);
    }
    var Pn = class e {
      constructor(r, t) {
        __publicField(this, "firstLineNumber");
        __publicField(this, "lines");
        this.firstLineNumber = r, this.lines = t;
      }
      static read(r) {
        let t;
        try {
          t = Zs.default.readFileSync(r, "utf-8");
        } catch {
          return null;
        }
        return e.fromContent(t);
      }
      static fromContent(r) {
        let t = r.split(/\r?\n/);
        return new e(1, t);
      }
      get lastLineNumber() {
        return this.firstLineNumber + this.lines.length - 1;
      }
      mapLineAt(r, t) {
        if (r < this.firstLineNumber || r > this.lines.length + this.firstLineNumber) return this;
        let n = r - this.firstLineNumber, i = [...this.lines];
        return i[n] = t(i[n]), new e(this.firstLineNumber, i);
      }
      mapLines(r) {
        return new e(this.firstLineNumber, this.lines.map((t, n) => r(t, this.firstLineNumber + n)));
      }
      lineAt(r) {
        return this.lines[r - this.firstLineNumber];
      }
      prependSymbolAt(r, t) {
        return this.mapLines((n, i) => i === r ? `${t} ${n}` : `  ${n}`);
      }
      slice(r, t) {
        let n = this.lines.slice(r - 1, t).join(`
`);
        return new e(r, zs(n).split(`
`));
      }
      highlight() {
        let r = Ys(this.toString());
        return new e(this.firstLineNumber, r.split(`
`));
      }
      toString() {
        return this.lines.join(`
`);
      }
    };
    var hd = { red: ce, gray: Hr, dim: Ce, bold: W, underline: Y, highlightSource: (e) => e.highlight() };
    var yd = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
    function bd({ message: e, originalMethod: r, isPanic: t, callArguments: n }) {
      return { functionName: `prisma.${r}()`, message: e, isPanic: t ?? false, callArguments: n };
    }
    function Ed({ callsite: e, message: r, originalMethod: t, isPanic: n, callArguments: i }, o) {
      let s = bd({ message: r, originalMethod: t, isPanic: n, callArguments: i });
      if (!e || typeof window < "u" || process.env.NODE_ENV === "production") return s;
      let a = e.getLocation();
      if (!a || !a.lineNumber || !a.columnNumber) return s;
      let l = Math.max(1, a.lineNumber - 3), u = Pn.read(a.fileName)?.slice(l, a.lineNumber), c = u?.lineAt(a.lineNumber);
      if (u && c) {
        let p = xd(c), d = wd(c);
        if (!d) return s;
        s.functionName = `${d.code})`, s.location = a, n || (u = u.mapLineAt(a.lineNumber, (h) => h.slice(0, d.openingBraceIndex))), u = o.highlightSource(u);
        let f = String(u.lastLineNumber).length;
        if (s.contextLines = u.mapLines((h, g) => o.gray(String(g).padStart(f)) + " " + h).mapLines((h) => o.dim(h)).prependSymbolAt(a.lineNumber, o.bold(o.red("\u2192"))), i) {
          let h = p + f + 1;
          h += 2, s.callArguments = (0, Xs.default)(i, h).slice(h);
        }
      }
      return s;
    }
    function wd(e) {
      let r = Object.keys(Rr).join("|"), n = new RegExp(String.raw`\.(${r})\(`).exec(e);
      if (n) {
        let i = n.index + n[0].length, o = e.lastIndexOf(" ", n.index) + 1;
        return { code: e.slice(o, i), openingBraceIndex: i };
      }
      return null;
    }
    function xd(e) {
      let r = 0;
      for (let t = 0; t < e.length; t++) {
        if (e.charAt(t) !== " ") return r;
        r++;
      }
      return r;
    }
    function vd({ functionName: e, location: r, message: t, isPanic: n, contextLines: i, callArguments: o }, s) {
      let a = [""], l = r ? " in" : ":";
      if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)), r && a.push(s.underline(Pd(r))), i) {
        a.push("");
        let u = [i.toString()];
        o && (u.push(o), u.push(s.dim(")"))), a.push(u.join("")), o && a.push("");
      } else a.push(""), o && a.push(o), a.push("");
      return a.push(t), a.join(`
`);
    }
    function Pd(e) {
      let r = [e.fileName];
      return e.lineNumber && r.push(String(e.lineNumber)), e.columnNumber && r.push(String(e.columnNumber)), r.join(":");
    }
    function Tn(e) {
      let r = e.showColors ? hd : yd, t;
      return t = Ed(e, r), vd(t, r);
    }
    var la = O(Ki());
    function na(e, r, t) {
      let n = ia(e), i = Td(n), o = Rd(i);
      o ? Sn(o, r, t) : r.addErrorMessage(() => "Unknown error");
    }
    function ia(e) {
      return e.errors.flatMap((r) => r.kind === "Union" ? ia(r) : [r]);
    }
    function Td(e) {
      let r = /* @__PURE__ */ new Map(), t = [];
      for (let n of e) {
        if (n.kind !== "InvalidArgumentType") {
          t.push(n);
          continue;
        }
        let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = r.get(i);
        o ? r.set(i, { ...n, argument: { ...n.argument, typeNames: Sd(o.argument.typeNames, n.argument.typeNames) } }) : r.set(i, n);
      }
      return t.push(...r.values()), t;
    }
    function Sd(e, r) {
      return [...new Set(e.concat(r))];
    }
    function Rd(e) {
      return ji(e, (r, t) => {
        let n = ra(r), i = ra(t);
        return n !== i ? n - i : ta(r) - ta(t);
      });
    }
    function ra(e) {
      let r = 0;
      return Array.isArray(e.selectionPath) && (r += e.selectionPath.length), Array.isArray(e.argumentPath) && (r += e.argumentPath.length), r;
    }
    function ta(e) {
      switch (e.kind) {
        case "InvalidArgumentValue":
        case "ValueTooLarge":
          return 20;
        case "InvalidArgumentType":
          return 10;
        case "RequiredArgumentMissing":
          return -10;
        default:
          return 0;
      }
    }
    var le = class {
      constructor(r, t) {
        __publicField(this, "isRequired", false);
        this.name = r;
        this.value = t;
      }
      makeRequired() {
        return this.isRequired = true, this;
      }
      write(r) {
        let { colors: { green: t } } = r.context;
        r.addMarginSymbol(t(this.isRequired ? "+" : "?")), r.write(t(this.name)), this.isRequired || r.write(t("?")), r.write(t(": ")), typeof this.value == "string" ? r.write(t(this.value)) : r.write(this.value);
      }
    };
    sa();
    var Ar = class {
      constructor(r = 0, t) {
        __publicField(this, "lines", []);
        __publicField(this, "currentLine", "");
        __publicField(this, "currentIndent", 0);
        __publicField(this, "marginSymbol");
        __publicField(this, "afterNextNewLineCallback");
        this.context = t;
        this.currentIndent = r;
      }
      write(r) {
        return typeof r == "string" ? this.currentLine += r : r.write(this), this;
      }
      writeJoined(r, t, n = (i, o) => o.write(i)) {
        let i = t.length - 1;
        for (let o = 0; o < t.length; o++) n(t[o], this), o !== i && this.write(r);
        return this;
      }
      writeLine(r) {
        return this.write(r).newLine();
      }
      newLine() {
        this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
        let r = this.afterNextNewLineCallback;
        return this.afterNextNewLineCallback = void 0, r?.(), this;
      }
      withIndent(r) {
        return this.indent(), r(this), this.unindent(), this;
      }
      afterNextNewline(r) {
        return this.afterNextNewLineCallback = r, this;
      }
      indent() {
        return this.currentIndent++, this;
      }
      unindent() {
        return this.currentIndent > 0 && this.currentIndent--, this;
      }
      addMarginSymbol(r) {
        return this.marginSymbol = r, this;
      }
      toString() {
        return this.lines.concat(this.indentedCurrentLine()).join(`
`);
      }
      getCurrentLineLength() {
        return this.currentLine.length;
      }
      indentedCurrentLine() {
        let r = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
        return this.marginSymbol ? this.marginSymbol + r.slice(1) : r;
      }
    };
    oa();
    var Rn = class {
      constructor(r) {
        this.value = r;
      }
      write(r) {
        r.write(this.value);
      }
      markAsError() {
        this.value.markAsError();
      }
    };
    var An = (e) => e;
    var Cn = { bold: An, red: An, green: An, dim: An, enabled: false };
    var aa = { bold: W, red: ce, green: qe, dim: Ce, enabled: true };
    var Cr = { write(e) {
      e.writeLine(",");
    } };
    var Pe = class {
      constructor(r) {
        __publicField(this, "isUnderlined", false);
        __publicField(this, "color", (r) => r);
        this.contents = r;
      }
      underline() {
        return this.isUnderlined = true, this;
      }
      setColor(r) {
        return this.color = r, this;
      }
      write(r) {
        let t = r.getCurrentLineLength();
        r.write(this.color(this.contents)), this.isUnderlined && r.afterNextNewline(() => {
          r.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length)));
        });
      }
    };
    var ze = class {
      constructor() {
        __publicField(this, "hasError", false);
      }
      markAsError() {
        return this.hasError = true, this;
      }
    };
    var Ir = class extends ze {
      constructor() {
        super(...arguments);
        __publicField(this, "items", []);
      }
      addItem(r) {
        return this.items.push(new Rn(r)), this;
      }
      getField(r) {
        return this.items[r];
      }
      getPrintWidth() {
        return this.items.length === 0 ? 2 : Math.max(...this.items.map((t) => t.value.getPrintWidth())) + 2;
      }
      write(r) {
        if (this.items.length === 0) {
          this.writeEmpty(r);
          return;
        }
        this.writeWithItems(r);
      }
      writeEmpty(r) {
        let t = new Pe("[]");
        this.hasError && t.setColor(r.context.colors.red).underline(), r.write(t);
      }
      writeWithItems(r) {
        let { colors: t } = r.context;
        r.writeLine("[").withIndent(() => r.writeJoined(Cr, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
          r.writeLine(t.red("~".repeat(this.getPrintWidth())));
        });
      }
      asObject() {
      }
    };
    var Dr = class e extends ze {
      constructor() {
        super(...arguments);
        __publicField(this, "fields", {});
        __publicField(this, "suggestions", []);
      }
      addField(r) {
        this.fields[r.name] = r;
      }
      addSuggestion(r) {
        this.suggestions.push(r);
      }
      getField(r) {
        return this.fields[r];
      }
      getDeepField(r) {
        let [t, ...n] = r, i = this.getField(t);
        if (!i) return;
        let o = i;
        for (let s of n) {
          let a;
          if (o.value instanceof e ? a = o.value.getField(s) : o.value instanceof Ir && (a = o.value.getField(Number(s))), !a) return;
          o = a;
        }
        return o;
      }
      getDeepFieldValue(r) {
        return r.length === 0 ? this : this.getDeepField(r)?.value;
      }
      hasField(r) {
        return !!this.getField(r);
      }
      removeAllFields() {
        this.fields = {};
      }
      removeField(r) {
        delete this.fields[r];
      }
      getFields() {
        return this.fields;
      }
      isEmpty() {
        return Object.keys(this.fields).length === 0;
      }
      getFieldValue(r) {
        return this.getField(r)?.value;
      }
      getDeepSubSelectionValue(r) {
        let t = this;
        for (let n of r) {
          if (!(t instanceof e)) return;
          let i = t.getSubSelectionValue(n);
          if (!i) return;
          t = i;
        }
        return t;
      }
      getDeepSelectionParent(r) {
        let t = this.getSelectionParent();
        if (!t) return;
        let n = t;
        for (let i of r) {
          let o = n.value.getFieldValue(i);
          if (!o || !(o instanceof e)) return;
          let s = o.getSelectionParent();
          if (!s) return;
          n = s;
        }
        return n;
      }
      getSelectionParent() {
        let r = this.getField("select")?.value.asObject();
        if (r) return { kind: "select", value: r };
        let t = this.getField("include")?.value.asObject();
        if (t) return { kind: "include", value: t };
      }
      getSubSelectionValue(r) {
        return this.getSelectionParent()?.value.fields[r].value;
      }
      getPrintWidth() {
        let r = Object.values(this.fields);
        return r.length == 0 ? 2 : Math.max(...r.map((n) => n.getPrintWidth())) + 2;
      }
      write(r) {
        let t = Object.values(this.fields);
        if (t.length === 0 && this.suggestions.length === 0) {
          this.writeEmpty(r);
          return;
        }
        this.writeWithContents(r, t);
      }
      asObject() {
        return this;
      }
      writeEmpty(r) {
        let t = new Pe("{}");
        this.hasError && t.setColor(r.context.colors.red).underline(), r.write(t);
      }
      writeWithContents(r, t) {
        r.writeLine("{").withIndent(() => {
          r.writeJoined(Cr, [...t, ...this.suggestions]).newLine();
        }), r.write("}"), this.hasError && r.afterNextNewline(() => {
          r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    var Q = class extends ze {
      constructor(t) {
        super();
        this.text = t;
      }
      getPrintWidth() {
        return this.text.length;
      }
      write(t) {
        let n = new Pe(this.text);
        this.hasError && n.underline().setColor(t.context.colors.red), t.write(n);
      }
      asObject() {
      }
    };
    var pt = class {
      constructor() {
        __publicField(this, "fields", []);
      }
      addField(r, t) {
        return this.fields.push({ write(n) {
          let { green: i, dim: o } = n.context.colors;
          n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("+")));
        } }), this;
      }
      write(r) {
        let { colors: { green: t } } = r.context;
        r.writeLine(t("{")).withIndent(() => {
          r.writeJoined(Cr, this.fields).newLine();
        }).write(t("}")).addMarginSymbol(t("+"));
      }
    };
    function Sn(e, r, t) {
      switch (e.kind) {
        case "MutuallyExclusiveFields":
          Ad(e, r);
          break;
        case "IncludeOnScalar":
          Cd(e, r);
          break;
        case "EmptySelection":
          Id(e, r, t);
          break;
        case "UnknownSelectionField":
          _d(e, r);
          break;
        case "InvalidSelectionValue":
          Nd(e, r);
          break;
        case "UnknownArgument":
          Ld(e, r);
          break;
        case "UnknownInputField":
          Fd(e, r);
          break;
        case "RequiredArgumentMissing":
          Md(e, r);
          break;
        case "InvalidArgumentType":
          $d(e, r);
          break;
        case "InvalidArgumentValue":
          qd(e, r);
          break;
        case "ValueTooLarge":
          Vd(e, r);
          break;
        case "SomeFieldsMissing":
          jd(e, r);
          break;
        case "TooManyFieldsGiven":
          Bd(e, r);
          break;
        case "Union":
          na(e, r, t);
          break;
        default:
          throw new Error("not implemented: " + e.kind);
      }
    }
    function Ad(e, r) {
      let t = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      t && (t.getField(e.firstField)?.markAsError(), t.getField(e.secondField)?.markAsError()), r.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`);
    }
    function Cd(e, r) {
      let [t, n] = Or(e.selectionPath), i = e.outputType, o = r.arguments.getDeepSelectionParent(t)?.value;
      if (o && (o.getField(n)?.markAsError(), i)) for (let s of i.fields) s.isRelation && o.addSuggestion(new le(s.name, "true"));
      r.addErrorMessage((s) => {
        let a = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
        return i ? a += ` on model ${s.bold(i.name)}. ${dt(s)}` : a += ".", a += `
Note that ${s.bold("include")} statements only accept relation fields.`, a;
      });
    }
    function Id(e, r, t) {
      let n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      if (n) {
        let i = n.getField("omit")?.value.asObject();
        if (i) {
          Dd(e, r, i);
          return;
        }
        if (n.hasField("select")) {
          Od(e, r);
          return;
        }
      }
      if (t?.[We(e.outputType.name)]) {
        kd(e, r);
        return;
      }
      r.addErrorMessage(() => `Unknown field at "${e.selectionPath.join(".")} selection"`);
    }
    function Dd(e, r, t) {
      t.removeAllFields();
      for (let n of e.outputType.fields) t.addSuggestion(new le(n.name, "false"));
      r.addErrorMessage((n) => `The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`);
    }
    function Od(e, r) {
      let t = e.outputType, n = r.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n?.isEmpty() ?? false;
      n && (n.removeAllFields(), pa(n, t)), r.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(t.name)} must not be empty. ${dt(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`);
    }
    function kd(e, r) {
      let t = new pt();
      for (let i of e.outputType.fields) i.isRelation || t.addField(i.name, "false");
      let n = new le("omit", t).makeRequired();
      if (e.selectionPath.length === 0) r.arguments.addSuggestion(n);
      else {
        let [i, o] = Or(e.selectionPath), a = r.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);
        if (a) {
          let l = a?.value.asObject() ?? new Dr();
          l.addSuggestion(n), a.value = l;
        }
      }
      r.addErrorMessage((i) => `The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`);
    }
    function _d(e, r) {
      let t = da(e.selectionPath, r);
      if (t.parentKind !== "unknown") {
        t.field.markAsError();
        let n = t.parent;
        switch (t.parentKind) {
          case "select":
            pa(n, e.outputType);
            break;
          case "include":
            Ud(n, e.outputType);
            break;
          case "omit":
            Gd(n, e.outputType);
            break;
        }
      }
      r.addErrorMessage((n) => {
        let i = [`Unknown field ${n.red(`\`${t.fieldName}\``)}`];
        return t.parentKind !== "unknown" && i.push(`for ${n.bold(t.parentKind)} statement`), i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`), i.push(dt(n)), i.join(" ");
      });
    }
    function Nd(e, r) {
      let t = da(e.selectionPath, r);
      t.parentKind !== "unknown" && t.field.value.markAsError(), r.addErrorMessage((n) => `Invalid value for selection field \`${n.red(t.fieldName)}\`: ${e.underlyingError}`);
    }
    function Ld(e, r) {
      let t = e.argumentPath[0], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      n && (n.getField(t)?.markAsError(), Qd(n, e.arguments)), r.addErrorMessage((i) => ua(i, t, e.arguments.map((o) => o.name)));
    }
    function Fd(e, r) {
      let [t, n] = Or(e.argumentPath), i = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      if (i) {
        i.getDeepField(e.argumentPath)?.markAsError();
        let o = i.getDeepFieldValue(t)?.asObject();
        o && ma(o, e.inputType);
      }
      r.addErrorMessage((o) => ua(o, n, e.inputType.fields.map((s) => s.name)));
    }
    function ua(e, r, t) {
      let n = [`Unknown argument \`${e.red(r)}\`.`], i = Jd(r, t);
      return i && n.push(`Did you mean \`${e.green(i)}\`?`), t.length > 0 && n.push(dt(e)), n.join(" ");
    }
    function Md(e, r) {
      let t;
      r.addErrorMessage((l) => t?.value instanceof Q && t.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
      let n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      if (!n) return;
      let [i, o] = Or(e.argumentPath), s = new pt(), a = n.getDeepFieldValue(i)?.asObject();
      if (a) {
        if (t = a.getField(o), t && a.removeField(o), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
          for (let l of e.inputTypes[0].fields) s.addField(l.name, l.typeNames.join(" | "));
          a.addSuggestion(new le(o, s).makeRequired());
        } else {
          let l = e.inputTypes.map(ca).join(" | ");
          a.addSuggestion(new le(o, l).makeRequired());
        }
        if (e.dependentArgumentPath) {
          n.getDeepField(e.dependentArgumentPath)?.markAsError();
          let [, l] = Or(e.dependentArgumentPath);
          r.addErrorMessage((u) => `Argument \`${u.green(o)}\` is required because argument \`${u.green(l)}\` was provided.`);
        }
      }
    }
    function ca(e) {
      return e.kind === "list" ? `${ca(e.elementType)}[]` : e.name;
    }
    function $d(e, r) {
      let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      n && n.getDeepFieldValue(e.argumentPath)?.markAsError(), r.addErrorMessage((i) => {
        let o = In("or", e.argument.typeNames.map((s) => i.green(s)));
        return `Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`;
      });
    }
    function qd(e, r) {
      let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      n && n.getDeepFieldValue(e.argumentPath)?.markAsError(), r.addErrorMessage((i) => {
        let o = [`Invalid value for argument \`${i.bold(t)}\``];
        if (e.underlyingError && o.push(`: ${e.underlyingError}`), o.push("."), e.argument.typeNames.length > 0) {
          let s = In("or", e.argument.typeNames.map((a) => i.green(a)));
          o.push(` Expected ${s}.`);
        }
        return o.join("");
      });
    }
    function Vd(e, r) {
      let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i;
      if (n) {
        let s = n.getDeepField(e.argumentPath)?.value;
        s?.markAsError(), s instanceof Q && (i = s.text);
      }
      r.addErrorMessage((o) => {
        let s = ["Unable to fit value"];
        return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``), s.join(" ");
      });
    }
    function jd(e, r) {
      let t = e.argumentPath[e.argumentPath.length - 1], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
      if (n) {
        let i = n.getDeepFieldValue(e.argumentPath)?.asObject();
        i && ma(i, e.inputType);
      }
      r.addErrorMessage((i) => {
        let o = [`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];
        return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${In("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o.push(dt(i)), o.join(" ");
      });
    }
    function Bd(e, r) {
      let t = e.argumentPath[e.argumentPath.length - 1], n = r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i = [];
      if (n) {
        let o = n.getDeepFieldValue(e.argumentPath)?.asObject();
        o && (o.markAsError(), i = Object.keys(o.getFields()));
      }
      r.addErrorMessage((o) => {
        let s = [`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];
        return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${In("and", i.map((a) => o.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
      });
    }
    function pa(e, r) {
      for (let t of r.fields) e.hasField(t.name) || e.addSuggestion(new le(t.name, "true"));
    }
    function Ud(e, r) {
      for (let t of r.fields) t.isRelation && !e.hasField(t.name) && e.addSuggestion(new le(t.name, "true"));
    }
    function Gd(e, r) {
      for (let t of r.fields) !e.hasField(t.name) && !t.isRelation && e.addSuggestion(new le(t.name, "true"));
    }
    function Qd(e, r) {
      for (let t of r) e.hasField(t.name) || e.addSuggestion(new le(t.name, t.typeNames.join(" | ")));
    }
    function da(e, r) {
      let [t, n] = Or(e), i = r.arguments.getDeepSubSelectionValue(t)?.asObject();
      if (!i) return { parentKind: "unknown", fieldName: n };
      let o = i.getFieldValue("select")?.asObject(), s = i.getFieldValue("include")?.asObject(), a = i.getFieldValue("omit")?.asObject(), l = o?.getField(n);
      return o && l ? { parentKind: "select", parent: o, field: l, fieldName: n } : (l = s?.getField(n), s && l ? { parentKind: "include", field: l, parent: s, fieldName: n } : (l = a?.getField(n), a && l ? { parentKind: "omit", field: l, parent: a, fieldName: n } : { parentKind: "unknown", fieldName: n }));
    }
    function ma(e, r) {
      if (r.kind === "object") for (let t of r.fields) e.hasField(t.name) || e.addSuggestion(new le(t.name, t.typeNames.join(" | ")));
    }
    function Or(e) {
      let r = [...e], t = r.pop();
      if (!t) throw new Error("unexpected empty path");
      return [r, t];
    }
    function dt({ green: e, enabled: r }) {
      return "Available options are " + (r ? `listed in ${e("green")}` : "marked with ?") + ".";
    }
    function In(e, r) {
      if (r.length === 1) return r[0];
      let t = [...r], n = t.pop();
      return `${t.join(", ")} ${e} ${n}`;
    }
    var Wd = 3;
    function Jd(e, r) {
      let t = 1 / 0, n;
      for (let i of r) {
        let o = (0, la.default)(e, i);
        o > Wd || o < t && (t = o, n = i);
      }
      return n;
    }
    var mt = class {
      constructor(r, t, n, i, o) {
        __publicField(this, "modelName");
        __publicField(this, "name");
        __publicField(this, "typeName");
        __publicField(this, "isList");
        __publicField(this, "isEnum");
        this.modelName = r, this.name = t, this.typeName = n, this.isList = i, this.isEnum = o;
      }
      _toGraphQLInputType() {
        let r = this.isList ? "List" : "", t = this.isEnum ? "Enum" : "";
        return `${r}${t}${this.typeName}FieldRefInput<${this.modelName}>`;
      }
    };
    function kr(e) {
      return e instanceof mt;
    }
    var Dn = Symbol();
    var Yi = /* @__PURE__ */ new WeakMap();
    var Me = class {
      constructor(r) {
        r === Dn ? Yi.set(this, `Prisma.${this._getName()}`) : Yi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return Yi.get(this);
      }
    };
    var ft = class extends Me {
      _getNamespace() {
        return "NullTypes";
      }
    };
    var _e, _a2;
    var gt = (_a2 = class extends ft {
      constructor() {
        super(...arguments);
        __privateAdd(this, _e);
      }
    }, _e = new WeakMap(), _a2);
    zi(gt, "DbNull");
    var _e2, _a3;
    var ht = (_a3 = class extends ft {
      constructor() {
        super(...arguments);
        __privateAdd(this, _e2);
      }
    }, _e2 = new WeakMap(), _a3);
    zi(ht, "JsonNull");
    var _e3, _a4;
    var yt = (_a4 = class extends ft {
      constructor() {
        super(...arguments);
        __privateAdd(this, _e3);
      }
    }, _e3 = new WeakMap(), _a4);
    zi(yt, "AnyNull");
    var On = { classes: { DbNull: gt, JsonNull: ht, AnyNull: yt }, instances: { DbNull: new gt(Dn), JsonNull: new ht(Dn), AnyNull: new yt(Dn) } };
    function zi(e, r) {
      Object.defineProperty(e, "name", { value: r, configurable: true });
    }
    var fa = ": ";
    var kn = class {
      constructor(r, t) {
        __publicField(this, "hasError", false);
        this.name = r;
        this.value = t;
      }
      markAsError() {
        this.hasError = true;
      }
      getPrintWidth() {
        return this.name.length + this.value.getPrintWidth() + fa.length;
      }
      write(r) {
        let t = new Pe(this.name);
        this.hasError && t.underline().setColor(r.context.colors.red), r.write(t).write(fa).write(this.value);
      }
    };
    var Zi = class {
      constructor(r) {
        __publicField(this, "arguments");
        __publicField(this, "errorMessages", []);
        this.arguments = r;
      }
      write(r) {
        r.write(this.arguments);
      }
      addErrorMessage(r) {
        this.errorMessages.push(r);
      }
      renderAllMessages(r) {
        return this.errorMessages.map((t) => t(r)).join(`
`);
      }
    };
    function _r(e) {
      return new Zi(ga(e));
    }
    function ga(e) {
      let r = new Dr();
      for (let [t, n] of Object.entries(e)) {
        let i = new kn(t, ha(n));
        r.addField(i);
      }
      return r;
    }
    function ha(e) {
      if (typeof e == "string") return new Q(JSON.stringify(e));
      if (typeof e == "number" || typeof e == "boolean") return new Q(String(e));
      if (typeof e == "bigint") return new Q(`${e}n`);
      if (e === null) return new Q("null");
      if (e === void 0) return new Q("undefined");
      if (Sr(e)) return new Q(`new Prisma.Decimal("${e.toFixed()}")`);
      if (e instanceof Uint8Array) return Buffer.isBuffer(e) ? new Q(`Buffer.alloc(${e.byteLength})`) : new Q(`new Uint8Array(${e.byteLength})`);
      if (e instanceof Date) {
        let r = mn(e) ? e.toISOString() : "Invalid Date";
        return new Q(`new Date("${r}")`);
      }
      return e instanceof Me ? new Q(`Prisma.${e._getName()}`) : kr(e) ? new Q(`prisma.${We(e.modelName)}.$fields.${e.name}`) : Array.isArray(e) ? Kd(e) : typeof e == "object" ? ga(e) : new Q(Object.prototype.toString.call(e));
    }
    function Kd(e) {
      let r = new Ir();
      for (let t of e) r.addItem(ha(t));
      return r;
    }
    function _n(e, r) {
      let t = r === "pretty" ? aa : Cn, n = e.renderAllMessages(t), i = new Ar(0, { colors: t }).write(e).toString();
      return { message: n, args: i };
    }
    function Nn({ args: e, errors: r, errorFormat: t, callsite: n, originalMethod: i, clientVersion: o, globalOmit: s }) {
      let a = _r(e);
      for (let p of r) Sn(p, a, s);
      let { message: l, args: u } = _n(a, t), c = Tn({ message: l, callsite: n, originalMethod: i, showColors: t === "pretty", callArguments: u });
      throw new Z(c, { clientVersion: o });
    }
    function Te(e) {
      return e.replace(/^./, (r) => r.toLowerCase());
    }
    function ba(e, r, t) {
      let n = Te(t);
      return !r.result || !(r.result.$allModels || r.result[n]) ? e : Hd({ ...e, ...ya(r.name, e, r.result.$allModels), ...ya(r.name, e, r.result[n]) });
    }
    function Hd(e) {
      let r = new we(), t = (n, i) => r.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e[n] ? e[n].needs.flatMap((o) => t(o, i)) : [n]));
      return pn(e, (n) => ({ ...n, needs: t(n.name, /* @__PURE__ */ new Set()) }));
    }
    function ya(e, r, t) {
      return t ? pn(t, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Yd(r, o, i) })) : {};
    }
    function Yd(e, r, t) {
      let n = e?.[r]?.compute;
      return n ? (i) => t({ ...i, [r]: n(i) }) : t;
    }
    function Ea(e, r) {
      if (!r) return e;
      let t = { ...e };
      for (let n of Object.values(r)) if (e[n.name]) for (let i of n.needs) t[i] = true;
      return t;
    }
    function wa(e, r) {
      if (!r) return e;
      let t = { ...e };
      for (let n of Object.values(r)) if (!e[n.name]) for (let i of n.needs) delete t[i];
      return t;
    }
    var Ln = class {
      constructor(r, t) {
        __publicField(this, "computedFieldsCache", new we());
        __publicField(this, "modelExtensionsCache", new we());
        __publicField(this, "queryCallbacksCache", new we());
        __publicField(this, "clientExtensions", lt(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions()));
        __publicField(this, "batchCallbacks", lt(() => {
          let r = this.previous?.getAllBatchQueryCallbacks() ?? [], t = this.extension.query?.$__internalBatch;
          return t ? r.concat(t) : r;
        }));
        this.extension = r;
        this.previous = t;
      }
      getAllComputedFields(r) {
        return this.computedFieldsCache.getOrCreate(r, () => ba(this.previous?.getAllComputedFields(r), this.extension, r));
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(r) {
        return this.modelExtensionsCache.getOrCreate(r, () => {
          let t = Te(r);
          return !this.extension.model || !(this.extension.model[t] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(r) : { ...this.previous?.getAllModelExtensions(r), ...this.extension.model.$allModels, ...this.extension.model[t] };
        });
      }
      getAllQueryCallbacks(r, t) {
        return this.queryCallbacksCache.getOrCreate(`${r}:${t}`, () => {
          let n = this.previous?.getAllQueryCallbacks(r, t) ?? [], i = [], o = this.extension.query;
          return !o || !(o[r] || o.$allModels || o[t] || o.$allOperations) ? n : (o[r] !== void 0 && (o[r][t] !== void 0 && i.push(o[r][t]), o[r].$allOperations !== void 0 && i.push(o[r].$allOperations)), r !== "$none" && o.$allModels !== void 0 && (o.$allModels[t] !== void 0 && i.push(o.$allModels[t]), o.$allModels.$allOperations !== void 0 && i.push(o.$allModels.$allOperations)), o[t] !== void 0 && i.push(o[t]), o.$allOperations !== void 0 && i.push(o.$allOperations), n.concat(i));
        });
      }
      getAllBatchQueryCallbacks() {
        return this.batchCallbacks.get();
      }
    };
    var Nr = class e {
      constructor(r) {
        this.head = r;
      }
      static empty() {
        return new e();
      }
      static single(r) {
        return new e(new Ln(r));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(r) {
        return new e(new Ln(r, this.head));
      }
      getAllComputedFields(r) {
        return this.head?.getAllComputedFields(r);
      }
      getAllClientExtensions() {
        return this.head?.getAllClientExtensions();
      }
      getAllModelExtensions(r) {
        return this.head?.getAllModelExtensions(r);
      }
      getAllQueryCallbacks(r, t) {
        return this.head?.getAllQueryCallbacks(r, t) ?? [];
      }
      getAllBatchQueryCallbacks() {
        return this.head?.getAllBatchQueryCallbacks() ?? [];
      }
    };
    var Fn = class {
      constructor(r) {
        this.name = r;
      }
    };
    function xa(e) {
      return e instanceof Fn;
    }
    function va(e) {
      return new Fn(e);
    }
    var Pa = Symbol();
    var bt = class {
      constructor(r) {
        if (r !== Pa) throw new Error("Skip instance can not be constructed directly");
      }
      ifUndefined(r) {
        return r === void 0 ? Mn : r;
      }
    };
    var Mn = new bt(Pa);
    function Se(e) {
      return e instanceof bt;
    }
    var zd = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", updateManyAndReturn: "updateManyAndReturn", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
    var Ta = "explicitly `undefined` values are not allowed";
    function $n({ modelName: e, action: r, args: t, runtimeDataModel: n, extensions: i = Nr.empty(), callsite: o, clientMethod: s, errorFormat: a, clientVersion: l, previewFeatures: u, globalOmit: c }) {
      let p = new Xi({ runtimeDataModel: n, modelName: e, action: r, rootArgs: t, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: l, previewFeatures: u, globalOmit: c });
      return { modelName: e, action: zd[r], query: Et(t, p) };
    }
    function Et({ select: e, include: r, ...t } = {}, n) {
      let i = t.omit;
      return delete t.omit, { arguments: Ra(t, n), selection: Zd(e, r, i, n) };
    }
    function Zd(e, r, t, n) {
      return e ? (r ? n.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n.getSelectionPath() }) : t && n.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n.getSelectionPath() }), tm(e, n)) : Xd(n, r, t);
    }
    function Xd(e, r, t) {
      let n = {};
      return e.modelOrType && !e.isRawAction() && (n.$composites = true, n.$scalars = true), r && em(n, r, e), rm(n, t, e), n;
    }
    function em(e, r, t) {
      for (let [n, i] of Object.entries(r)) {
        if (Se(i)) continue;
        let o = t.nestSelection(n);
        if (eo(i, o), i === false || i === void 0) {
          e[n] = false;
          continue;
        }
        let s = t.findField(n);
        if (s && s.kind !== "object" && t.throwValidationError({ kind: "IncludeOnScalar", selectionPath: t.getSelectionPath().concat(n), outputType: t.getOutputTypeDescription() }), s) {
          e[n] = Et(i === true ? {} : i, o);
          continue;
        }
        if (i === true) {
          e[n] = true;
          continue;
        }
        e[n] = Et(i, o);
      }
    }
    function rm(e, r, t) {
      let n = t.getComputedFields(), i = { ...t.getGlobalOmit(), ...r }, o = wa(i, n);
      for (let [s, a] of Object.entries(o)) {
        if (Se(a)) continue;
        eo(a, t.nestSelection(s));
        let l = t.findField(s);
        n?.[s] && !l || (e[s] = !a);
      }
    }
    function tm(e, r) {
      let t = {}, n = r.getComputedFields(), i = Ea(e, n);
      for (let [o, s] of Object.entries(i)) {
        if (Se(s)) continue;
        let a = r.nestSelection(o);
        eo(s, a);
        let l = r.findField(o);
        if (!(n?.[o] && !l)) {
          if (s === false || s === void 0 || Se(s)) {
            t[o] = false;
            continue;
          }
          if (s === true) {
            l?.kind === "object" ? t[o] = Et({}, a) : t[o] = true;
            continue;
          }
          t[o] = Et(s, a);
        }
      }
      return t;
    }
    function Sa(e, r) {
      if (e === null) return null;
      if (typeof e == "string" || typeof e == "number" || typeof e == "boolean") return e;
      if (typeof e == "bigint") return { $type: "BigInt", value: String(e) };
      if (vr(e)) {
        if (mn(e)) return { $type: "DateTime", value: e.toISOString() };
        r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r.getSelectionPath(), argumentPath: r.getArgumentPath(), argument: { name: r.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
      }
      if (xa(e)) return { $type: "Param", value: e.name };
      if (kr(e)) return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
      if (Array.isArray(e)) return nm(e, r);
      if (ArrayBuffer.isView(e)) {
        let { buffer: t, byteOffset: n, byteLength: i } = e;
        return { $type: "Bytes", value: Buffer.from(t, n, i).toString("base64") };
      }
      if (im(e)) return e.values;
      if (Sr(e)) return { $type: "Decimal", value: e.toFixed() };
      if (e instanceof Me) {
        if (e !== On.instances[e._getName()]) throw new Error("Invalid ObjectEnumValue");
        return { $type: "Enum", value: e._getName() };
      }
      if (om(e)) return e.toJSON();
      if (typeof e == "object") return Ra(e, r);
      r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r.getSelectionPath(), argumentPath: r.getArgumentPath(), argument: { name: r.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
    }
    function Ra(e, r) {
      if (e.$type) return { $type: "Raw", value: e };
      let t = {};
      for (let n in e) {
        let i = e[n], o = r.nestArgument(n);
        Se(i) || (i !== void 0 ? t[n] = Sa(i, o) : r.isPreviewFeatureOn("strictUndefinedChecks") && r.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: o.getArgumentPath(), selectionPath: r.getSelectionPath(), argument: { name: r.getArgumentName(), typeNames: [] }, underlyingError: Ta }));
      }
      return t;
    }
    function nm(e, r) {
      let t = [];
      for (let n = 0; n < e.length; n++) {
        let i = r.nestArgument(String(n)), o = e[n];
        if (o === void 0 || Se(o)) {
          let s = o === void 0 ? "undefined" : "Prisma.skip";
          r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${r.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: `Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values` });
        }
        t.push(Sa(o, i));
      }
      return t;
    }
    function im(e) {
      return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
    }
    function om(e) {
      return typeof e == "object" && e !== null && typeof e.toJSON == "function";
    }
    function eo(e, r) {
      e === void 0 && r.isPreviewFeatureOn("strictUndefinedChecks") && r.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: r.getSelectionPath(), underlyingError: Ta });
    }
    var Xi = class e {
      constructor(r) {
        __publicField(this, "modelOrType");
        this.params = r;
        this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
      }
      throwValidationError(r) {
        Nn({ errors: [r], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
      }
      getSelectionPath() {
        return this.params.selectionPath;
      }
      getArgumentPath() {
        return this.params.argumentPath;
      }
      getArgumentName() {
        return this.params.argumentPath[this.params.argumentPath.length - 1];
      }
      getOutputTypeDescription() {
        if (!(!this.params.modelName || !this.modelOrType)) return { name: this.params.modelName, fields: this.modelOrType.fields.map((r) => ({ name: r.name, typeName: "boolean", isRelation: r.kind === "object" })) };
      }
      isRawAction() {
        return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
      }
      isPreviewFeatureOn(r) {
        return this.params.previewFeatures.includes(r);
      }
      getComputedFields() {
        if (this.params.modelName) return this.params.extensions.getAllComputedFields(this.params.modelName);
      }
      findField(r) {
        return this.modelOrType?.fields.find((t) => t.name === r);
      }
      nestSelection(r) {
        let t = this.findField(r), n = t?.kind === "object" ? t.type : void 0;
        return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(r) });
      }
      getGlobalOmit() {
        return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[We(this.params.modelName)] ?? {} : {};
      }
      shouldApplyGlobalOmit() {
        switch (this.params.action) {
          case "findFirst":
          case "findFirstOrThrow":
          case "findUniqueOrThrow":
          case "findMany":
          case "upsert":
          case "findUnique":
          case "createManyAndReturn":
          case "create":
          case "update":
          case "updateManyAndReturn":
          case "delete":
            return true;
          case "executeRaw":
          case "aggregateRaw":
          case "runCommandRaw":
          case "findRaw":
          case "createMany":
          case "deleteMany":
          case "groupBy":
          case "updateMany":
          case "count":
          case "aggregate":
          case "queryRaw":
            return false;
          default:
            ar(this.params.action, "Unknown action");
        }
      }
      nestArgument(r) {
        return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(r) });
      }
    };
    function Aa(e) {
      if (!e._hasPreviewFlag("metrics")) throw new Z("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: e._clientVersion });
    }
    var Lr = class {
      constructor(r) {
        __publicField(this, "_client");
        this._client = r;
      }
      prometheus(r) {
        return Aa(this._client), this._client._engine.metrics({ format: "prometheus", ...r });
      }
      json(r) {
        return Aa(this._client), this._client._engine.metrics({ format: "json", ...r });
      }
    };
    function Ca(e, r) {
      let t = lt(() => sm(r));
      Object.defineProperty(e, "dmmf", { get: () => t.get() });
    }
    function sm(e) {
      return { datamodel: { models: ro(e.models), enums: ro(e.enums), types: ro(e.types) } };
    }
    function ro(e) {
      return Object.entries(e).map(([r, t]) => ({ name: r, ...t }));
    }
    var to = /* @__PURE__ */ new WeakMap();
    var qn = "$$PrismaTypedSql";
    var wt = class {
      constructor(r, t) {
        to.set(this, { sql: r, values: t }), Object.defineProperty(this, qn, { value: qn });
      }
      get sql() {
        return to.get(this).sql;
      }
      get values() {
        return to.get(this).values;
      }
    };
    function Ia(e) {
      return (...r) => new wt(e, r);
    }
    function Vn(e) {
      return e != null && e[qn] === qn;
    }
    var cu = O(Ti());
    var pu = require("async_hooks");
    var du = require("events");
    var mu = O(require("fs"));
    var ri = O(require("path"));
    var ie = class e {
      constructor(r, t) {
        if (r.length - 1 !== t.length) throw r.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${r.length} strings to have ${r.length - 1} values`);
        let n = t.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
        this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = r[0];
        let i = 0, o = 0;
        for (; i < t.length; ) {
          let s = t[i++], a = r[i];
          if (s instanceof e) {
            this.strings[o] += s.strings[0];
            let l = 0;
            for (; l < s.values.length; ) this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
            this.strings[o] += a;
          } else this.values[o++] = s, this.strings[o] = a;
        }
      }
      get sql() {
        let r = this.strings.length, t = 1, n = this.strings[0];
        for (; t < r; ) n += `?${this.strings[t++]}`;
        return n;
      }
      get statement() {
        let r = this.strings.length, t = 1, n = this.strings[0];
        for (; t < r; ) n += `:${t}${this.strings[t++]}`;
        return n;
      }
      get text() {
        let r = this.strings.length, t = 1, n = this.strings[0];
        for (; t < r; ) n += `$${t}${this.strings[t++]}`;
        return n;
      }
      inspect() {
        return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
      }
    };
    function Da(e, r = ",", t = "", n = "") {
      if (e.length === 0) throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      return new ie([t, ...Array(e.length - 1).fill(r), n], e);
    }
    function no(e) {
      return new ie([e], []);
    }
    var Oa = no("");
    function io(e, ...r) {
      return new ie(e, r);
    }
    function xt(e) {
      return { getKeys() {
        return Object.keys(e);
      }, getPropertyValue(r) {
        return e[r];
      } };
    }
    function re(e, r) {
      return { getKeys() {
        return [e];
      }, getPropertyValue() {
        return r();
      } };
    }
    function lr(e) {
      let r = new we();
      return { getKeys() {
        return e.getKeys();
      }, getPropertyValue(t) {
        return r.getOrCreate(t, () => e.getPropertyValue(t));
      }, getPropertyDescriptor(t) {
        return e.getPropertyDescriptor?.(t);
      } };
    }
    var jn = { enumerable: true, configurable: true, writable: true };
    function Bn(e) {
      let r = new Set(e);
      return { getPrototypeOf: () => Object.prototype, getOwnPropertyDescriptor: () => jn, has: (t, n) => r.has(n), set: (t, n, i) => r.add(n) && Reflect.set(t, n, i), ownKeys: () => [...r] };
    }
    var ka = Symbol.for("nodejs.util.inspect.custom");
    function he(e, r) {
      let t = am(r), n = /* @__PURE__ */ new Set(), i = new Proxy(e, { get(o, s) {
        if (n.has(s)) return o[s];
        let a = t.get(s);
        return a ? a.getPropertyValue(s) : o[s];
      }, has(o, s) {
        if (n.has(s)) return true;
        let a = t.get(s);
        return a ? a.has?.(s) ?? true : Reflect.has(o, s);
      }, ownKeys(o) {
        let s = _a(Reflect.ownKeys(o), t), a = _a(Array.from(t.keys()), t);
        return [.../* @__PURE__ */ new Set([...s, ...a, ...n])];
      }, set(o, s, a) {
        return t.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a));
      }, getOwnPropertyDescriptor(o, s) {
        let a = Reflect.getOwnPropertyDescriptor(o, s);
        if (a && !a.configurable) return a;
        let l = t.get(s);
        return l ? l.getPropertyDescriptor ? { ...jn, ...l?.getPropertyDescriptor(s) } : jn : a;
      }, defineProperty(o, s, a) {
        return n.add(s), Reflect.defineProperty(o, s, a);
      }, getPrototypeOf: () => Object.prototype });
      return i[ka] = function() {
        let o = { ...this };
        return delete o[ka], o;
      }, i;
    }
    function am(e) {
      let r = /* @__PURE__ */ new Map();
      for (let t of e) {
        let n = t.getKeys();
        for (let i of n) r.set(i, t);
      }
      return r;
    }
    function _a(e, r) {
      return e.filter((t) => r.get(t)?.has?.(t) ?? true);
    }
    function Fr(e) {
      return { getKeys() {
        return e;
      }, has() {
        return false;
      }, getPropertyValue() {
      } };
    }
    function Mr(e, r) {
      return { batch: e, transaction: r?.kind === "batch" ? { isolationLevel: r.options.isolationLevel } : void 0 };
    }
    function Na(e) {
      if (e === void 0) return "";
      let r = _r(e);
      return new Ar(0, { colors: Cn }).write(r).toString();
    }
    var lm = "P2037";
    function $r({ error: e, user_facing_error: r }, t, n) {
      return r.error_code ? new z(um(r, n), { code: r.error_code, clientVersion: t, meta: r.meta, batchRequestIdx: r.batch_request_idx }) : new V(e, { clientVersion: t, batchRequestIdx: r.batch_request_idx });
    }
    function um(e, r) {
      let t = e.message;
      return (r === "postgresql" || r === "postgres" || r === "mysql") && e.error_code === lm && (t += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), t;
    }
    var vt = "<unknown>";
    function La(e) {
      var r = e.split(`
`);
      return r.reduce(function(t, n) {
        var i = dm(n) || fm(n) || ym(n) || xm(n) || Em(n);
        return i && t.push(i), t;
      }, []);
    }
    var cm = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var pm = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function dm(e) {
      var r = cm.exec(e);
      if (!r) return null;
      var t = r[2] && r[2].indexOf("native") === 0, n = r[2] && r[2].indexOf("eval") === 0, i = pm.exec(r[2]);
      return n && i != null && (r[2] = i[1], r[3] = i[2], r[4] = i[3]), { file: t ? null : r[2], methodName: r[1] || vt, arguments: t ? [r[2]] : [], lineNumber: r[3] ? +r[3] : null, column: r[4] ? +r[4] : null };
    }
    var mm = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function fm(e) {
      var r = mm.exec(e);
      return r ? { file: r[2], methodName: r[1] || vt, arguments: [], lineNumber: +r[3], column: r[4] ? +r[4] : null } : null;
    }
    var gm = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var hm = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function ym(e) {
      var r = gm.exec(e);
      if (!r) return null;
      var t = r[3] && r[3].indexOf(" > eval") > -1, n = hm.exec(r[3]);
      return t && n != null && (r[3] = n[1], r[4] = n[2], r[5] = null), { file: r[3], methodName: r[1] || vt, arguments: r[2] ? r[2].split(",") : [], lineNumber: r[4] ? +r[4] : null, column: r[5] ? +r[5] : null };
    }
    var bm = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function Em(e) {
      var r = bm.exec(e);
      return r ? { file: r[3], methodName: r[1] || vt, arguments: [], lineNumber: +r[4], column: r[5] ? +r[5] : null } : null;
    }
    var wm = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function xm(e) {
      var r = wm.exec(e);
      return r ? { file: r[2], methodName: r[1] || vt, arguments: [], lineNumber: +r[3], column: r[4] ? +r[4] : null } : null;
    }
    var oo = class {
      getLocation() {
        return null;
      }
    };
    var so = class {
      constructor() {
        __publicField(this, "_error");
        this._error = new Error();
      }
      getLocation() {
        let r = this._error.stack;
        if (!r) return null;
        let n = La(r).find((i) => {
          if (!i.file) return false;
          let o = Li(i.file);
          return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
        });
        return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
      }
    };
    function Ze(e) {
      return e === "minimal" ? typeof $EnabledCallSite == "function" && e !== "minimal" ? new $EnabledCallSite() : new oo() : new so();
    }
    var Fa = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function qr(e = {}) {
      let r = Pm(e);
      return Object.entries(r).reduce((n, [i, o]) => (Fa[i] !== void 0 ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
    }
    function Pm(e = {}) {
      return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
    }
    function Un(e = {}) {
      return (r) => (typeof e._count == "boolean" && (r._count = r._count._all), r);
    }
    function Ma(e, r) {
      let t = Un(e);
      return r({ action: "aggregate", unpacker: t, argsMapper: qr })(e);
    }
    function Tm(e = {}) {
      let { select: r, ...t } = e;
      return typeof r == "object" ? qr({ ...t, _count: r }) : qr({ ...t, _count: { _all: true } });
    }
    function Sm(e = {}) {
      return typeof e.select == "object" ? (r) => Un(e)(r)._count : (r) => Un(e)(r)._count._all;
    }
    function $a(e, r) {
      return r({ action: "count", unpacker: Sm(e), argsMapper: Tm })(e);
    }
    function Rm(e = {}) {
      let r = qr(e);
      if (Array.isArray(r.by)) for (let t of r.by) typeof t == "string" && (r.select[t] = true);
      else typeof r.by == "string" && (r.select[r.by] = true);
      return r;
    }
    function Am(e = {}) {
      return (r) => (typeof e?._count == "boolean" && r.forEach((t) => {
        t._count = t._count._all;
      }), r);
    }
    function qa(e, r) {
      return r({ action: "groupBy", unpacker: Am(e), argsMapper: Rm })(e);
    }
    function Va(e, r, t) {
      if (r === "aggregate") return (n) => Ma(n, t);
      if (r === "count") return (n) => $a(n, t);
      if (r === "groupBy") return (n) => qa(n, t);
    }
    function ja(e, r) {
      let t = r.fields.filter((i) => !i.relationName), n = _s(t, "name");
      return new Proxy({}, { get(i, o) {
        if (o in i || typeof o == "symbol") return i[o];
        let s = n[o];
        if (s) return new mt(e, o, s.type, s.isList, s.kind === "enum");
      }, ...Bn(Object.keys(n)) });
    }
    var Ba = (e) => Array.isArray(e) ? e : e.split(".");
    var ao = (e, r) => Ba(r).reduce((t, n) => t && t[n], e);
    var Ua = (e, r, t) => Ba(r).reduceRight((n, i, o, s) => Object.assign({}, ao(e, s.slice(0, o)), { [i]: n }), t);
    function Cm(e, r) {
      return e === void 0 || r === void 0 ? [] : [...r, "select", e];
    }
    function Im(e, r, t) {
      return r === void 0 ? e ?? {} : Ua(r, t, e || true);
    }
    function lo(e, r, t, n, i, o) {
      let a = e._runtimeDataModel.models[r].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
      return (l) => {
        let u = Ze(e._errorFormat), c = Cm(n, i), p = Im(l, o, c), d = t({ dataPath: c, callsite: u })(p), f = Dm(e, r);
        return new Proxy(d, { get(h, g) {
          if (!f.includes(g)) return h[g];
          let T = [a[g].type, t, g], S = [c, p];
          return lo(e, ...T, ...S);
        }, ...Bn([...f, ...Object.getOwnPropertyNames(d)]) });
      };
    }
    function Dm(e, r) {
      return e._runtimeDataModel.models[r].fields.filter((t) => t.kind === "object").map((t) => t.name);
    }
    var Om = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
    var km = ["aggregate", "count", "groupBy"];
    function uo(e, r) {
      let t = e._extensions.getAllModelExtensions(r) ?? {}, n = [_m(e, r), Lm(e, r), xt(t), re("name", () => r), re("$name", () => r), re("$parent", () => e._appliedParent)];
      return he({}, n);
    }
    function _m(e, r) {
      let t = Te(r), n = Object.keys(Rr).concat("count");
      return { getKeys() {
        return n;
      }, getPropertyValue(i) {
        let o = i, s = (a) => (l) => {
          let u = Ze(e._errorFormat);
          return e._createPrismaPromise((c) => {
            let p = { args: l, dataPath: [], action: o, model: r, clientMethod: `${t}.${i}`, jsModelName: t, transaction: c, callsite: u };
            return e._request({ ...p, ...a });
          }, { action: o, args: l, model: r });
        };
        return Om.includes(o) ? lo(e, r, s) : Nm(i) ? Va(e, i, s) : s({});
      } };
    }
    function Nm(e) {
      return km.includes(e);
    }
    function Lm(e, r) {
      return lr(re("fields", () => {
        let t = e._runtimeDataModel.models[r];
        return ja(r, t);
      }));
    }
    function Ga(e) {
      return e.replace(/^./, (r) => r.toUpperCase());
    }
    var co = Symbol();
    function Pt(e) {
      let r = [Fm(e), Mm(e), re(co, () => e), re("$parent", () => e._appliedParent)], t = e._extensions.getAllClientExtensions();
      return t && r.push(xt(t)), he(e, r);
    }
    function Fm(e) {
      let r = Object.getPrototypeOf(e._originalClient), t = [...new Set(Object.getOwnPropertyNames(r))];
      return { getKeys() {
        return t;
      }, getPropertyValue(n) {
        return e[n];
      } };
    }
    function Mm(e) {
      let r = Object.keys(e._runtimeDataModel.models), t = r.map(Te), n = [...new Set(r.concat(t))];
      return lr({ getKeys() {
        return n;
      }, getPropertyValue(i) {
        let o = Ga(i);
        if (e._runtimeDataModel.models[o] !== void 0) return uo(e, o);
        if (e._runtimeDataModel.models[i] !== void 0) return uo(e, i);
      }, getPropertyDescriptor(i) {
        if (!t.includes(i)) return { enumerable: false };
      } });
    }
    function Qa(e) {
      return e[co] ? e[co] : e;
    }
    function Wa(e) {
      if (typeof e == "function") return e(this);
      if (e.client?.__AccelerateEngine) {
        let t = e.client.__AccelerateEngine;
        this._originalClient._engine = new t(this._originalClient._accelerateEngineConfig);
      }
      let r = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $on: { value: void 0 } });
      return Pt(r);
    }
    function Ja({ result: e, modelName: r, select: t, omit: n, extensions: i }) {
      let o = i.getAllComputedFields(r);
      if (!o) return e;
      let s = [], a = [];
      for (let l of Object.values(o)) {
        if (n) {
          if (n[l.name]) continue;
          let u = l.needs.filter((c) => n[c]);
          u.length > 0 && a.push(Fr(u));
        } else if (t) {
          if (!t[l.name]) continue;
          let u = l.needs.filter((c) => !t[c]);
          u.length > 0 && a.push(Fr(u));
        }
        $m(e, l.needs) && s.push(qm(l, he(e, s)));
      }
      return s.length > 0 || a.length > 0 ? he(e, [...s, ...a]) : e;
    }
    function $m(e, r) {
      return r.every((t) => Vi(e, t));
    }
    function qm(e, r) {
      return lr(re(e.name, () => e.compute(r)));
    }
    function Gn({ visitor: e, result: r, args: t, runtimeDataModel: n, modelName: i }) {
      if (Array.isArray(r)) {
        for (let s = 0; s < r.length; s++) r[s] = Gn({ result: r[s], args: t, modelName: i, runtimeDataModel: n, visitor: e });
        return r;
      }
      let o = e(r, i, t) ?? r;
      return t.include && Ka({ includeOrSelect: t.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), t.select && Ka({ includeOrSelect: t.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), o;
    }
    function Ka({ includeOrSelect: e, result: r, parentModelName: t, runtimeDataModel: n, visitor: i }) {
      for (let [o, s] of Object.entries(e)) {
        if (!s || r[o] == null || Se(s)) continue;
        let l = n.models[t].fields.find((c) => c.name === o);
        if (!l || l.kind !== "object" || !l.relationName) continue;
        let u = typeof s == "object" ? s : {};
        r[o] = Gn({ visitor: i, result: r[o], args: u, modelName: l.type, runtimeDataModel: n });
      }
    }
    function Ha({ result: e, modelName: r, args: t, extensions: n, runtimeDataModel: i, globalOmit: o }) {
      return n.isEmpty() || e == null || typeof e != "object" || !i.models[r] ? e : Gn({ result: e, args: t ?? {}, modelName: r, runtimeDataModel: i, visitor: (a, l, u) => {
        let c = Te(l);
        return Ja({ result: a, modelName: c, select: u.select, omit: u.select ? void 0 : { ...o?.[c], ...u.omit }, extensions: n });
      } });
    }
    var Vm = ["$connect", "$disconnect", "$on", "$transaction", "$extends"];
    var Ya = Vm;
    function za(e) {
      if (e instanceof ie) return jm(e);
      if (Vn(e)) return Bm(e);
      if (Array.isArray(e)) {
        let t = [e[0]];
        for (let n = 1; n < e.length; n++) t[n] = Tt(e[n]);
        return t;
      }
      let r = {};
      for (let t in e) r[t] = Tt(e[t]);
      return r;
    }
    function jm(e) {
      return new ie(e.strings, e.values);
    }
    function Bm(e) {
      return new wt(e.sql, e.values);
    }
    function Tt(e) {
      if (typeof e != "object" || e == null || e instanceof Me || kr(e)) return e;
      if (Sr(e)) return new Fe(e.toFixed());
      if (vr(e)) return /* @__PURE__ */ new Date(+e);
      if (ArrayBuffer.isView(e)) return e.slice(0);
      if (Array.isArray(e)) {
        let r = e.length, t;
        for (t = Array(r); r--; ) t[r] = Tt(e[r]);
        return t;
      }
      if (typeof e == "object") {
        let r = {};
        for (let t in e) t === "__proto__" ? Object.defineProperty(r, t, { value: Tt(e[t]), configurable: true, enumerable: true, writable: true }) : r[t] = Tt(e[t]);
        return r;
      }
      ar(e, "Unknown value");
    }
    function Xa(e, r, t, n = 0) {
      return e._createPrismaPromise((i) => {
        let o = r.customDataProxyFetch;
        return "transaction" in r && i !== void 0 && (r.transaction?.kind === "batch" && r.transaction.lock.then(), r.transaction = i), n === t.length ? e._executeRequest(r) : t[n]({ model: r.model, operation: r.model ? r.action : r.clientMethod, args: za(r.args ?? {}), __internalParams: r, query: (s, a = r) => {
          let l = a.customDataProxyFetch;
          return a.customDataProxyFetch = nl(o, l), a.args = s, Xa(e, a, t, n + 1);
        } });
      });
    }
    function el(e, r) {
      let { jsModelName: t, action: n, clientMethod: i } = r, o = t ? n : i;
      if (e._extensions.isEmpty()) return e._executeRequest(r);
      let s = e._extensions.getAllQueryCallbacks(t ?? "$none", o);
      return Xa(e, r, s);
    }
    function rl(e) {
      return (r) => {
        let t = { requests: r }, n = r[0].extensions.getAllBatchQueryCallbacks();
        return n.length ? tl(t, n, 0, e) : e(t);
      };
    }
    function tl(e, r, t, n) {
      if (t === r.length) return n(e);
      let i = e.customDataProxyFetch, o = e.requests[0].transaction;
      return r[t]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : void 0 } : void 0 }, __internalParams: e, query(s, a = e) {
        let l = a.customDataProxyFetch;
        return a.customDataProxyFetch = nl(i, l), tl(a, r, t + 1, n);
      } });
    }
    var Za = (e) => e;
    function nl(e = Za, r = Za) {
      return (t) => e(r(t));
    }
    var il = N("prisma:client");
    var ol = { Vercel: "vercel", "Netlify CI": "netlify" };
    function sl({ postinstall: e, ciName: r, clientVersion: t, generator: n }) {
      if (il("checkPlatformCaching:postinstall", e), il("checkPlatformCaching:ciName", r), e === true && !(n?.output && typeof (n.output.fromEnvVar ?? n.output.value) == "string") && r && r in ol) {
        let i = `Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ol[r]}-build`;
        throw console.error(i), new P(i, t);
      }
    }
    function al(e, r) {
      return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [r[0]]: { url: e.datasourceUrl } } : {} : {};
    }
    var dl = O(require("fs"));
    var St = O(require("path"));
    function Qn(e) {
      let { runtimeBinaryTarget: r } = e;
      return `Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Um(e)}`;
    }
    function Um(e) {
      let { generator: r, generatorBinaryTargets: t, runtimeBinaryTarget: n } = e, i = { fromEnvVar: null, value: n }, o = [...t, i];
      return ki({ ...r, binaryTargets: o });
    }
    function Xe(e) {
      let { runtimeBinaryTarget: r } = e;
      return `Prisma Client could not locate the Query Engine for runtime "${r}".`;
    }
    function er(e) {
      let { searchedLocations: r } = e;
      return `The following locations have been searched:
${[...new Set(r)].map((i) => `  ${i}`).join(`
`)}`;
    }
    function ll(e) {
      let { runtimeBinaryTarget: r } = e;
      return `${Xe(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".
${Qn(e)}

${er(e)}`;
    }
    function Wn(e) {
      return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
    }
    function Jn(e) {
      let { errorStack: r } = e;
      return r?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
    }
    function ul(e) {
      let { queryEngineName: r } = e;
      return `${Xe(e)}${Jn(e)}

This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.
Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".

${Wn("engine-not-found-bundler-investigation")}

${er(e)}`;
    }
    function cl(e) {
      let { runtimeBinaryTarget: r, generatorBinaryTargets: t } = e, n = t.find((i) => i.native);
      return `${Xe(e)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${r}".
${Qn(e)}

${er(e)}`;
    }
    function pl(e) {
      let { queryEngineName: r } = e;
      return `${Xe(e)}${Jn(e)}

This is likely caused by tooling that has not copied "${r}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".

${Wn("engine-not-found-tooling-investigation")}

${er(e)}`;
    }
    var Gm = N("prisma:client:engines:resolveEnginePath");
    var Qm = () => new RegExp("runtime[\\\\/]library\\.m?js$");
    async function ml(e, r) {
      let t = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? r.prismaPath;
      if (t !== void 0) return t;
      let { enginePath: n, searchedLocations: i } = await Wm(e, r);
      if (Gm("enginePath", n), n !== void 0 && e === "binary" && Ri(n), n !== void 0) return r.prismaPath = n;
      let o = await ir(), s = r.generator?.binaryTargets ?? [], a = s.some((d) => d.native), l = !s.some((d) => d.value === o), u = __filename.match(Qm()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: r.generator, runtimeBinaryTarget: o, queryEngineName: fl(e, o), expectedLocation: St.default.relative(process.cwd(), r.dirname), errorStack: new Error().stack }, p;
      throw a && l ? p = cl(c) : l ? p = ll(c) : u ? p = ul(c) : p = pl(c), new P(p, r.clientVersion);
    }
    async function Wm(e, r) {
      let t = await ir(), n = [], i = [r.dirname, St.default.resolve(__dirname, ".."), r.generator?.output?.value ?? __dirname, St.default.resolve(__dirname, "../../../.prisma/client"), "/tmp/prisma-engines", r.cwd];
      __filename.includes("resolveEnginePath") && i.push(ms());
      for (let o of i) {
        let s = fl(e, t), a = St.default.join(o, s);
        if (n.push(o), dl.default.existsSync(a)) return { enginePath: a, searchedLocations: n };
      }
      return { enginePath: void 0, searchedLocations: n };
    }
    function fl(e, r) {
      return e === "library" ? Gt(r, "fs") : `query-engine-${r}${r === "windows" ? ".exe" : ""}`;
    }
    function gl(e) {
      return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (r) => `${r[0]}5`) : "";
    }
    function hl(e) {
      return e.split(`
`).map((r) => r.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
    }
    var yl = O(Os());
    function bl({ title: e, user: r = "prisma", repo: t = "prisma", template: n = "bug_report.yml", body: i }) {
      return (0, yl.default)({ user: r, repo: t, template: n, title: e, body: i });
    }
    function El({ version: e, binaryTarget: r, title: t, description: n, engineVersion: i, database: o, query: s }) {
      let a = Bo(6e3 - (s?.length ?? 0)), l = hl(wr(a)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = wr(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${r?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? gl(s) : ""}
\`\`\`
`), p = bl({ title: t, body: c });
      return `${t}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${Y(p)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
    }
    function wl(e, r) {
      throw new Error(r);
    }
    function Jm(e) {
      return e !== null && typeof e == "object" && typeof e.$type == "string";
    }
    function Km(e, r) {
      let t = {};
      for (let n of Object.keys(e)) t[n] = r(e[n], n);
      return t;
    }
    function Vr(e) {
      return e === null ? e : Array.isArray(e) ? e.map(Vr) : typeof e == "object" ? Jm(e) ? Hm(e) : e.constructor !== null && e.constructor.name !== "Object" ? e : Km(e, Vr) : e;
    }
    function Hm({ $type: e, value: r }) {
      switch (e) {
        case "BigInt":
          return BigInt(r);
        case "Bytes": {
          let { buffer: t, byteOffset: n, byteLength: i } = Buffer.from(r, "base64");
          return new Uint8Array(t, n, i);
        }
        case "DateTime":
          return new Date(r);
        case "Decimal":
          return new Le(r);
        case "Json":
          return JSON.parse(r);
        default:
          wl(r, "Unknown tagged value");
      }
    }
    var xl = "6.16.2";
    var zm = () => globalThis.process?.release?.name === "node";
    var Zm = () => !!globalThis.Bun || !!globalThis.process?.versions?.bun;
    var Xm = () => !!globalThis.Deno;
    var ef = () => typeof globalThis.Netlify == "object";
    var rf = () => typeof globalThis.EdgeRuntime == "object";
    var tf = () => globalThis.navigator?.userAgent === "Cloudflare-Workers";
    function nf() {
      return [[ef, "netlify"], [rf, "edge-light"], [tf, "workerd"], [Xm, "deno"], [Zm, "bun"], [zm, "node"]].flatMap((t) => t[0]() ? [t[1]] : []).at(0) ?? "";
    }
    var of = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
    function Kn() {
      let e = nf();
      return { id: e, prettyName: of[e] || e, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e) };
    }
    function jr({ inlineDatasources: e, overrideDatasources: r, env: t, clientVersion: n }) {
      let i, o = Object.keys(e)[0], s = e[o]?.url, a = r[o]?.url;
      if (o === void 0 ? i = void 0 : a ? i = a : s?.value ? i = s.value : s?.fromEnvVar && (i = t[s.fromEnvVar]), s?.fromEnvVar !== void 0 && i === void 0) throw new P(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
      if (i === void 0) throw new P("error: Missing URL environment variable, value, or override.", n);
      return i;
    }
    var Hn = class extends Error {
      constructor(r, t) {
        super(r);
        __publicField(this, "clientVersion");
        __publicField(this, "cause");
        this.clientVersion = t.clientVersion, this.cause = t.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    var oe = class extends Hn {
      constructor(r, t) {
        super(r, t);
        __publicField(this, "isRetryable");
        this.isRetryable = t.isRetryable ?? true;
      }
    };
    function R(e, r) {
      return { ...e, isRetryable: r };
    }
    var ur = class extends oe {
      constructor(r, t) {
        super(r, R(t, false));
        __publicField(this, "name", "InvalidDatasourceError");
        __publicField(this, "code", "P6001");
      }
    };
    x(ur, "InvalidDatasourceError");
    function vl(e) {
      let r = { clientVersion: e.clientVersion }, t = Object.keys(e.inlineDatasources)[0], n = jr({ inlineDatasources: e.inlineDatasources, overrideDatasources: e.overrideDatasources, clientVersion: e.clientVersion, env: { ...e.env, ...typeof process < "u" ? process.env : {} } }), i;
      try {
        i = new URL(n);
      } catch {
        throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``, r);
      }
      let { protocol: o, searchParams: s } = i;
      if (o !== "prisma:" && o !== sn) throw new ur(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``, r);
      let a = s.get("api_key");
      if (a === null || a.length < 1) throw new ur(`Error validating datasource \`${t}\`: the URL must contain a valid API key`, r);
      let l = Ii(i) ? "http:" : "https:";
      process.env.TEST_CLIENT_ENGINE_REMOTE_EXECUTOR && i.searchParams.has("use_http") && (l = "http:");
      let u = new URL(i.href.replace(o, l));
      return { apiKey: a, url: u };
    }
    var Pl = O(on());
    var _Yn_instances, e_fn, _a5;
    var Yn = (_a5 = class {
      constructor({ apiKey: r, tracingHelper: t, logLevel: n, logQueries: i, engineHash: o }) {
        __privateAdd(this, _Yn_instances);
        __publicField(this, "apiKey");
        __publicField(this, "tracingHelper");
        __publicField(this, "logLevel");
        __publicField(this, "logQueries");
        __publicField(this, "engineHash");
        this.apiKey = r, this.tracingHelper = t, this.logLevel = n, this.logQueries = i, this.engineHash = o;
      }
      build({ traceparent: r, transactionId: t } = {}) {
        let n = { Accept: "application/json", Authorization: `Bearer ${this.apiKey}`, "Content-Type": "application/json", "Prisma-Engine-Hash": this.engineHash, "Prisma-Engine-Version": Pl.enginesVersion };
        this.tracingHelper.isEnabled() && (n.traceparent = r ?? this.tracingHelper.getTraceParent()), t && (n["X-Transaction-Id"] = t);
        let i = __privateMethod(this, _Yn_instances, e_fn).call(this);
        return i.length > 0 && (n["X-Capture-Telemetry"] = i.join(", ")), n;
      }
    }, _Yn_instances = new WeakSet(), e_fn = function() {
      let r = [];
      return this.tracingHelper.isEnabled() && r.push("tracing"), this.logLevel && r.push(this.logLevel), this.logQueries && r.push("query"), r;
    }, _a5);
    function sf(e) {
      return e[0] * 1e3 + e[1] / 1e6;
    }
    function po(e) {
      return new Date(sf(e));
    }
    var Br = class extends oe {
      constructor(r) {
        super("This request must be retried", R(r, true));
        __publicField(this, "name", "ForcedRetryError");
        __publicField(this, "code", "P5001");
      }
    };
    x(Br, "ForcedRetryError");
    var cr = class extends oe {
      constructor(r, t) {
        super(r, R(t, false));
        __publicField(this, "name", "NotImplementedYetError");
        __publicField(this, "code", "P5004");
      }
    };
    x(cr, "NotImplementedYetError");
    var $ = class extends oe {
      constructor(r, t) {
        super(r, t);
        __publicField(this, "response");
        this.response = t.response;
        let n = this.response.headers.get("prisma-request-id");
        if (n) {
          let i = `(The request id was: ${n})`;
          this.message = this.message + " " + i;
        }
      }
    };
    var pr = class extends $ {
      constructor(r) {
        super("Schema needs to be uploaded", R(r, true));
        __publicField(this, "name", "SchemaMissingError");
        __publicField(this, "code", "P5005");
      }
    };
    x(pr, "SchemaMissingError");
    var mo = "This request could not be understood by the server";
    var Rt = class extends $ {
      constructor(r, t, n) {
        super(t || mo, R(r, false));
        __publicField(this, "name", "BadRequestError");
        __publicField(this, "code", "P5000");
        n && (this.code = n);
      }
    };
    x(Rt, "BadRequestError");
    var At = class extends $ {
      constructor(r, t) {
        super("Engine not started: healthcheck timeout", R(r, true));
        __publicField(this, "name", "HealthcheckTimeoutError");
        __publicField(this, "code", "P5013");
        __publicField(this, "logs");
        this.logs = t;
      }
    };
    x(At, "HealthcheckTimeoutError");
    var Ct = class extends $ {
      constructor(r, t, n) {
        super(t, R(r, true));
        __publicField(this, "name", "EngineStartupError");
        __publicField(this, "code", "P5014");
        __publicField(this, "logs");
        this.logs = n;
      }
    };
    x(Ct, "EngineStartupError");
    var It = class extends $ {
      constructor(r) {
        super("Engine version is not supported", R(r, false));
        __publicField(this, "name", "EngineVersionNotSupportedError");
        __publicField(this, "code", "P5012");
      }
    };
    x(It, "EngineVersionNotSupportedError");
    var fo = "Request timed out";
    var Dt = class extends $ {
      constructor(r, t = fo) {
        super(t, R(r, false));
        __publicField(this, "name", "GatewayTimeoutError");
        __publicField(this, "code", "P5009");
      }
    };
    x(Dt, "GatewayTimeoutError");
    var af = "Interactive transaction error";
    var Ot = class extends $ {
      constructor(r, t = af) {
        super(t, R(r, false));
        __publicField(this, "name", "InteractiveTransactionError");
        __publicField(this, "code", "P5015");
      }
    };
    x(Ot, "InteractiveTransactionError");
    var lf = "Request parameters are invalid";
    var kt = class extends $ {
      constructor(r, t = lf) {
        super(t, R(r, false));
        __publicField(this, "name", "InvalidRequestError");
        __publicField(this, "code", "P5011");
      }
    };
    x(kt, "InvalidRequestError");
    var go = "Requested resource does not exist";
    var _t = class extends $ {
      constructor(r, t = go) {
        super(t, R(r, false));
        __publicField(this, "name", "NotFoundError");
        __publicField(this, "code", "P5003");
      }
    };
    x(_t, "NotFoundError");
    var ho = "Unknown server error";
    var Ur = class extends $ {
      constructor(r, t, n) {
        super(t || ho, R(r, true));
        __publicField(this, "name", "ServerError");
        __publicField(this, "code", "P5006");
        __publicField(this, "logs");
        this.logs = n;
      }
    };
    x(Ur, "ServerError");
    var yo = "Unauthorized, check your connection string";
    var Nt = class extends $ {
      constructor(r, t = yo) {
        super(t, R(r, false));
        __publicField(this, "name", "UnauthorizedError");
        __publicField(this, "code", "P5007");
      }
    };
    x(Nt, "UnauthorizedError");
    var bo = "Usage exceeded, retry again later";
    var Lt = class extends $ {
      constructor(r, t = bo) {
        super(t, R(r, true));
        __publicField(this, "name", "UsageExceededError");
        __publicField(this, "code", "P5008");
      }
    };
    x(Lt, "UsageExceededError");
    async function uf(e) {
      let r;
      try {
        r = await e.text();
      } catch {
        return { type: "EmptyError" };
      }
      try {
        let t = JSON.parse(r);
        if (typeof t == "string") switch (t) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: t };
          default:
            return { type: "UnknownTextError", body: t };
        }
        if (typeof t == "object" && t !== null) {
          if ("is_panic" in t && "message" in t && "error_code" in t) return { type: "QueryEngineError", body: t };
          if ("EngineNotStarted" in t || "InteractiveTransactionMisrouted" in t || "InvalidRequestError" in t) {
            let n = Object.values(t)[0].reason;
            return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: t } : { type: "DataProxyError", body: t };
          }
        }
        return { type: "UnknownJsonError", body: t };
      } catch {
        return r === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: r };
      }
    }
    async function Ft(e, r) {
      if (e.ok) return;
      let t = { clientVersion: r, response: e }, n = await uf(e);
      if (n.type === "QueryEngineError") throw new z(n.body.message, { code: n.body.error_code, clientVersion: r });
      if (n.type === "DataProxyError") {
        if (n.body === "InternalDataProxyError") throw new Ur(t, "Internal Data Proxy error");
        if ("EngineNotStarted" in n.body) {
          if (n.body.EngineNotStarted.reason === "SchemaMissing") return new pr(t);
          if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported") throw new It(t);
          if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
            throw new Ct(t, i, o);
          }
          if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
            throw new P(i, r, o);
          }
          if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
            let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
            throw new At(t, i);
          }
        }
        if ("InteractiveTransactionMisrouted" in n.body) {
          let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
          throw new Ot(t, i[n.body.InteractiveTransactionMisrouted.reason]);
        }
        if ("InvalidRequestError" in n.body) throw new kt(t, n.body.InvalidRequestError.reason);
      }
      if (e.status === 401 || e.status === 403) throw new Nt(t, Gr(yo, n));
      if (e.status === 404) return new _t(t, Gr(go, n));
      if (e.status === 429) throw new Lt(t, Gr(bo, n));
      if (e.status === 504) throw new Dt(t, Gr(fo, n));
      if (e.status >= 500) throw new Ur(t, Gr(ho, n));
      if (e.status >= 400) throw new Rt(t, Gr(mo, n));
    }
    function Gr(e, r) {
      return r.type === "EmptyError" ? e : `${e}: ${JSON.stringify(r)}`;
    }
    function Tl(e) {
      let r = Math.pow(2, e) * 50, t = Math.ceil(Math.random() * r) - Math.ceil(r / 2), n = r + t;
      return new Promise((i) => setTimeout(() => i(n), n));
    }
    var $e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    function Sl(e) {
      let r = new TextEncoder().encode(e), t = "", n = r.byteLength, i = n % 3, o = n - i, s, a, l, u, c;
      for (let p = 0; p < o; p = p + 3) c = r[p] << 16 | r[p + 1] << 8 | r[p + 2], s = (c & 16515072) >> 18, a = (c & 258048) >> 12, l = (c & 4032) >> 6, u = c & 63, t += $e[s] + $e[a] + $e[l] + $e[u];
      return i == 1 ? (c = r[o], s = (c & 252) >> 2, a = (c & 3) << 4, t += $e[s] + $e[a] + "==") : i == 2 && (c = r[o] << 8 | r[o + 1], s = (c & 64512) >> 10, a = (c & 1008) >> 4, l = (c & 15) << 2, t += $e[s] + $e[a] + $e[l] + "="), t;
    }
    function Rl(e) {
      if (!!e.generator?.previewFeatures.some((t) => t.toLowerCase().includes("metrics"))) throw new P("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
    }
    var Al = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
    var Mt = class extends oe {
      constructor(r, t) {
        super(`Cannot fetch data from service:
${r}`, R(t, true));
        __publicField(this, "name", "RequestError");
        __publicField(this, "code", "P5010");
      }
    };
    x(Mt, "RequestError");
    async function dr(e, r, t = (n) => n) {
      let { clientVersion: n, ...i } = r, o = t(fetch);
      try {
        return await o(e, i);
      } catch (s) {
        let a = s.message ?? "Unknown error";
        throw new Mt(a, { clientVersion: n, cause: s });
      }
    }
    var pf = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
    var Cl = N("prisma:client:dataproxyEngine");
    async function df(e, r) {
      let t = Al["@prisma/engines-version"], n = r.clientVersion ?? "unknown";
      if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION) return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION || globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
      if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory") return n;
      let [i, o] = n?.split("-") ?? [];
      if (o === void 0 && pf.test(i)) return i;
      if (o !== void 0 || n === "0.0.0" || n === "in-memory") {
        let [s] = t.split("-") ?? [], [a, l, u] = s.split("."), c = mf(`<=${a}.${l}.${u}`), p = await dr(c, { clientVersion: n });
        if (!p.ok) throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
        let d = await p.text();
        Cl("length of body fetched from unpkg.com", d.length);
        let f;
        try {
          f = JSON.parse(d);
        } catch (h) {
          throw console.error("JSON.parse error: body fetched from unpkg.com: ", d), h;
        }
        return f.version;
      }
      throw new cr("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
    }
    async function Il(e, r) {
      let t = await df(e, r);
      return Cl("version", t), t;
    }
    function mf(e) {
      return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
    }
    var Dl = 3;
    var $t = N("prisma:client:dataproxyEngine");
    var qt = class {
      constructor(r) {
        __publicField(this, "name", "DataProxyEngine");
        __publicField(this, "inlineSchema");
        __publicField(this, "inlineSchemaHash");
        __publicField(this, "inlineDatasources");
        __publicField(this, "config");
        __publicField(this, "logEmitter");
        __publicField(this, "env");
        __publicField(this, "clientVersion");
        __publicField(this, "engineHash");
        __publicField(this, "tracingHelper");
        __publicField(this, "remoteClientVersion");
        __publicField(this, "host");
        __publicField(this, "headerBuilder");
        __publicField(this, "startPromise");
        __publicField(this, "protocol");
        Rl(r), this.config = r, this.env = r.env, this.inlineSchema = Sl(r.inlineSchema), this.inlineDatasources = r.inlineDatasources, this.inlineSchemaHash = r.inlineSchemaHash, this.clientVersion = r.clientVersion, this.engineHash = r.engineVersion, this.logEmitter = r.logEmitter, this.tracingHelper = r.tracingHelper;
      }
      apiKey() {
        return this.headerBuilder.apiKey;
      }
      version() {
        return this.engineHash;
      }
      async start() {
        this.startPromise !== void 0 && await this.startPromise, this.startPromise = (async () => {
          let { apiKey: r, url: t } = this.getURLAndAPIKey();
          this.host = t.host, this.protocol = t.protocol, this.headerBuilder = new Yn({ apiKey: r, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel ?? "error", logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await Il(this.host, this.config), $t("host", this.host), $t("protocol", this.protocol);
        })(), await this.startPromise;
      }
      async stop() {
      }
      propagateResponseExtensions(r) {
        r?.logs?.length && r.logs.forEach((t) => {
          switch (t.level) {
            case "debug":
            case "trace":
              $t(t);
              break;
            case "error":
            case "warn":
            case "info": {
              this.logEmitter.emit(t.level, { timestamp: po(t.timestamp), message: t.attributes.message ?? "", target: t.target ?? "BinaryEngine" });
              break;
            }
            case "query": {
              this.logEmitter.emit("query", { query: t.attributes.query ?? "", timestamp: po(t.timestamp), duration: t.attributes.duration_ms ?? 0, params: t.attributes.params ?? "", target: t.target ?? "BinaryEngine" });
              break;
            }
            default:
              t.level;
          }
        }), r?.traces?.length && this.tracingHelper.dispatchEngineSpans(r.traces);
      }
      onBeforeExit() {
        throw new Error('"beforeExit" hook is not applicable to the remote query engine');
      }
      async url(r) {
        return await this.start(), `${this.protocol}//${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
      }
      async uploadSchema() {
        let r = { name: "schemaUpload", internal: true };
        return this.tracingHelper.runInChildSpan(r, async () => {
          let t = await dr(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
          t.ok || $t("schema response status", t.status);
          let n = await Ft(t, this.clientVersion);
          if (n) throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n.message}`, timestamp: /* @__PURE__ */ new Date(), target: "" }), n;
          this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: /* @__PURE__ */ new Date(), target: "" });
        });
      }
      request(r, { traceparent: t, interactiveTransaction: n, customDataProxyFetch: i }) {
        return this.requestInternal({ body: r, traceparent: t, interactiveTransaction: n, customDataProxyFetch: i });
      }
      async requestBatch(r, { traceparent: t, transaction: n, customDataProxyFetch: i }) {
        let o = n?.kind === "itx" ? n.options : void 0, s = Mr(r, n);
        return (await this.requestInternal({ body: s, customDataProxyFetch: i, interactiveTransaction: o, traceparent: t })).map((l) => (l.extensions && this.propagateResponseExtensions(l.extensions), "errors" in l ? this.convertProtocolErrorsToClientError(l.errors) : l));
      }
      requestInternal({ body: r, traceparent: t, customDataProxyFetch: n, interactiveTransaction: i }) {
        return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o }) => {
          let s = i ? `${i.payload.endpoint}/graphql` : await this.url("graphql");
          o(s);
          let a = await dr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t, transactionId: i?.id }), body: JSON.stringify(r), clientVersion: this.clientVersion }, n);
          a.ok || $t("graphql response status", a.status), await this.handleError(await Ft(a, this.clientVersion));
          let l = await a.json();
          if (l.extensions && this.propagateResponseExtensions(l.extensions), "errors" in l) throw this.convertProtocolErrorsToClientError(l.errors);
          return "batchResult" in l ? l.batchResult : l;
        } });
      }
      async transaction(r, t, n) {
        let i = { start: "starting", commit: "committing", rollback: "rolling back" };
        return this.withRetry({ actionGerund: `${i[r]} transaction`, callback: async ({ logHttpCall: o }) => {
          if (r === "start") {
            let s = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel }), a = await this.url("transaction/start");
            o(a);
            let l = await dr(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: t.traceparent }), body: s, clientVersion: this.clientVersion });
            await this.handleError(await Ft(l, this.clientVersion));
            let u = await l.json(), { extensions: c } = u;
            c && this.propagateResponseExtensions(c);
            let p = u.id, d = u["data-proxy"].endpoint;
            return { id: p, payload: { endpoint: d } };
          } else {
            let s = `${n.payload.endpoint}/${r}`;
            o(s);
            let a = await dr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t.traceparent }), clientVersion: this.clientVersion });
            await this.handleError(await Ft(a, this.clientVersion));
            let l = await a.json(), { extensions: u } = l;
            u && this.propagateResponseExtensions(u);
            return;
          }
        } });
      }
      getURLAndAPIKey() {
        return vl({ clientVersion: this.clientVersion, env: this.env, inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources });
      }
      metrics() {
        throw new cr("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
      }
      async withRetry(r) {
        for (let t = 0; ; t++) {
          let n = (i) => {
            this.logEmitter.emit("info", { message: `Calling ${i} (n=${t})`, timestamp: /* @__PURE__ */ new Date(), target: "" });
          };
          try {
            return await r.callback({ logHttpCall: n });
          } catch (i) {
            if (!(i instanceof oe) || !i.isRetryable) throw i;
            if (t >= Dl) throw i instanceof Br ? i.cause : i;
            this.logEmitter.emit("warn", { message: `Attempt ${t + 1}/${Dl} failed for ${r.actionGerund}: ${i.message ?? "(unknown)"}`, timestamp: /* @__PURE__ */ new Date(), target: "" });
            let o = await Tl(t);
            this.logEmitter.emit("warn", { message: `Retrying after ${o}ms`, timestamp: /* @__PURE__ */ new Date(), target: "" });
          }
        }
      }
      async handleError(r) {
        if (r instanceof pr) throw await this.uploadSchema(), new Br({ clientVersion: this.clientVersion, cause: r });
        if (r) throw r;
      }
      convertProtocolErrorsToClientError(r) {
        return r.length === 1 ? $r(r[0], this.config.clientVersion, this.config.activeProvider) : new V(JSON.stringify(r), { clientVersion: this.config.clientVersion });
      }
      applyPendingMigrations() {
        throw new Error("Method not implemented.");
      }
    };
    function Ol(e) {
      if (e?.kind === "itx") return e.options.id;
    }
    var wo = O(require("os"));
    var kl = O(require("path"));
    var Eo = Symbol("PrismaLibraryEngineCache");
    function ff() {
      let e = globalThis;
      return e[Eo] === void 0 && (e[Eo] = {}), e[Eo];
    }
    function gf(e) {
      let r = ff();
      if (r[e] !== void 0) return r[e];
      let t = kl.default.toNamespacedPath(e), n = { exports: {} }, i = 0;
      return process.platform !== "win32" && (i = wo.default.constants.dlopen.RTLD_LAZY | wo.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, t, i), r[e] = n.exports, n.exports;
    }
    var _l = { async loadLibrary(e) {
      let r = await fi(), t = await ml("library", e);
      try {
        return e.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => gf(t));
      } catch (n) {
        let i = Ai({ e: n, platformInfo: r, id: t });
        throw new P(i, e.clientVersion);
      }
    } };
    var xo;
    var Nl = { async loadLibrary(e) {
      let { clientVersion: r, adapter: t, engineWasm: n } = e;
      if (t === void 0) throw new P(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Kn().prettyName})`, r);
      if (n === void 0) throw new P("WASM engine was unexpectedly `undefined`", r);
      xo === void 0 && (xo = (async () => {
        let o = await n.getRuntime(), s = await n.getQueryEngineWasmModule();
        if (s == null) throw new P("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", r);
        let a = { "./query_engine_bg.js": o }, l = new WebAssembly.Instance(s, a), u = l.exports.__wbindgen_start;
        return o.__wbg_set_wasm(l.exports), u(), o.QueryEngine;
      })());
      let i = await xo;
      return { debugPanic() {
        return Promise.reject("{}");
      }, dmmf() {
        return Promise.resolve("{}");
      }, version() {
        return { commit: "unknown", version: "unknown" };
      }, QueryEngine: i };
    } };
    var hf = "P2036";
    var Re = N("prisma:client:libraryEngine");
    function yf(e) {
      return e.item_type === "query" && "query" in e;
    }
    function bf(e) {
      return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
    }
    var Ll = [...li, "native"];
    var Ef = 0xffffffffffffffffn;
    var vo = 1n;
    function wf() {
      let e = vo++;
      return vo > Ef && (vo = 1n), e;
    }
    var Qr = class {
      constructor(r, t) {
        __publicField(this, "name", "LibraryEngine");
        __publicField(this, "engine");
        __publicField(this, "libraryInstantiationPromise");
        __publicField(this, "libraryStartingPromise");
        __publicField(this, "libraryStoppingPromise");
        __publicField(this, "libraryStarted");
        __publicField(this, "executingQueryPromise");
        __publicField(this, "config");
        __publicField(this, "QueryEngineConstructor");
        __publicField(this, "libraryLoader");
        __publicField(this, "library");
        __publicField(this, "logEmitter");
        __publicField(this, "libQueryEnginePath");
        __publicField(this, "binaryTarget");
        __publicField(this, "datasourceOverrides");
        __publicField(this, "datamodel");
        __publicField(this, "logQueries");
        __publicField(this, "logLevel");
        __publicField(this, "lastQuery");
        __publicField(this, "loggerRustPanic");
        __publicField(this, "tracingHelper");
        __publicField(this, "adapterPromise");
        __publicField(this, "versionInfo");
        this.libraryLoader = t ?? _l, r.engineWasm !== void 0 && (this.libraryLoader = t ?? Nl), this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.logEmitter = r.logEmitter, this.datamodel = r.inlineSchema, this.tracingHelper = r.tracingHelper, r.enableDebugLogs && (this.logLevel = "debug");
        let n = Object.keys(r.overrideDatasources)[0], i = r.overrideDatasources[n]?.url;
        n !== void 0 && i !== void 0 && (this.datasourceOverrides = { [n]: i }), this.libraryInstantiationPromise = this.instantiateLibrary();
      }
      wrapEngine(r) {
        return { applyPendingMigrations: r.applyPendingMigrations?.bind(r), commitTransaction: this.withRequestId(r.commitTransaction.bind(r)), connect: this.withRequestId(r.connect.bind(r)), disconnect: this.withRequestId(r.disconnect.bind(r)), metrics: r.metrics?.bind(r), query: this.withRequestId(r.query.bind(r)), rollbackTransaction: this.withRequestId(r.rollbackTransaction.bind(r)), sdlSchema: r.sdlSchema?.bind(r), startTransaction: this.withRequestId(r.startTransaction.bind(r)), trace: r.trace.bind(r), free: r.free?.bind(r) };
      }
      withRequestId(r) {
        return async (...t) => {
          let n = wf().toString();
          try {
            return await r(...t, n);
          } finally {
            if (this.tracingHelper.isEnabled()) {
              let i = await this.engine?.trace(n);
              if (i) {
                let o = JSON.parse(i);
                this.tracingHelper.dispatchEngineSpans(o.spans);
              }
            }
          }
        };
      }
      async applyPendingMigrations() {
        throw new Error("Cannot call this method from this type of engine instance");
      }
      async transaction(r, t, n) {
        await this.start();
        let i = await this.adapterPromise, o = JSON.stringify(t), s;
        if (r === "start") {
          let l = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel });
          s = await this.engine?.startTransaction(l, o);
        } else r === "commit" ? s = await this.engine?.commitTransaction(n.id, o) : r === "rollback" && (s = await this.engine?.rollbackTransaction(n.id, o));
        let a = this.parseEngineResponse(s);
        if (xf(a)) {
          let l = this.getExternalAdapterError(a, i?.errorRegistry);
          throw l ? l.error : new z(a.message, { code: a.error_code, clientVersion: this.config.clientVersion, meta: a.meta });
        } else if (typeof a.message == "string") throw new V(a.message, { clientVersion: this.config.clientVersion });
        return a;
      }
      async instantiateLibrary() {
        if (Re("internalSetup"), this.libraryInstantiationPromise) return this.libraryInstantiationPromise;
        ai(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.tracingHelper.runInChildSpan("load_engine", () => this.loadEngine()), this.version();
      }
      async getCurrentBinaryTarget() {
        {
          if (this.binaryTarget) return this.binaryTarget;
          let r = await this.tracingHelper.runInChildSpan("detect_platform", () => ir());
          if (!Ll.includes(r)) throw new P(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r))}. Possible binaryTargets: ${qe(Ll.join(", "))} or a path to the query engine library.
You may have to run ${qe("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
          return r;
        }
      }
      parseEngineResponse(r) {
        if (!r) throw new V("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
        try {
          return JSON.parse(r);
        } catch {
          throw new V("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
        }
      }
      async loadEngine() {
        if (!this.engine) {
          this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
          try {
            let r = new WeakRef(this);
            this.adapterPromise || (this.adapterPromise = this.config.adapter?.connect()?.then(tn));
            let t = await this.adapterPromise;
            t && Re("Using driver adapter: %O", t), this.engine = this.wrapEngine(new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json", enableTracing: this.tracingHelper.isEnabled() }, (n) => {
              r.deref()?.logger(n);
            }, t));
          } catch (r) {
            let t = r, n = this.parseInitError(t.message);
            throw typeof n == "string" ? t : new P(n.message, this.config.clientVersion, n.error_code);
          }
        }
      }
      logger(r) {
        let t = this.parseEngineResponse(r);
        t && (t.level = t?.level.toLowerCase() ?? "unknown", yf(t) ? this.logEmitter.emit("query", { timestamp: /* @__PURE__ */ new Date(), query: t.query, params: t.params, duration: Number(t.duration_ms), target: t.module_path }) : bf(t) ? this.loggerRustPanic = new ae(Po(this, `${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`), this.config.clientVersion) : this.logEmitter.emit(t.level, { timestamp: /* @__PURE__ */ new Date(), message: t.message, target: t.module_path }));
      }
      parseInitError(r) {
        try {
          return JSON.parse(r);
        } catch {
        }
        return r;
      }
      parseRequestError(r) {
        try {
          return JSON.parse(r);
        } catch {
        }
        return r;
      }
      onBeforeExit() {
        throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
      }
      async start() {
        if (this.libraryInstantiationPromise || (this.libraryInstantiationPromise = this.instantiateLibrary()), await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise) return Re(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
        if (this.libraryStarted) return;
        let r = async () => {
          Re("library starting");
          try {
            let t = { traceparent: this.tracingHelper.getTraceParent() };
            await this.engine?.connect(JSON.stringify(t)), this.libraryStarted = true, this.adapterPromise || (this.adapterPromise = this.config.adapter?.connect()?.then(tn)), await this.adapterPromise, Re("library started");
          } catch (t) {
            let n = this.parseInitError(t.message);
            throw typeof n == "string" ? t : new P(n.message, this.config.clientVersion, n.error_code);
          } finally {
            this.libraryStartingPromise = void 0;
          }
        };
        return this.libraryStartingPromise = this.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
      }
      async stop() {
        if (await this.libraryInstantiationPromise, await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise) return Re("library is already stopping"), this.libraryStoppingPromise;
        if (!this.libraryStarted) {
          await (await this.adapterPromise)?.dispose(), this.adapterPromise = void 0;
          return;
        }
        let r = async () => {
          await new Promise((n) => setImmediate(n)), Re("library stopping");
          let t = { traceparent: this.tracingHelper.getTraceParent() };
          await this.engine?.disconnect(JSON.stringify(t)), this.engine?.free && this.engine.free(), this.engine = void 0, this.libraryStarted = false, this.libraryStoppingPromise = void 0, this.libraryInstantiationPromise = void 0, await (await this.adapterPromise)?.dispose(), this.adapterPromise = void 0, Re("library stopped");
        };
        return this.libraryStoppingPromise = this.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
      }
      version() {
        return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
      }
      debugPanic(r) {
        return this.library?.debugPanic(r);
      }
      async request(r, { traceparent: t, interactiveTransaction: n }) {
        Re(`sending request, this.libraryStarted: ${this.libraryStarted}`);
        let i = JSON.stringify({ traceparent: t }), o = JSON.stringify(r);
        try {
          await this.start();
          let s = await this.adapterPromise;
          this.executingQueryPromise = this.engine?.query(o, i, n?.id), this.lastQuery = o;
          let a = this.parseEngineResponse(await this.executingQueryPromise);
          if (a.errors) throw a.errors.length === 1 ? this.buildQueryError(a.errors[0], s?.errorRegistry) : new V(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
          if (this.loggerRustPanic) throw this.loggerRustPanic;
          return { data: a };
        } catch (s) {
          if (s instanceof P) throw s;
          if (s.code === "GenericFailure" && s.message?.startsWith("PANIC:")) throw new ae(Po(this, s.message), this.config.clientVersion);
          let a = this.parseRequestError(s.message);
          throw typeof a == "string" ? s : new V(`${a.message}
${a.backtrace}`, { clientVersion: this.config.clientVersion });
        }
      }
      async requestBatch(r, { transaction: t, traceparent: n }) {
        Re("requestBatch");
        let i = Mr(r, t);
        await this.start();
        let o = await this.adapterPromise;
        this.lastQuery = JSON.stringify(i), this.executingQueryPromise = this.engine?.query(this.lastQuery, JSON.stringify({ traceparent: n }), Ol(t));
        let s = await this.executingQueryPromise, a = this.parseEngineResponse(s);
        if (a.errors) throw a.errors.length === 1 ? this.buildQueryError(a.errors[0], o?.errorRegistry) : new V(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
        let { batchResult: l, errors: u } = a;
        if (Array.isArray(l)) return l.map((c) => c.errors && c.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(c.errors[0], o?.errorRegistry) : { data: c });
        throw u && u.length === 1 ? new Error(u[0].error) : new Error(JSON.stringify(a));
      }
      buildQueryError(r, t) {
        if (r.user_facing_error.is_panic) return new ae(Po(this, r.user_facing_error.message), this.config.clientVersion);
        let n = this.getExternalAdapterError(r.user_facing_error, t);
        return n ? n.error : $r(r, this.config.clientVersion, this.config.activeProvider);
      }
      getExternalAdapterError(r, t) {
        if (r.error_code === hf && t) {
          let n = r.meta?.id;
          ln(typeof n == "number", "Malformed external JS error received from the engine");
          let i = t.consumeError(n);
          return ln(i, "External error with reported id was not registered"), i;
        }
      }
      async metrics(r) {
        await this.start();
        let t = await this.engine.metrics(JSON.stringify(r));
        return r.format === "prometheus" ? t : this.parseEngineResponse(t);
      }
    };
    function xf(e) {
      return typeof e == "object" && e !== null && e.error_code !== void 0;
    }
    function Po(e, r) {
      return El({ binaryTarget: e.binaryTarget, title: r, version: e.config.clientVersion, engineVersion: e.versionInfo?.commit, database: e.config.activeProvider, query: e.lastQuery });
    }
    function Fl({ url: e, adapter: r, copyEngine: t, targetBuildType: n }) {
      let i = [], o = [], s = (g) => {
        i.push({ _tag: "warning", value: g });
      }, a = (g) => {
        let I = g.join(`
`);
        o.push({ _tag: "error", value: I });
      }, l = !!e?.startsWith("prisma://"), u = an(e), c = !!r, p = l || u;
      !c && t && p && n !== "client" && n !== "wasm-compiler-edge" && s(["recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);
      let d = p || !t;
      c && (d || n === "edge") && (n === "edge" ? a(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.", "Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]) : p ? a(["You've provided both a driver adapter and an Accelerate database URL. Driver adapters currently cannot connect to Accelerate.", "Please provide either a driver adapter with a direct database URL or an Accelerate URL and no driver adapter."]) : t || a(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));
      let f = { accelerate: d, ppg: u, driverAdapters: c };
      function h(g) {
        return g.length > 0;
      }
      return h(o) ? { ok: false, diagnostics: { warnings: i, errors: o }, isUsing: f } : { ok: true, diagnostics: { warnings: i }, isUsing: f };
    }
    function Ml({ copyEngine: e = true }, r) {
      let t;
      try {
        t = jr({ inlineDatasources: r.inlineDatasources, overrideDatasources: r.overrideDatasources, env: { ...r.env, ...process.env }, clientVersion: r.clientVersion });
      } catch {
      }
      let { ok: n, isUsing: i, diagnostics: o } = Fl({ url: t, adapter: r.adapter, copyEngine: e, targetBuildType: "library" });
      for (let p of o.warnings) at(...p.value);
      if (!n) {
        let p = o.errors[0];
        throw new Z(p.value, { clientVersion: r.clientVersion });
      }
      let s = Er(r.generator), a = s === "library", l = s === "binary", u = s === "client", c = (i.accelerate || i.ppg) && !i.driverAdapters;
      return i.accelerate ? new qt(r) : (i.driverAdapters, a ? new Qr(r) : (i.accelerate, new Qr(r)));
    }
    function $l({ generator: e }) {
      return e?.previewFeatures ?? [];
    }
    var ql = (e) => ({ command: e });
    var Vl = (e) => e.strings.reduce((r, t, n) => `${r}@P${n}${t}`);
    function Wr(e) {
      try {
        return jl(e, "fast");
      } catch {
        return jl(e, "slow");
      }
    }
    function jl(e, r) {
      return JSON.stringify(e.map((t) => Ul(t, r)));
    }
    function Ul(e, r) {
      if (Array.isArray(e)) return e.map((t) => Ul(t, r));
      if (typeof e == "bigint") return { prisma__type: "bigint", prisma__value: e.toString() };
      if (vr(e)) return { prisma__type: "date", prisma__value: e.toJSON() };
      if (Fe.isDecimal(e)) return { prisma__type: "decimal", prisma__value: e.toJSON() };
      if (Buffer.isBuffer(e)) return { prisma__type: "bytes", prisma__value: e.toString("base64") };
      if (vf(e)) return { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") };
      if (ArrayBuffer.isView(e)) {
        let { buffer: t, byteOffset: n, byteLength: i } = e;
        return { prisma__type: "bytes", prisma__value: Buffer.from(t, n, i).toString("base64") };
      }
      return typeof e == "object" && r === "slow" ? Gl(e) : e;
    }
    function vf(e) {
      return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
    }
    function Gl(e) {
      if (typeof e != "object" || e === null) return e;
      if (typeof e.toJSON == "function") return e.toJSON();
      if (Array.isArray(e)) return e.map(Bl);
      let r = {};
      for (let t of Object.keys(e)) r[t] = Bl(e[t]);
      return r;
    }
    function Bl(e) {
      return typeof e == "bigint" ? e.toString() : Gl(e);
    }
    var Pf = /^(\s*alter\s)/i;
    var Ql = N("prisma:client");
    function To(e, r, t, n) {
      if (!(e !== "postgresql" && e !== "cockroachdb") && t.length > 0 && Pf.exec(r)) throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    var So = ({ clientMethod: e, activeProvider: r }) => (t) => {
      let n = "", i;
      if (Vn(t)) n = t.sql, i = { values: Wr(t.values), __prismaRawParameters__: true };
      else if (Array.isArray(t)) {
        let [o, ...s] = t;
        n = o, i = { values: Wr(s || []), __prismaRawParameters__: true };
      } else switch (r) {
        case "sqlite":
        case "mysql": {
          n = t.sql, i = { values: Wr(t.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n = t.text, i = { values: Wr(t.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n = Vl(t), i = { values: Wr(t.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${r} provider does not support ${e}`);
      }
      return i?.values ? Ql(`prisma.${e}(${n}, ${i.values})`) : Ql(`prisma.${e}(${n})`), { query: n, parameters: i };
    };
    var Wl = { requestArgsToMiddlewareArgs(e) {
      return [e.strings, ...e.values];
    }, middlewareArgsToRequestArgs(e) {
      let [r, ...t] = e;
      return new ie(r, t);
    } };
    var Jl = { requestArgsToMiddlewareArgs(e) {
      return [e];
    }, middlewareArgsToRequestArgs(e) {
      return e[0];
    } };
    function Ro(e) {
      return function(t, n) {
        let i, o = (s = e) => {
          try {
            return s === void 0 || s?.kind === "itx" ? i ?? (i = Kl(t(s))) : Kl(t(s));
          } catch (a) {
            return Promise.reject(a);
          }
        };
        return { get spec() {
          return n;
        }, then(s, a) {
          return o().then(s, a);
        }, catch(s) {
          return o().catch(s);
        }, finally(s) {
          return o().finally(s);
        }, requestTransaction(s) {
          let a = o(s);
          return a.requestTransaction ? a.requestTransaction(s) : a;
        }, [Symbol.toStringTag]: "PrismaPromise" };
      };
    }
    function Kl(e) {
      return typeof e.then == "function" ? e : Promise.resolve(e);
    }
    var Tf = xi.split(".")[0];
    var Sf = { isEnabled() {
      return false;
    }, getTraceParent() {
      return "00-10-10-00";
    }, dispatchEngineSpans() {
    }, getActiveContext() {
    }, runInChildSpan(e, r) {
      return r();
    } };
    var Ao = class {
      isEnabled() {
        return this.getGlobalTracingHelper().isEnabled();
      }
      getTraceParent(r) {
        return this.getGlobalTracingHelper().getTraceParent(r);
      }
      dispatchEngineSpans(r) {
        return this.getGlobalTracingHelper().dispatchEngineSpans(r);
      }
      getActiveContext() {
        return this.getGlobalTracingHelper().getActiveContext();
      }
      runInChildSpan(r, t) {
        return this.getGlobalTracingHelper().runInChildSpan(r, t);
      }
      getGlobalTracingHelper() {
        let r = globalThis[`V${Tf}_PRISMA_INSTRUMENTATION`], t = globalThis.PRISMA_INSTRUMENTATION;
        return r?.helper ?? t?.helper ?? Sf;
      }
    };
    function Hl() {
      return new Ao();
    }
    function Yl(e, r = () => {
    }) {
      let t, n = new Promise((i) => t = i);
      return { then(i) {
        return --e === 0 && t(r()), i?.(n);
      } };
    }
    function zl(e) {
      return typeof e == "string" ? e : e.reduce((r, t) => {
        let n = typeof t == "string" ? t : t.level;
        return n === "query" ? r : r && (t === "info" || r === "info") ? "info" : n;
      }, void 0);
    }
    function zn(e) {
      return typeof e.batchRequestIdx == "number";
    }
    function Zl(e) {
      if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow") return;
      let r = [];
      return e.modelName && r.push(e.modelName), e.query.arguments && r.push(Co(e.query.arguments)), r.push(Co(e.query.selection)), r.join("");
    }
    function Co(e) {
      return `(${Object.keys(e).sort().map((t) => {
        let n = e[t];
        return typeof n == "object" && n !== null ? `(${t} ${Co(n)})` : t;
      }).join(" ")})`;
    }
    var Rf = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateManyAndReturn: true, updateOne: true, upsertOne: true };
    function Io(e) {
      return Rf[e];
    }
    var Zn = class {
      constructor(r) {
        __publicField(this, "batches");
        __publicField(this, "tickActive", false);
        this.options = r;
        this.batches = {};
      }
      request(r) {
        let t = this.options.batchBy(r);
        return t ? (this.batches[t] || (this.batches[t] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((n, i) => {
          this.batches[t].push({ request: r, resolve: n, reject: i });
        })) : this.options.singleLoader(r);
      }
      dispatchBatches() {
        for (let r in this.batches) {
          let t = this.batches[r];
          delete this.batches[r], t.length === 1 ? this.options.singleLoader(t[0].request).then((n) => {
            n instanceof Error ? t[0].reject(n) : t[0].resolve(n);
          }).catch((n) => {
            t[0].reject(n);
          }) : (t.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(t.map((n) => n.request)).then((n) => {
            if (n instanceof Error) for (let i = 0; i < t.length; i++) t[i].reject(n);
            else for (let i = 0; i < t.length; i++) {
              let o = n[i];
              o instanceof Error ? t[i].reject(o) : t[i].resolve(o);
            }
          }).catch((n) => {
            for (let i = 0; i < t.length; i++) t[i].reject(n);
          }));
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    function mr(e, r) {
      if (r === null) return r;
      switch (e) {
        case "bigint":
          return BigInt(r);
        case "bytes": {
          let { buffer: t, byteOffset: n, byteLength: i } = Buffer.from(r, "base64");
          return new Uint8Array(t, n, i);
        }
        case "decimal":
          return new Fe(r);
        case "datetime":
        case "date":
          return new Date(r);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${r}Z`);
        case "bigint-array":
          return r.map((t) => mr("bigint", t));
        case "bytes-array":
          return r.map((t) => mr("bytes", t));
        case "decimal-array":
          return r.map((t) => mr("decimal", t));
        case "datetime-array":
          return r.map((t) => mr("datetime", t));
        case "date-array":
          return r.map((t) => mr("date", t));
        case "time-array":
          return r.map((t) => mr("time", t));
        default:
          return r;
      }
    }
    function Xn(e) {
      let r = [], t = Af(e);
      for (let n = 0; n < e.rows.length; n++) {
        let i = e.rows[n], o = { ...t };
        for (let s = 0; s < i.length; s++) o[e.columns[s]] = mr(e.types[s], i[s]);
        r.push(o);
      }
      return r;
    }
    function Af(e) {
      let r = {};
      for (let t = 0; t < e.columns.length; t++) r[e.columns[t]] = null;
      return r;
    }
    var Cf = N("prisma:client:request_handler");
    var ei = class {
      constructor(r, t) {
        __publicField(this, "client");
        __publicField(this, "dataloader");
        __publicField(this, "logEmitter");
        this.logEmitter = t, this.client = r, this.dataloader = new Zn({ batchLoader: rl(async ({ requests: n, customDataProxyFetch: i }) => {
          let { transaction: o, otelParentCtx: s } = n[0], a = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => Io(p.protocolQuery.action));
          return (await this.client._engine.requestBatch(a, { traceparent: l, transaction: If(o), containsWrite: u, customDataProxyFetch: i })).map((p, d) => {
            if (p instanceof Error) return p;
            try {
              return this.mapQueryEngineResult(n[d], p);
            } catch (f) {
              return f;
            }
          });
        }), singleLoader: async (n) => {
          let i = n.transaction?.kind === "itx" ? Xl(n.transaction) : void 0, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Io(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
          return this.mapQueryEngineResult(n, o);
        }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : Zl(n.protocolQuery), batchOrder(n, i) {
          return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
        } });
      }
      async request(r) {
        try {
          return await this.dataloader.request(r);
        } catch (t) {
          let { clientMethod: n, callsite: i, transaction: o, args: s, modelName: a } = r;
          this.handleAndLogRequestError({ error: t, clientMethod: n, callsite: i, transaction: o, args: s, modelName: a, globalOmit: r.globalOmit });
        }
      }
      mapQueryEngineResult({ dataPath: r, unpacker: t }, n) {
        let i = n?.data, o = this.unpack(i, r, t);
        return process.env.PRISMA_CLIENT_GET_TIME ? { data: o } : o;
      }
      handleAndLogRequestError(r) {
        try {
          this.handleRequestError(r);
        } catch (t) {
          throw this.logEmitter && this.logEmitter.emit("error", { message: t.message, target: r.clientMethod, timestamp: /* @__PURE__ */ new Date() }), t;
        }
      }
      handleRequestError({ error: r, clientMethod: t, callsite: n, transaction: i, args: o, modelName: s, globalOmit: a }) {
        if (Cf(r), Df(r, i)) throw r;
        if (r instanceof z && Of(r)) {
          let u = eu(r.meta);
          Nn({ args: o, errors: [u], callsite: n, errorFormat: this.client._errorFormat, originalMethod: t, clientVersion: this.client._clientVersion, globalOmit: a });
        }
        let l = r.message;
        if (n && (l = Tn({ callsite: n, originalMethod: t, isPanic: r.isPanic, showColors: this.client._errorFormat === "pretty", message: l })), l = this.sanitizeMessage(l), r.code) {
          let u = s ? { modelName: s, ...r.meta } : r.meta;
          throw new z(l, { code: r.code, clientVersion: this.client._clientVersion, meta: u, batchRequestIdx: r.batchRequestIdx });
        } else {
          if (r.isPanic) throw new ae(l, this.client._clientVersion);
          if (r instanceof V) throw new V(l, { clientVersion: this.client._clientVersion, batchRequestIdx: r.batchRequestIdx });
          if (r instanceof P) throw new P(l, this.client._clientVersion);
          if (r instanceof ae) throw new ae(l, this.client._clientVersion);
        }
        throw r.clientVersion = this.client._clientVersion, r;
      }
      sanitizeMessage(r) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? wr(r) : r;
      }
      unpack(r, t, n) {
        if (!r || (r.data && (r = r.data), !r)) return r;
        let i = Object.keys(r)[0], o = Object.values(r)[0], s = t.filter((u) => u !== "select" && u !== "include"), a = ao(o, s), l = i === "queryRaw" ? Xn(a) : Vr(a);
        return n ? n(l) : l;
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    function If(e) {
      if (e) {
        if (e.kind === "batch") return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
        if (e.kind === "itx") return { kind: "itx", options: Xl(e) };
        ar(e, "Unknown transaction kind");
      }
    }
    function Xl(e) {
      return { id: e.id, payload: e.payload };
    }
    function Df(e, r) {
      return zn(e) && r?.kind === "batch" && e.batchRequestIdx !== r.index;
    }
    function Of(e) {
      return e.code === "P2009" || e.code === "P2012";
    }
    function eu(e) {
      if (e.kind === "Union") return { kind: "Union", errors: e.errors.map(eu) };
      if (Array.isArray(e.selectionPath)) {
        let [, ...r] = e.selectionPath;
        return { ...e, selectionPath: r };
      }
      return e;
    }
    var ru = xl;
    var su = O(Ki());
    var _ = class extends Error {
      constructor(r) {
        super(r + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    x(_, "PrismaClientConstructorValidationError");
    var tu = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "omit", "__internal"];
    var nu = ["pretty", "colorless", "minimal"];
    var iu = ["info", "query", "warn", "error"];
    var kf = { datasources: (e, { datasourceNames: r }) => {
      if (e) {
        if (typeof e != "object" || Array.isArray(e)) throw new _(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
        for (let [t, n] of Object.entries(e)) {
          if (!r.includes(t)) {
            let i = Jr(t, r) || ` Available datasources: ${r.join(", ")}`;
            throw new _(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`);
          }
          if (typeof n != "object" || Array.isArray(n)) throw new _(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          if (n && typeof n == "object") for (let [i, o] of Object.entries(n)) {
            if (i !== "url") throw new _(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o != "string") throw new _(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
        }
      }
    }, adapter: (e, r) => {
      if (!e && Er(r.generator) === "client") throw new _('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');
      if (e !== null) {
        if (e === void 0) throw new _('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
        if (Er(r.generator) === "binary") throw new _('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
      }
    }, datasourceUrl: (e) => {
      if (typeof e < "u" && typeof e != "string") throw new _(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
    }, errorFormat: (e) => {
      if (e) {
        if (typeof e != "string") throw new _(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!nu.includes(e)) {
          let r = Jr(e, nu);
          throw new _(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`);
        }
      }
    }, log: (e) => {
      if (!e) return;
      if (!Array.isArray(e)) throw new _(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
      function r(t) {
        if (typeof t == "string" && !iu.includes(t)) {
          let n = Jr(t, iu);
          throw new _(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`);
        }
      }
      for (let t of e) {
        r(t);
        let n = { level: r, emit: (i) => {
          let o = ["stdout", "event"];
          if (!o.includes(i)) {
            let s = Jr(i, o);
            throw new _(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
          }
        } };
        if (t && typeof t == "object") for (let [i, o] of Object.entries(t)) if (n[i]) n[i](o);
        else throw new _(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
      }
    }, transactionOptions: (e) => {
      if (!e) return;
      let r = e.maxWait;
      if (r != null && r <= 0) throw new _(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
      let t = e.timeout;
      if (t != null && t <= 0) throw new _(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
    }, omit: (e, r) => {
      if (typeof e != "object") throw new _('"omit" option is expected to be an object.');
      if (e === null) throw new _('"omit" option can not be `null`');
      let t = [];
      for (let [n, i] of Object.entries(e)) {
        let o = Nf(n, r.runtimeDataModel);
        if (!o) {
          t.push({ kind: "UnknownModel", modelKey: n });
          continue;
        }
        for (let [s, a] of Object.entries(i)) {
          let l = o.fields.find((u) => u.name === s);
          if (!l) {
            t.push({ kind: "UnknownField", modelKey: n, fieldName: s });
            continue;
          }
          if (l.relationName) {
            t.push({ kind: "RelationInOmit", modelKey: n, fieldName: s });
            continue;
          }
          typeof a != "boolean" && t.push({ kind: "InvalidFieldValue", modelKey: n, fieldName: s });
        }
      }
      if (t.length > 0) throw new _(Lf(e, t));
    }, __internal: (e) => {
      if (!e) return;
      let r = ["debug", "engine", "configOverride"];
      if (typeof e != "object") throw new _(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
      for (let [t] of Object.entries(e)) if (!r.includes(t)) {
        let n = Jr(t, r);
        throw new _(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
    } };
    function au(e, r) {
      for (let [t, n] of Object.entries(e)) {
        if (!tu.includes(t)) {
          let i = Jr(t, tu);
          throw new _(`Unknown property ${t} provided to PrismaClient constructor.${i}`);
        }
        kf[t](n, r);
      }
      if (e.datasourceUrl && e.datasources) throw new _('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
    }
    function Jr(e, r) {
      if (r.length === 0 || typeof e != "string") return "";
      let t = _f(e, r);
      return t ? ` Did you mean "${t}"?` : "";
    }
    function _f(e, r) {
      if (r.length === 0) return null;
      let t = r.map((i) => ({ value: i, distance: (0, su.default)(e, i) }));
      t.sort((i, o) => i.distance < o.distance ? -1 : 1);
      let n = t[0];
      return n.distance < 3 ? n.value : null;
    }
    function Nf(e, r) {
      return ou(r.models, e) ?? ou(r.types, e);
    }
    function ou(e, r) {
      let t = Object.keys(e).find((n) => We(n) === r);
      if (t) return e[t];
    }
    function Lf(e, r) {
      let t = _r(e);
      for (let o of r) switch (o.kind) {
        case "UnknownModel":
          t.arguments.getField(o.modelKey)?.markAsError(), t.addErrorMessage(() => `Unknown model name: ${o.modelKey}.`);
          break;
        case "UnknownField":
          t.arguments.getDeepField([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => `Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);
          break;
        case "RelationInOmit":
          t.arguments.getDeepField([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
          break;
        case "InvalidFieldValue":
          t.arguments.getDeepFieldValue([o.modelKey, o.fieldName])?.markAsError(), t.addErrorMessage(() => "Omit field option value must be a boolean.");
          break;
      }
      let { message: n, args: i } = _n(t, "colorless");
      return `Error validating "omit" option:

${i}

${n}`;
    }
    function lu(e) {
      return e.length === 0 ? Promise.resolve([]) : new Promise((r, t) => {
        let n = new Array(e.length), i = null, o = false, s = 0, a = () => {
          o || (s++, s === e.length && (o = true, i ? t(i) : r(n)));
        }, l = (u) => {
          o || (o = true, t(u));
        };
        for (let u = 0; u < e.length; u++) e[u].then((c) => {
          n[u] = c, a();
        }, (c) => {
          if (!zn(c)) {
            l(c);
            return;
          }
          c.batchRequestIdx === u ? l(c) : (i || (i = c), a());
        });
      });
    }
    var rr = N("prisma:client");
    typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
    var Ff = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
    var Mf = Symbol.for("prisma.client.transaction.id");
    var $f = { id: 0, nextId() {
      return ++this.id;
    } };
    function fu(e) {
      class r {
        constructor(n) {
          __publicField(this, "_originalClient", this);
          __publicField(this, "_runtimeDataModel");
          __publicField(this, "_requestHandler");
          __publicField(this, "_connectionPromise");
          __publicField(this, "_disconnectionPromise");
          __publicField(this, "_engineConfig");
          __publicField(this, "_accelerateEngineConfig");
          __publicField(this, "_clientVersion");
          __publicField(this, "_errorFormat");
          __publicField(this, "_tracingHelper");
          __publicField(this, "_previewFeatures");
          __publicField(this, "_activeProvider");
          __publicField(this, "_globalOmit");
          __publicField(this, "_extensions");
          __publicField(this, "_engine");
          __publicField(this, "_appliedParent");
          __publicField(this, "_createPrismaPromise", Ro());
          __publicField(this, "$metrics", new Lr(this));
          __publicField(this, "$extends", Wa);
          e = n?.__internal?.configOverride?.(e) ?? e, sl(e), n && au(n, e);
          let i = new du.EventEmitter().on("error", () => {
          });
          this._extensions = Nr.empty(), this._previewFeatures = $l(e), this._clientVersion = e.clientVersion ?? ru, this._activeProvider = e.activeProvider, this._globalOmit = n?.omit, this._tracingHelper = Hl();
          let o = e.relativeEnvPaths && { rootEnvPath: e.relativeEnvPaths.rootEnvPath && ri.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && ri.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, s;
          if (n?.adapter) {
            s = n.adapter;
            let l = e.activeProvider === "postgresql" || e.activeProvider === "cockroachdb" ? "postgres" : e.activeProvider;
            if (s.provider !== l) throw new P(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`, this._clientVersion);
            if (n.datasources || n.datasourceUrl !== void 0) throw new P("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.", this._clientVersion);
          }
          let a = !s && o && st(o, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
          try {
            let l = n ?? {}, u = l.__internal ?? {}, c = u.debug === true;
            c && N.enable("prisma:client");
            let p = ri.default.resolve(e.dirname, e.relativePath);
            mu.default.existsSync(p) || (p = e.dirname), rr("dirname", e.dirname), rr("relativePath", e.relativePath), rr("cwd", p);
            let d = u.engine || {};
            if (l.errorFormat ? this._errorFormat = l.errorFormat : process.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e.dirname, enableDebugLogs: c, allowTriggerPanic: d.allowTriggerPanic, prismaPath: d.binaryPath ?? void 0, engineEndpoint: d.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: l.log && zl(l.log), logQueries: l.log && !!(typeof l.log == "string" ? l.log === "query" : l.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a?.parsed ?? {}, flags: [], engineWasm: e.engineWasm, compilerWasm: e.compilerWasm, clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: al(l, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: l.transactionOptions?.maxWait ?? 2e3, timeout: l.transactionOptions?.timeout ?? 5e3, isolationLevel: l.transactionOptions?.isolationLevel }, logEmitter: i, isBundled: e.isBundled, adapter: s }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: jr, getBatchRequestPayload: Mr, prismaGraphQLToJSError: $r, PrismaClientUnknownRequestError: V, PrismaClientInitializationError: P, PrismaClientKnownRequestError: z, debug: N("prisma:client:accelerateEngine"), engineVersion: cu.version, clientVersion: e.clientVersion } }, rr("clientVersion", e.clientVersion), this._engine = Ml(e, this._engineConfig), this._requestHandler = new ei(this, i), l.log) for (let f of l.log) {
              let h = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              h && this.$on(h, (g) => {
                nt.log(`${nt.tags[h] ?? ""}`, g.message || g.query);
              });
            }
          } catch (l) {
            throw l.clientVersion = this._clientVersion, l;
          }
          return this._appliedParent = Pt(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        $on(n, i) {
          return n === "beforeExit" ? this._engine.onBeforeExit(i) : n && this._engineConfig.logEmitter.on(n, i), this;
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          }
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          } finally {
            Uo();
          }
        }
        $executeRawInternal(n, i, o, s) {
          let a = this._activeProvider;
          return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: So({ clientMethod: i, activeProvider: a }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $executeRaw(n, ...i) {
          return this._createPrismaPromise((o) => {
            if (n.raw !== void 0 || n.sql !== void 0) {
              let [s, a] = uu(n, i);
              return To(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a);
            }
            throw new Z("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
          });
        }
        $executeRawUnsafe(n, ...i) {
          return this._createPrismaPromise((o) => (To(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
        }
        $runCommandRaw(n) {
          if (e.activeProvider !== "mongodb") throw new Z(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
          return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: ql, callsite: Ze(this._errorFormat), transaction: i }));
        }
        async $queryRawInternal(n, i, o, s) {
          let a = this._activeProvider;
          return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: So({ clientMethod: i, activeProvider: a }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $queryRaw(n, ...i) {
          return this._createPrismaPromise((o) => {
            if (n.raw !== void 0 || n.sql !== void 0) return this.$queryRawInternal(o, "$queryRaw", ...uu(n, i));
            throw new Z("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
          });
        }
        $queryRawTyped(n) {
          return this._createPrismaPromise((i) => {
            if (!this._hasPreviewFlag("typedSql")) throw new Z("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
            return this.$queryRawInternal(i, "$queryRawTyped", n);
          });
        }
        $queryRawUnsafe(n, ...i) {
          return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
        }
        _transactionWithArray({ promises: n, options: i }) {
          let o = $f.nextId(), s = Yl(n.length), a = n.map((l, u) => {
            if (l?.[Symbol.toStringTag] !== "PrismaPromise") throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            let c = i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
            return l.requestTransaction?.(p) ?? l;
          });
          return lu(a);
        }
        async _transactionWithCallback({ callback: n, options: i }) {
          let o = { traceparent: this._tracingHelper.getTraceParent() }, s = { maxWait: i?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a = await this._engine.transaction("start", o, s), l;
          try {
            let u = { kind: "itx", ...a };
            l = await n(this._createItxClient(u)), await this._engine.transaction("commit", o, a);
          } catch (u) {
            throw await this._engine.transaction("rollback", o, a).catch(() => {
            }), u;
          }
          return l;
        }
        _createItxClient(n) {
          return he(Pt(he(Qa(this), [re("_appliedParent", () => this._appliedParent._createItxClient(n)), re("_createPrismaPromise", () => Ro(n)), re(Mf, () => n.id)])), [Fr(Ya)]);
        }
        $transaction(n, i) {
          let o;
          typeof n == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o = () => {
            throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
          } : o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
          let s = { name: "transaction", attributes: { method: "$transaction" } };
          return this._tracingHelper.runInChildSpan(s, o);
        }
        _request(n) {
          n.otelParentCtx = this._tracingHelper.getActiveContext();
          let i = n.middlewareArgsMapper ?? Ff, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a = async (l) => {
            let { runInTransaction: u, args: c, ...p } = l, d = { ...n, ...p };
            c && (d.args = i.middlewareArgsToRequestArgs(c)), n.transaction !== void 0 && u === false && delete d.transaction;
            let f = await el(this, d);
            return d.model ? Ha({ result: f, modelName: d.model, args: d.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : f;
          };
          return this._tracingHelper.runInChildSpan(s.operation, () => new pu.AsyncResource("prisma-client-request").runInAsyncScope(() => a(o)));
        }
        async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: d, customDataProxyFetch: f }) {
          try {
            n = u ? u(n) : n;
            let h = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(h, () => $n({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
            return N.enabled("prisma:client") && (rr("Prisma Client call:"), rr(`prisma.${i}(${Na(n)})`), rr("Generated request:"), rr(JSON.stringify(g, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: g, modelName: l, action: a, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: d, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: f });
          } catch (h) {
            throw h.clientVersion = this._clientVersion, h;
          }
        }
        _hasPreviewFlag(n) {
          return !!this._engineConfig.previewFeatures?.includes(n);
        }
        $applyPendingMigrations() {
          return this._engine.applyPendingMigrations();
        }
      }
      return r;
    }
    function uu(e, r) {
      return qf(e) ? [new ie(e, r), Wl] : [e, Jl];
    }
    function qf(e) {
      return Array.isArray(e) && Array.isArray(e.raw);
    }
    var Vf = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
    function gu(e) {
      return new Proxy(e, { get(r, t) {
        if (t in r) return r[t];
        if (!Vf.has(t)) throw new TypeError(`Invalid enum value: ${String(t)}`);
      } });
    }
    function hu(e) {
      st(e, { conflictCheck: "warn" });
    }
  }
});

// src/generated/prisma/index.js
var require_prisma = __commonJS({
  "src/generated/prisma/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join2,
      raw: raw2,
      skip: skip2,
      Decimal: Decimal3,
      Debug: Debug2,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2,
      warnOnce: warnOnce2,
      defineDmmfProperty: defineDmmfProperty2,
      Public: Public2,
      getRuntime: getRuntime2,
      createParam: createParam2
    } = require_library();
    var Prisma = {};
    exports2.Prisma = Prisma;
    exports2.$Enums = {};
    Prisma.prismaVersion = {
      client: "6.18.0",
      engine: "34b5a692b7bd79939a9a2c3ef97d816e749cda2f"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.Decimal = Decimal3;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join2;
    Prisma.raw = raw2;
    Prisma.validator = Public2.validator;
    Prisma.getExtensionContext = Extensions2.getExtensionContext;
    Prisma.defineExtension = Extensions2.defineExtension;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    var path4 = require("path");
    exports2.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      ReadUncommitted: "ReadUncommitted",
      ReadCommitted: "ReadCommitted",
      RepeatableRead: "RepeatableRead",
      Serializable: "Serializable"
    });
    exports2.Prisma.UserScalarFieldEnum = {
      id: "id",
      email: "email",
      password: "password",
      name: "name",
      phone: "phone",
      storeId: "storeId",
      isOwner: "isOwner",
      status: "status",
      deletedAt: "deletedAt",
      deletedById: "deletedById",
      suspendedAt: "suspendedAt",
      invitedById: "invitedById",
      acceptedAt: "acceptedAt",
      inviteCode: "inviteCode",
      pendingInvitation: "pendingInvitation",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      lastLoginAt: "lastLoginAt",
      lastActiveAt: "lastActiveAt",
      emailVerified: "emailVerified",
      emailVerificationToken: "emailVerificationToken",
      emailVerificationCode: "emailVerificationCode",
      emailVerificationCodeExpires: "emailVerificationCodeExpires",
      resetPasswordToken: "resetPasswordToken",
      resetPasswordExpires: "resetPasswordExpires"
    };
    exports2.Prisma.UserPermissionScalarFieldEnum = {
      id: "id",
      userId: "userId",
      action: "action",
      resource: "resource",
      scope: "scope",
      grant: "grant",
      expiresAt: "expiresAt",
      conditions: "conditions",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.UserPreferencesScalarFieldEnum = {
      id: "id",
      userId: "userId",
      theme: "theme",
      primaryColor: "primaryColor",
      sidebarCollapsed: "sidebarCollapsed",
      compactMode: "compactMode",
      uiScale: "uiScale",
      language: "language",
      currency: "currency",
      timezone: "timezone",
      dateFormat: "dateFormat",
      timeFormat: "timeFormat",
      numberFormat: "numberFormat",
      emailNotifications: "emailNotifications",
      pushNotifications: "pushNotifications",
      smsNotifications: "smsNotifications",
      notificationTypes: "notificationTypes",
      dashboardLayout: "dashboardLayout",
      defaultPage: "defaultPage",
      itemsPerPage: "itemsPerPage",
      autoRefresh: "autoRefresh",
      refreshInterval: "refreshInterval",
      customSettings: "customSettings",
      aiAssistantSettings: "aiAssistantSettings",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.StoreScalarFieldEnum = {
      id: "id",
      ownerId: "ownerId",
      name: "name",
      cnpj: "cnpj",
      email: "email",
      phone: "phone",
      description: "description",
      logoUrl: "logoUrl",
      website: "website",
      cep: "cep",
      city: "city",
      state: "state",
      address: "address",
      status: "status",
      deletedAt: "deletedAt",
      suspendedAt: "suspendedAt",
      plan: "plan",
      timezone: "timezone",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      settings: "settings"
    };
    exports2.Prisma.ProductScalarFieldEnum = {
      id: "id",
      name: "name",
      sku: "sku",
      barcode: "barcode",
      referenceCode: "referenceCode",
      description: "description",
      unitOfMeasure: "unitOfMeasure",
      referencePrice: "referencePrice",
      costPrice: "costPrice",
      markupPercent: "markupPercent",
      currency: "currency",
      stockCurrent: "stockCurrent",
      stockMin: "stockMin",
      stockMax: "stockMax",
      alertPercentage: "alertPercentage",
      allowNegative: "allowNegative",
      batchTracked: "batchTracked",
      expirationDate: "expirationDate",
      storeId: "storeId",
      supplierId: "supplierId",
      status: "status",
      deletedAt: "deletedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      tags: "tags",
      metadata: "metadata"
    };
    exports2.Prisma.CategoryScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      code: "code",
      color: "color",
      icon: "icon",
      parentId: "parentId",
      storeId: "storeId",
      status: "status",
      deletedAt: "deletedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      tags: "tags",
      metadata: "metadata"
    };
    exports2.Prisma.ProductCategoryScalarFieldEnum = {
      id: "id",
      productId: "productId",
      categoryId: "categoryId",
      createdAt: "createdAt"
    };
    exports2.Prisma.SupplierScalarFieldEnum = {
      id: "id",
      corporateName: "corporateName",
      tradeName: "tradeName",
      cnpj: "cnpj",
      ie: "ie",
      email: "email",
      phone: "phone",
      website: "website",
      description: "description",
      cep: "cep",
      city: "city",
      state: "state",
      address: "address",
      complement: "complement",
      storeId: "storeId",
      status: "status",
      deletedAt: "deletedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      tags: "tags",
      metadata: "metadata"
    };
    exports2.Prisma.SupplierResponsibleScalarFieldEnum = {
      id: "id",
      supplierId: "supplierId",
      name: "name",
      role: "role",
      phone: "phone",
      email: "email",
      cpf: "cpf",
      whatsapp: "whatsapp",
      mainContact: "mainContact",
      notes: "notes",
      status: "status",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      deletedAt: "deletedAt"
    };
    exports2.Prisma.MovementScalarFieldEnum = {
      id: "id",
      type: "type",
      origin: "origin",
      referenceCode: "referenceCode",
      note: "note",
      quantity: "quantity",
      price: "price",
      totalValue: "totalValue",
      balanceBefore: "balanceBefore",
      balanceAfter: "balanceAfter",
      batch: "batch",
      expiration: "expiration",
      storeId: "storeId",
      productId: "productId",
      supplierId: "supplierId",
      userId: "userId",
      verified: "verified",
      verifiedAt: "verifiedAt",
      verifiedBy: "verifiedBy",
      verificationNote: "verificationNote",
      cancelled: "cancelled",
      cancelledAt: "cancelledAt",
      cancelledBy: "cancelledBy",
      cancellationReason: "cancellationReason",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      deletedAt: "deletedAt",
      metadata: "metadata"
    };
    exports2.Prisma.SubscriptionScalarFieldEnum = {
      id: "id",
      userId: "userId",
      polarCustomerId: "polarCustomerId",
      polarSubscriptionId: "polarSubscriptionId",
      polarProductId: "polarProductId",
      polarPlanName: "polarPlanName",
      status: "status",
      currentPeriodEnd: "currentPeriodEnd",
      trialEndsAt: "trialEndsAt",
      cancelledAt: "cancelledAt",
      renewalCount: "renewalCount",
      priceAmount: "priceAmount",
      priceInterval: "priceInterval",
      currency: "currency",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.InvoiceScalarFieldEnum = {
      id: "id",
      subscriptionId: "subscriptionId",
      polarInvoiceId: "polarInvoiceId",
      amount: "amount",
      currency: "currency",
      status: "status",
      paymentDate: "paymentDate",
      dueDate: "dueDate",
      createdAt: "createdAt"
    };
    exports2.Prisma.QuoteScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      userId: "userId",
      customerId: "customerId",
      customerName: "customerName",
      title: "title",
      description: "description",
      publicId: "publicId",
      authCode: "authCode",
      status: "status",
      expiresAt: "expiresAt",
      viewedAt: "viewedAt",
      approvedAt: "approvedAt",
      rejectedAt: "rejectedAt",
      convertedAt: "convertedAt",
      canceledAt: "canceledAt",
      approvalNote: "approvalNote",
      ipAddress: "ipAddress",
      viewedBy: "viewedBy",
      subtotal: "subtotal",
      discount: "discount",
      interest: "interest",
      total: "total",
      currency: "currency",
      paymentType: "paymentType",
      paymentTerms: "paymentTerms",
      paymentDueDays: "paymentDueDays",
      observations: "observations",
      notesInternal: "notesInternal",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      deletedAt: "deletedAt"
    };
    exports2.Prisma.QuoteItemScalarFieldEnum = {
      id: "id",
      quoteId: "quoteId",
      productId: "productId",
      quantity: "quantity",
      unitPrice: "unitPrice",
      subtotal: "subtotal",
      discount: "discount",
      note: "note"
    };
    exports2.Prisma.QuoteInstallmentScalarFieldEnum = {
      id: "id",
      quoteId: "quoteId",
      number: "number",
      dueDate: "dueDate",
      amount: "amount",
      interest: "interest",
      paidAt: "paidAt"
    };
    exports2.Prisma.NotificationScalarFieldEnum = {
      id: "id",
      userId: "userId",
      storeId: "storeId",
      title: "title",
      message: "message",
      type: "type",
      priority: "priority",
      isRead: "isRead",
      readAt: "readAt",
      channel: "channel",
      sentAt: "sentAt",
      deliveredAt: "deliveredAt",
      deliveryError: "deliveryError",
      actionUrl: "actionUrl",
      expiresAt: "expiresAt",
      data: "data",
      deletedAt: "deletedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.AuditLogScalarFieldEnum = {
      id: "id",
      entity: "entity",
      entityId: "entityId",
      action: "action",
      userId: "userId",
      storeId: "storeId",
      ipAddress: "ipAddress",
      userAgent: "userAgent",
      source: "source",
      before: "before",
      after: "after",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.MediaScalarFieldEnum = {
      id: "id",
      url: "url",
      name: "name",
      type: "type",
      extension: "extension",
      size: "size",
      hash: "hash",
      storeId: "storeId",
      uploadedById: "uploadedById",
      provider: "provider",
      storagePath: "storagePath",
      bucket: "bucket",
      visibility: "visibility",
      status: "status",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      deletedAt: "deletedAt"
    };
    exports2.Prisma.ProductMediaScalarFieldEnum = {
      id: "id",
      productId: "productId",
      mediaId: "mediaId",
      isPrimary: "isPrimary",
      altText: "altText",
      sortOrder: "sortOrder"
    };
    exports2.Prisma.SupplierMediaScalarFieldEnum = {
      id: "id",
      supplierId: "supplierId",
      mediaId: "mediaId"
    };
    exports2.Prisma.UserMediaScalarFieldEnum = {
      id: "id",
      userId: "userId",
      mediaId: "mediaId"
    };
    exports2.Prisma.StoreMediaScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      mediaId: "mediaId"
    };
    exports2.Prisma.RoadmapScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      userId: "userId",
      title: "title",
      description: "description",
      status: "status",
      visibility: "visibility",
      priority: "priority",
      progress: "progress",
      archived: "archived",
      deletedAt: "deletedAt",
      startDate: "startDate",
      endDate: "endDate",
      createdById: "createdById",
      updatedById: "updatedById",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      tags: "tags",
      metadata: "metadata"
    };
    exports2.Prisma.MilestoneScalarFieldEnum = {
      id: "id",
      roadmapId: "roadmapId",
      title: "title",
      description: "description",
      status: "status",
      progress: "progress",
      order: "order",
      priority: "priority",
      blockedById: "blockedById",
      startDate: "startDate",
      endDate: "endDate",
      completedAt: "completedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      deletedAt: "deletedAt",
      metadata: "metadata"
    };
    exports2.Prisma.CrmStageScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      name: "name",
      color: "color",
      order: "order",
      description: "description",
      isDefault: "isDefault",
      isFinal: "isFinal",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.CrmClientScalarFieldEnum = {
      id: "id",
      storeId: "storeId",
      stageId: "stageId",
      name: "name",
      email: "email",
      phone: "phone",
      cpfCnpj: "cpfCnpj",
      company: "company",
      position: "position",
      source: "source",
      status: "status",
      tags: "tags",
      notes: "notes",
      lastContactAt: "lastContactAt",
      nextContactAt: "nextContactAt",
      lastInteraction: "lastInteraction",
      ownerId: "ownerId",
      archivedAt: "archivedAt",
      deletedAt: "deletedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.FlowScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      version: "version",
      category: "category",
      nodes: "nodes",
      edges: "edges",
      metadata: "metadata",
      status: "status",
      isPublic: "isPublic",
      deletedAt: "deletedAt",
      storeId: "storeId",
      createdBy: "createdBy",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      lastRunAt: "lastRunAt",
      lastStatus: "lastStatus"
    };
    exports2.Prisma.FlowNodeScalarFieldEnum = {
      id: "id",
      flowId: "flowId",
      nodeId: "nodeId",
      type: "type",
      name: "name",
      config: "config",
      order: "order",
      parentNodeId: "parentNodeId",
      position: "position",
      metadata: "metadata",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.FlowExecutionScalarFieldEnum = {
      id: "id",
      flowId: "flowId",
      status: "status",
      triggerType: "triggerType",
      triggerData: "triggerData",
      context: "context",
      executionLog: "executionLog",
      error: "error",
      durationMs: "durationMs",
      startedAt: "startedAt",
      completedAt: "completedAt",
      executedById: "executedById",
      storeId: "storeId"
    };
    exports2.Prisma.ChatSessionScalarFieldEnum = {
      id: "id",
      userId: "userId",
      storeId: "storeId",
      title: "title",
      model: "model",
      temperature: "temperature",
      context: "context",
      metadata: "metadata",
      active: "active",
      isPinned: "isPinned",
      deletedAt: "deletedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      lastActivityAt: "lastActivityAt"
    };
    exports2.Prisma.ChatMessageScalarFieldEnum = {
      id: "id",
      sessionId: "sessionId",
      role: "role",
      content: "content",
      tokens: "tokens",
      model: "model",
      context: "context",
      options: "options",
      error: "error",
      cost: "cost",
      latencyMs: "latencyMs",
      isFinal: "isFinal",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.SortOrder = {
      asc: "asc",
      desc: "desc"
    };
    exports2.Prisma.NullableJsonNullValueInput = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull
    };
    exports2.Prisma.JsonNullValueInput = {
      JsonNull: Prisma.JsonNull
    };
    exports2.Prisma.QueryMode = {
      default: "default",
      insensitive: "insensitive"
    };
    exports2.Prisma.NullsOrder = {
      first: "first",
      last: "last"
    };
    exports2.Prisma.JsonNullValueFilter = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull,
      AnyNull: Prisma.AnyNull
    };
    exports2.UnitOfMeasure = exports2.$Enums.UnitOfMeasure = {
      UNIDADE: "UNIDADE",
      KG: "KG",
      L: "L",
      ML: "ML",
      M: "M",
      CM: "CM",
      MM: "MM",
      UN: "UN",
      DZ: "DZ",
      CX: "CX",
      PCT: "PCT",
      KIT: "KIT",
      PAR: "PAR",
      H: "H",
      D: "D"
    };
    exports2.MovementType = exports2.$Enums.MovementType = {
      INBOUND: "INBOUND",
      OUTBOUND: "OUTBOUND",
      LOSS: "LOSS"
    };
    exports2.MovementOrigin = exports2.$Enums.MovementOrigin = {
      PURCHASE: "PURCHASE",
      SALE: "SALE",
      RETURN: "RETURN",
      SUPPLIER_RETURN: "SUPPLIER_RETURN",
      ADJUSTMENT: "ADJUSTMENT",
      TRANSFER: "TRANSFER",
      INVENTORY: "INVENTORY",
      DAMAGE: "DAMAGE",
      EXPIRATION: "EXPIRATION",
      OTHER: "OTHER"
    };
    exports2.SubscriptionStatus = exports2.$Enums.SubscriptionStatus = {
      ACTIVE: "ACTIVE",
      INACTIVE: "INACTIVE",
      CANCELLED: "CANCELLED",
      TRIAL: "TRIAL",
      EXPIRED: "EXPIRED",
      PAST_DUE: "PAST_DUE"
    };
    exports2.PlanInterval = exports2.$Enums.PlanInterval = {
      MONTHLY: "MONTHLY",
      YEARLY: "YEARLY"
    };
    exports2.InvoiceStatus = exports2.$Enums.InvoiceStatus = {
      PENDING: "PENDING",
      PAID: "PAID",
      FAILED: "FAILED",
      REFUNDED: "REFUNDED"
    };
    exports2.PaymentType = exports2.$Enums.PaymentType = {
      UNDEFINED: "UNDEFINED",
      PIX: "PIX",
      BOLETO: "BOLETO",
      CREDIT_CARD: "CREDIT_CARD",
      CASH: "CASH",
      TRANSFER: "TRANSFER"
    };
    exports2.QuoteStatus = exports2.$Enums.QuoteStatus = {
      DRAFT: "DRAFT",
      PUBLISHED: "PUBLISHED",
      SENT: "SENT",
      VIEWED: "VIEWED",
      APPROVED: "APPROVED",
      REJECTED: "REJECTED",
      EXPIRED: "EXPIRED",
      CONVERTED: "CONVERTED",
      CANCELED: "CANCELED"
    };
    exports2.NotificationType = exports2.$Enums.NotificationType = {
      INFO: "INFO",
      SUCCESS: "SUCCESS",
      WARNING: "WARNING",
      ERROR: "ERROR",
      STOCK_ALERT: "STOCK_ALERT",
      MOVEMENT: "MOVEMENT",
      PERMISSION: "PERMISSION",
      SYSTEM: "SYSTEM",
      BILLING: "BILLING",
      WORKFLOW: "WORKFLOW"
    };
    exports2.NotificationPriority = exports2.$Enums.NotificationPriority = {
      LOW: "LOW",
      MEDIUM: "MEDIUM",
      HIGH: "HIGH",
      URGENT: "URGENT"
    };
    exports2.NotificationChannel = exports2.$Enums.NotificationChannel = {
      IN_APP: "IN_APP",
      PUSH: "PUSH",
      EMAIL: "EMAIL",
      SMS: "SMS",
      SYSTEM: "SYSTEM"
    };
    exports2.AuditAction = exports2.$Enums.AuditAction = {
      CREATE: "CREATE",
      UPDATE: "UPDATE",
      DELETE: "DELETE",
      LOGIN: "LOGIN",
      LOGOUT: "LOGOUT",
      VERIFY: "VERIFY",
      RESTORE: "RESTORE"
    };
    exports2.AuditEntity = exports2.$Enums.AuditEntity = {
      USER: "USER",
      STORE: "STORE",
      PRODUCT: "PRODUCT",
      SUPPLIER: "SUPPLIER",
      MOVEMENT: "MOVEMENT",
      CATEGORY: "CATEGORY",
      QUOTE: "QUOTE",
      FLOW: "FLOW",
      SYSTEM: "SYSTEM"
    };
    exports2.StorageProvider = exports2.$Enums.StorageProvider = {
      SYSTEM: "SYSTEM",
      S3: "S3",
      SUPABASE: "SUPABASE",
      CLOUDINARY: "CLOUDINARY",
      GOOGLE_DRIVE: "GOOGLE_DRIVE"
    };
    exports2.MediaVisibility = exports2.$Enums.MediaVisibility = {
      PRIVATE: "PRIVATE",
      PUBLIC: "PUBLIC",
      RESTRICTED: "RESTRICTED"
    };
    exports2.MediaStatus = exports2.$Enums.MediaStatus = {
      ACTIVE: "ACTIVE",
      ARCHIVED: "ARCHIVED",
      DELETED: "DELETED",
      PROCESSING: "PROCESSING"
    };
    exports2.RoadmapStatus = exports2.$Enums.RoadmapStatus = {
      ACTIVE: "ACTIVE",
      COMPLETED: "COMPLETED",
      ARCHIVED: "ARCHIVED"
    };
    exports2.RoadmapVisibility = exports2.$Enums.RoadmapVisibility = {
      PRIVATE: "PRIVATE",
      PUBLIC: "PUBLIC",
      INTERNAL: "INTERNAL"
    };
    exports2.RoadmapPriority = exports2.$Enums.RoadmapPriority = {
      LOW: "LOW",
      MEDIUM: "MEDIUM",
      HIGH: "HIGH",
      CRITICAL: "CRITICAL"
    };
    exports2.MilestoneStatus = exports2.$Enums.MilestoneStatus = {
      PENDING: "PENDING",
      IN_PROGRESS: "IN_PROGRESS",
      COMPLETED: "COMPLETED",
      BLOCKED: "BLOCKED"
    };
    exports2.CrmClientStatus = exports2.$Enums.CrmClientStatus = {
      ACTIVE: "ACTIVE",
      WON: "WON",
      LOST: "LOST",
      INACTIVE: "INACTIVE",
      ARCHIVED: "ARCHIVED"
    };
    exports2.FlowStatus = exports2.$Enums.FlowStatus = {
      ACTIVE: "ACTIVE",
      INACTIVE: "INACTIVE",
      DRAFT: "DRAFT"
    };
    exports2.FlowNodeType = exports2.$Enums.FlowNodeType = {
      TRIGGER: "TRIGGER",
      CONDITION: "CONDITION",
      ACTION: "ACTION",
      NOTIFICATION: "NOTIFICATION"
    };
    exports2.FlowExecutionStatus = exports2.$Enums.FlowExecutionStatus = {
      SUCCESS: "SUCCESS",
      FAILED: "FAILED",
      RUNNING: "RUNNING",
      CANCELLED: "CANCELLED"
    };
    exports2.ChatMessageRole = exports2.$Enums.ChatMessageRole = {
      USER: "USER",
      ASSISTANT: "ASSISTANT",
      SYSTEM: "SYSTEM",
      TOOL: "TOOL"
    };
    exports2.Prisma.ModelName = {
      User: "User",
      UserPermission: "UserPermission",
      UserPreferences: "UserPreferences",
      Store: "Store",
      Product: "Product",
      Category: "Category",
      ProductCategory: "ProductCategory",
      Supplier: "Supplier",
      SupplierResponsible: "SupplierResponsible",
      Movement: "Movement",
      Subscription: "Subscription",
      Invoice: "Invoice",
      Quote: "Quote",
      QuoteItem: "QuoteItem",
      QuoteInstallment: "QuoteInstallment",
      Notification: "Notification",
      AuditLog: "AuditLog",
      Media: "Media",
      ProductMedia: "ProductMedia",
      SupplierMedia: "SupplierMedia",
      UserMedia: "UserMedia",
      StoreMedia: "StoreMedia",
      Roadmap: "Roadmap",
      Milestone: "Milestone",
      CrmStage: "CrmStage",
      CrmClient: "CrmClient",
      Flow: "Flow",
      FlowNode: "FlowNode",
      FlowExecution: "FlowExecution",
      ChatSession: "ChatSession",
      ChatMessage: "ChatMessage"
    };
    var config = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "C:\\Node\\fastify_20stock\\src\\generated\\prisma",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "library"
        },
        "binaryTargets": [
          {
            "fromEnvVar": null,
            "value": "windows",
            "native": true
          }
        ],
        "previewFeatures": [],
        "sourceFilePath": "C:\\Node\\fastify_20stock\\prisma\\schema.prisma",
        "isCustomOutput": true
      },
      "relativeEnvPaths": {
        "rootEnvPath": null,
        "schemaEnvPath": "../../../.env"
      },
      "relativePath": "../../../prisma",
      "clientVersion": "6.18.0",
      "engineVersion": "34b5a692b7bd79939a9a2c3ef97d816e749cda2f",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "postgresql",
      "postinstall": false,
      "inlineDatasources": {
        "db": {
          "url": {
            "fromEnvVar": "DATABASE_URL",
            "value": null
          }
        }
      },
      "inlineSchema": 'generator client {\n  provider      = "prisma-client-js"\n  output        = "../src/generated/prisma"\n  binaryTargets = "native"\n}\n\ndatasource db {\n  provider = "postgresql"\n  url      = env("DATABASE_URL")\n}\n\n// ========== user.prisma ==========\n/// ===============================\n///  USER & STORE STRUCTURE\n///  - Cada usu\xE1rio pertence a uma \xFAnica loja.\n///  - Dono (isOwner = true) \xE9 o criador da loja.\n///  - Permiss\xF5es s\xE3o granulares (ACL).\n///  - Soft delete com deletedAt.\n/// ===============================\n\nmodel User {\n  id String @id @default(cuid())\n\n  // Identifica\xE7\xE3o\n  email    String  @unique\n  password String\n  name     String?\n  phone    String?\n\n  // Associa\xE7\xE3o direta com a loja\n  storeId String?\n  store   Store?  @relation(fields: [storeId], references: [id], onDelete: Cascade)\n\n  // Controle de status e hierarquia\n  isOwner     Boolean   @default(false)\n  status      Boolean   @default(true)\n  deletedAt   DateTime?\n  deletedById String?\n  deletedBy   User?     @relation("UserDeleted", fields: [deletedById], references: [id])\n  suspendedAt DateTime? // bloqueio tempor\xE1rio\n\n  invitedById       String?\n  invitedBy         User?     @relation("UserInviter", fields: [invitedById], references: [id])\n  acceptedAt        DateTime?\n  inviteCode        String?   @unique\n  pendingInvitation Boolean   @default(false)\n\n  ownedStore Store? @relation("StoreOwner")\n\n  // Auditoria e seguran\xE7a\n  createdAt    DateTime  @default(now())\n  updatedAt    DateTime  @updatedAt\n  lastLoginAt  DateTime?\n  lastActiveAt DateTime?\n\n  emailVerified                Boolean   @default(false)\n  emailVerificationToken       String?\n  emailVerificationCode        String?\n  emailVerificationCodeExpires DateTime?\n  resetPasswordToken           String?\n  resetPasswordExpires         DateTime?\n\n  // Rela\xE7\xF5es\n  permissions   UserPermission[]\n  preferences   UserPreferences?\n  notifications Notification[]\n  media         UserMedia[]\n  uploadedMedia Media[]\n  quotes        Quote[]\n\n  subscription Subscription?\n\n  auditLogs      AuditLog[]\n  movements      Movement[]\n  roadmaps       Roadmap[]\n  createdFlows   Flow[]\n  flowExecutions FlowExecution[]\n  crmClients     CrmClient[]\n  chatSessions   ChatSession[]\n\n  // Rela\xE7\xF5es auto-referenciais\n  invitedUsers User[] @relation("UserInviter")\n  deletedUsers User[] @relation("UserDeleted")\n\n  // \xCDndices estrat\xE9gicos\n  @@index([storeId])\n  @@index([storeId, isOwner])\n  @@index([status])\n  @@index([deletedAt])\n  @@map("users")\n}\n\nmodel UserPermission {\n  id     String @id @default(cuid())\n  userId String\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  action     String // Ex: "create", "update", "delete"\n  resource   String // Ex: "product", "supplier"\n  scope      String? // m\xF3dulo l\xF3gico ex: "inventory", "crm"\n  grant      Boolean   @default(true)\n  expiresAt  DateTime? // expira\xE7\xE3o da permiss\xE3o (tempor\xE1ria)\n  conditions Json? // Ex: { "category": "Bebidas" }\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@unique([userId, action, resource])\n  @@index([userId])\n  @@index([resource])\n  @@index([scope])\n  @@map("user_permissions")\n}\n\nmodel UserPreferences {\n  id     String @id @default(cuid())\n  userId String @unique\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  // ===== THEME & UI =====\n  theme            String  @default("light")\n  primaryColor     String?\n  sidebarCollapsed Boolean @default(false)\n  compactMode      Boolean @default(false)\n  uiScale          Float   @default(1.0) // escala visual (zoom/acessibilidade)\n\n  // ===== LANGUAGE & LOCALIZATION =====\n  language     String @default("pt-BR")\n  currency     String @default("BRL")\n  timezone     String @default("America/Sao_Paulo")\n  dateFormat   String @default("DD/MM/YYYY")\n  timeFormat   String @default("24h")\n  numberFormat String @default("pt-BR")\n\n  // ===== NOTIFICATION PREFERENCES =====\n  emailNotifications Boolean @default(true)\n  pushNotifications  Boolean @default(true)\n  smsNotifications   Boolean @default(false)\n  notificationTypes  Json?\n\n  // ===== DASHBOARD & LAYOUT =====\n  dashboardLayout Json?\n  defaultPage     String?\n  itemsPerPage    Int     @default(20)\n\n  // ===== BEHAVIOR =====\n  autoRefresh     Boolean @default(true)\n  refreshInterval Int     @default(30)\n\n  // ===== ADVANCED =====\n  customSettings      Json?\n  aiAssistantSettings Json? // IA / LLM settings por usu\xE1rio\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  @@index([userId])\n  @@map("user_preferences")\n}\n\n// ========== store.prisma ==========\n/// ===============================\n///  STORE STRUCTURE\n///  - Cada loja tem um \xFAnico dono (ownerId).\n///  - Usu\xE1rios pertencem diretamente \xE0 loja.\n///  - Suporte a soft delete e auditoria.\n///  - Base pronta para IA, billing e opera\xE7\xF5es.\n/// ===============================\n\nmodel Store {\n  id      String  @id @default(cuid())\n  ownerId String? @unique\n  owner   User?   @relation("StoreOwner", fields: [ownerId], references: [id])\n\n  // Identifica\xE7\xE3o e dados b\xE1sicos\n  name        String\n  cnpj        String  @unique\n  email       String?\n  phone       String?\n  description String? // opcional: pode ser mostrado no dashboard\n  logoUrl     String? // opcional: imagem da loja\n  website     String? // opcional\n\n  // Endere\xE7o\n  cep     String?\n  city    String?\n  state   String?\n  address String?\n\n  // Controle e status\n  status      Boolean   @default(true)\n  deletedAt   DateTime? // soft delete (loja desativada)\n  suspendedAt DateTime? // bloqueio tempor\xE1rio (ex: problema no pagamento)\n  plan        String? // nome do plano atual (sincronizado com tabela de billing)\n  timezone    String?   @default("America/Sao_Paulo")\n\n  // Auditoria\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  // Rela\xE7\xF5es com m\xF3dulos do sistema\n  users          User[] // todos os usu\xE1rios dessa loja\n  products       Product[]\n  categories     Category[]\n  suppliers      Supplier[]\n  movements      Movement[]\n  media          StoreMedia[]\n  uploadedMedia  Media[]\n  roadmaps       Roadmap[]\n  crmStages      CrmStage[]\n  crmClients     CrmClient[]\n  flows          Flow[]\n  flowExecutions FlowExecution[]\n  auditLogs      AuditLog[]\n  notifications  Notification[]\n  quotes         Quote[]\n  chatSessions   ChatSession[]\n\n  // Configura\xE7\xF5es adicionais (JSON flex\xEDvel)\n  settings Json? // ex: { "autoStockAlerts": true, "defaultCurrency": "BRL" }\n\n  // \xCDndices estrat\xE9gicos\n  @@index([status])\n  @@index([deletedAt])\n  @@index([ownerId])\n  @@index([city])\n  @@index([state])\n}\n\n// ========== product.prisma ==========\n/// ===============================\n///  PRODUCT STRUCTURE\n///  - Cada produto pertence a uma loja.\n///  - Pode ter um fornecedor vinculado.\n///  - Suporte a categorias, m\xEDdia, controle de estoque e rastreabilidade.\n///  - Soft delete e campos para IA e relat\xF3rios.\n/// ===============================\n\nmodel Product {\n  id String @id @default(cuid())\n\n  // Identifica\xE7\xE3o\n  name          String\n  sku           String? @unique // SKU interno (opcional)\n  barcode       String? @unique // EAN/UPC opcional\n  referenceCode String? // c\xF3digo interno curto (ex: "PRD-001")\n  description   String?\n\n  // Unidade e precifica\xE7\xE3o\n  unitOfMeasure  UnitOfMeasure\n  referencePrice Decimal       @db.Decimal(10, 2) // pre\xE7o de refer\xEAncia\n  costPrice      Decimal?      @db.Decimal(10, 2) // custo m\xE9dio\n  markupPercent  Decimal?      @db.Decimal(5, 2) // margem sobre o custo (%)\n  currency       String        @default("BRL")\n\n  // Estoque\n  stockCurrent    Int     @default(0)\n  stockMin        Int     @default(0)\n  stockMax        Int     @default(0)\n  alertPercentage Int     @default(20) @db.SmallInt\n  allowNegative   Boolean @default(false)\n\n  // Controle de lote / validade (para alimentos, medicamentos etc.)\n  batchTracked   Boolean   @default(false)\n  expirationDate DateTime? // validade do produto principal (se aplic\xE1vel)\n\n  // Associa\xE7\xE3o\n  storeId    String\n  supplierId String?\n  store      Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)\n  supplier   Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull)\n\n  // Status e auditoria\n  status    Boolean   @default(true)\n  deletedAt DateTime? // soft delete\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n\n  // Rela\xE7\xF5es\n  movements  Movement[]\n  categories ProductCategory[]\n  media      ProductMedia[]\n  quotes     QuoteItem[]\n\n  // Extens\xF5es e metadados\n  tags     Json? // ex: ["bebida", "perec\xEDvel"]\n  metadata Json? // ex: { "ncm": "2202.10.00", "origem": "nacional" }\n\n  // \xCDndices e constraints\n  @@index([storeId])\n  @@index([supplierId])\n  @@index([status])\n  @@index([deletedAt])\n  @@index([name])\n  @@index([sku])\n}\n\nenum UnitOfMeasure {\n  UNIDADE\n  KG\n  L\n  ML\n  M\n  CM\n  MM\n  UN\n  DZ\n  CX\n  PCT\n  KIT\n  PAR\n  H\n  D\n}\n\n// ========== category.prisma ==========\n/// ===============================\n///  CATEGORY STRUCTURE\n///  - Cada loja possui suas pr\xF3prias categorias.\n///  - Suporte a subcategorias (hierarquia).\n///  - Soft delete, cor, \xEDcone e metadados.\n///  - Associada a produtos via tabela ProductCategory.\n/// ===============================\n\nmodel Category {\n  id String @id @default(cuid())\n\n  // Identifica\xE7\xE3o e exibi\xE7\xE3o\n  name        String\n  description String?\n  code        String? // c\xF3digo interno (opcional, ex: CAT-001)\n  color       String? // cor no painel ex: "#3B82F6"\n  icon        String? // \xEDcone do front ex: "box", "truck", "chart"\n\n  // Hierarquia\n  parentId String?\n  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])\n  children Category[] @relation("CategoryHierarchy")\n\n  // Loja\n  storeId String\n  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)\n\n  // Status e controle\n  status    Boolean   @default(true)\n  deletedAt DateTime? // soft delete\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n\n  // Relacionamentos\n  products ProductCategory[]\n\n  // Extens\xF5es e metadados\n  tags     Json? // ex: ["perec\xEDvel", "embalagem"]\n  metadata Json? // ex: { "priority": 1, "visibleInMenu": true }\n\n  // Restri\xE7\xF5es e \xEDndices\n  @@unique([code, storeId])\n  @@index([storeId])\n  @@index([status])\n  @@index([deletedAt])\n  @@index([name])\n}\n\nmodel ProductCategory {\n  id         String   @id @default(cuid())\n  productId  String\n  categoryId String\n  createdAt  DateTime @default(now())\n\n  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)\n  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)\n\n  @@unique([productId, categoryId])\n  @@index([categoryId])\n  @@index([productId])\n}\n\n// ========== supplier.prisma ==========\n/// ===============================\n///  SUPPLIER STRUCTURE\n///  - Fornecedor pertence a uma loja.\n///  - Pode ter v\xE1rios respons\xE1veis (SupplierResponsible).\n///  - Suporte a m\xEDdia, auditoria e soft delete.\n/// ===============================\n\nmodel Supplier {\n  id String @id @default(cuid())\n\n  // Identifica\xE7\xE3o b\xE1sica\n  corporateName String // Raz\xE3o social\n  tradeName     String? // Nome fantasia\n  cnpj          String\n  ie            String? // Inscri\xE7\xE3o estadual opcional\n  email         String?\n  phone         String?\n  website       String?\n  description   String? // Observa\xE7\xE3o interna\n\n  // Localiza\xE7\xE3o\n  cep        String?\n  city       String?\n  state      String?\n  address    String?\n  complement String?\n\n  // Relacionamento com a loja\n  storeId String\n  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)\n\n  // Status e auditoria\n  status    Boolean   @default(true)\n  deletedAt DateTime? // soft delete\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n\n  // Relacionamentos\n  products     Product[]\n  movements    Movement[]\n  responsibles SupplierResponsible[]\n  media        SupplierMedia[]\n\n  // Configura\xE7\xF5es / metadados (extens\xEDvel)\n  tags     Json? // Ex: ["distribuidor", "nacional"]\n  metadata Json? // Ex: { "frete": "pr\xF3prio", "tempoEntrega": "48h" }\n\n  @@unique([cnpj, storeId])\n  @@index([storeId])\n  @@index([status])\n  @@index([deletedAt])\n}\n\nmodel SupplierResponsible {\n  id         String   @id @default(cuid())\n  supplierId String\n  supplier   Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)\n\n  name        String\n  role        String? // cargo ex: "Vendas", "Financeiro", "Log\xEDstica"\n  phone       String?\n  email       String?\n  cpf         String?\n  whatsapp    Boolean   @default(false) // se esse contato \xE9 via WhatsApp\n  mainContact Boolean   @default(false) // define se \xE9 o contato principal\n  notes       String? // observa\xE7\xF5es internas\n  status      Boolean   @default(true)\n  createdAt   DateTime  @default(now())\n  updatedAt   DateTime  @updatedAt\n  deletedAt   DateTime? // soft delete\n\n  @@index([supplierId])\n  @@index([status])\n  @@index([mainContact])\n}\n\n// ========== movement.prisma ==========\n/// ===============================\n///  MOVEMENT STRUCTURE\n///  - Registra qualquer entrada, sa\xEDda ou perda de produto.\n///  - Controla saldo, custo e origem.\n///  - \xC9 base para relat\xF3rios, IA e auditoria de estoque.\n/// ===============================\n\nmodel Movement {\n  id String @id @default(cuid())\n\n  // Identifica\xE7\xE3o e contexto\n  type          MovementType // ENTRADA, SAIDA, PERDA\n  origin        MovementOrigin? // motivo ou contexto da movimenta\xE7\xE3o\n  referenceCode String? // c\xF3digo externo opcional (nota, pedido, etc.)\n  note          String? // observa\xE7\xF5es gerais\n\n  // Estoque e valores\n  quantity      Int\n  price         Decimal?  @db.Decimal(10, 2) // valor unit\xE1rio da movimenta\xE7\xE3o\n  totalValue    Decimal?  @db.Decimal(10, 2) // quantity * price\n  balanceBefore Int? // estoque antes da movimenta\xE7\xE3o\n  balanceAfter  Int? // estoque ap\xF3s a movimenta\xE7\xE3o\n  batch         String? // lote\n  expiration    DateTime? // validade (se aplic\xE1vel)\n\n  // Relacionamentos\n  storeId String\n  store   Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)\n\n  productId String\n  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)\n\n  supplierId String?\n  supplier   Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull)\n\n  userId String? // quem registrou\n  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)\n\n  // Verifica\xE7\xE3o e controle\n  verified         Boolean   @default(false)\n  verifiedAt       DateTime?\n  verifiedBy       String?\n  verificationNote String?\n\n  // Cancelamento\n  cancelled          Boolean   @default(false)\n  cancelledAt        DateTime?\n  cancelledBy        String?\n  cancellationReason String?\n\n  // Auditoria e status\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n  deletedAt DateTime? // soft delete, se precisar reverter algo manualmente\n\n  // Metadados e IA\n  metadata Json? // dados extras: { "source": "import", "autoGenerated": true }\n\n  // \xCDndices e otimiza\xE7\xF5es\n  @@index([storeId])\n  @@index([productId])\n  @@index([type])\n  @@index([createdAt])\n  @@index([cancelled])\n  @@index([verified])\n}\n\n/// ===============================\n///  MOVEMENT ENUMS\n///  - Type = dire\xE7\xE3o da movimenta\xE7\xE3o (entrada/sa\xEDda/perda)\n///  - Origin = motivo ou contexto da movimenta\xE7\xE3o\n/// ===============================\n\nenum MovementType {\n  INBOUND // Entrada de produtos no estoque\n  OUTBOUND // Sa\xEDda de produtos\n  LOSS // Perda ou descarte\n}\n\nenum MovementOrigin {\n  PURCHASE // Compra de fornecedor\n  SALE // Venda a cliente\n  RETURN // Devolu\xE7\xE3o de cliente\n  SUPPLIER_RETURN // Devolu\xE7\xE3o ao fornecedor\n  ADJUSTMENT // Ajuste manual de estoque\n  TRANSFER // Transfer\xEAncia entre locais\n  INVENTORY // Ajuste por contagem/invent\xE1rio\n  DAMAGE // Quebra ou dano\n  EXPIRATION // Produto vencido\n  OTHER // Outro motivo n\xE3o especificado  \n}\n\n// ========== billing.prisma ==========\n/// ===============================\n///  BILLING (Polar.sh Integration)\n///  - Polar \xE9 o sistema de cobran\xE7a principal.\n///  - O backend apenas espelha status e refer\xEAncias.\n/// ===============================\n\nmodel Subscription {\n  id     String @id @default(cuid())\n  userId String @unique\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  // Polar references\n  polarCustomerId     String? @unique\n  polarSubscriptionId String? @unique\n  polarProductId      String? // plano ativo no Polar\n  polarPlanName       String? // redund\xE2ncia para exibi\xE7\xE3o r\xE1pida no painel\n\n  // Status tracking\n  status           SubscriptionStatus @default(ACTIVE)\n  currentPeriodEnd DateTime? // data de renova\xE7\xE3o ou expira\xE7\xE3o\n  trialEndsAt      DateTime?\n  cancelledAt      DateTime?\n  renewalCount     Int                @default(0)\n\n  // Dados financeiros b\xE1sicos\n  priceAmount   Decimal?      @db.Decimal(10, 2)\n  priceInterval PlanInterval? // MONTHLY, YEARLY (espelhado do Polar)\n  currency      String?       @default("BRL")\n\n  // Auditoria\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n  invoices  Invoice[]\n\n  @@index([status])\n  @@index([polarSubscriptionId])\n  @@index([userId])\n}\n\nmodel Invoice {\n  id             String       @id @default(cuid())\n  subscriptionId String\n  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)\n\n  // Dados do Polar\n  polarInvoiceId String?       @unique\n  amount         Decimal       @db.Decimal(10, 2)\n  currency       String?       @default("BRL")\n  status         InvoiceStatus @default(PENDING)\n  paymentDate    DateTime?\n  dueDate        DateTime?\n  createdAt      DateTime      @default(now())\n\n  @@index([status])\n  @@index([subscriptionId])\n}\n\nenum SubscriptionStatus {\n  ACTIVE\n  INACTIVE\n  CANCELLED\n  TRIAL\n  EXPIRED\n  PAST_DUE\n}\n\nenum PlanInterval {\n  MONTHLY\n  YEARLY\n}\n\nenum InvoiceStatus {\n  PENDING\n  PAID\n  FAILED\n  REFUNDED\n}\n\n// ========== quote.prisma ==========\n/// ===============================\n///  QUOTATION (QUOTE) STRUCTURE\n///  - Or\xE7amentos criados pelos usu\xE1rios.\n///  - Possuem link p\xFAblico seguro (publicId + authCode).\n///  - Base para aprova\xE7\xF5es, convers\xF5es e vendas.\n/// ===============================\n\nmodel Quote {\n  id String @id @default(cuid())\n\n  // Associa\xE7\xE3o principal\n  storeId      String\n  store        Store   @relation(fields: [storeId], references: [id], onDelete: Cascade)\n  userId       String\n  user         User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n  customerId   String? // futuro: cliente vinculado (CRM)\n  customerName String? // nome do cliente externo (sem login)\n\n  // Identifica\xE7\xE3o\n  title       String\n  description String?\n  publicId    String  @unique @default(uuid()) // usado no link p\xFAblico\n  authCode    String  @default(uuid()) // valida acesso sem login\n\n  // Status e controle\n  status       QuoteStatus @default(DRAFT)\n  expiresAt    DateTime?\n  viewedAt     DateTime?\n  approvedAt   DateTime?\n  rejectedAt   DateTime?\n  convertedAt  DateTime?\n  canceledAt   DateTime?\n  approvalNote String? // observa\xE7\xE3o do cliente (motivo ou coment\xE1rio)\n  ipAddress    String? // IP de quem visualizou/aprovou\n  viewedBy     String? // email ou nome informado ao visualizar\n\n  // Valores\n  subtotal Decimal  @db.Decimal(10, 2)\n  discount Decimal? @db.Decimal(10, 2)\n  interest Decimal? @db.Decimal(10, 2)\n  total    Decimal  @db.Decimal(10, 2)\n  currency String   @default("BRL")\n\n  // Pagamento\n  paymentType    PaymentType @default(UNDEFINED)\n  paymentTerms   String? // ex: "6x sem juros"\n  paymentDueDays Int? // ex: 15 dias no boleto\n\n  // Observa\xE7\xF5es e anota\xE7\xF5es\n  observations  String?\n  notesInternal String? // observa\xE7\xE3o vis\xEDvel apenas internamente (n\xE3o p\xFAblica)\n\n  // Auditoria\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n  deletedAt DateTime? // soft delete\n\n  // Rela\xE7\xF5es\n  items        QuoteItem[]\n  installments QuoteInstallment[]\n\n  // \xCDndices\n  @@index([storeId])\n  @@index([userId])\n  @@index([status])\n  @@index([publicId])\n  @@index([createdAt])\n}\n\n/// ===============================\n///  QUOTE ITEM\n///  - Produtos inclu\xEDdos no or\xE7amento.\n/// ===============================\n\nmodel QuoteItem {\n  id        String   @id @default(cuid())\n  quoteId   String\n  productId String\n  quantity  Int\n  unitPrice Decimal  @db.Decimal(10, 2)\n  subtotal  Decimal  @db.Decimal(10, 2)\n  discount  Decimal? @db.Decimal(10, 2)\n  note      String?\n\n  quote   Quote   @relation(fields: [quoteId], references: [id], onDelete: Cascade)\n  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)\n\n  @@unique([quoteId, productId])\n  @@index([quoteId])\n}\n\n/// ===============================\n///  QUOTE INSTALLMENTS\n///  - Parcelas de pagamento do or\xE7amento.\n/// ===============================\n\nmodel QuoteInstallment {\n  id       String    @id @default(cuid())\n  quoteId  String\n  number   Int // n\xFAmero da parcela\n  dueDate  DateTime\n  amount   Decimal   @db.Decimal(10, 2)\n  interest Decimal?  @db.Decimal(10, 2)\n  paidAt   DateTime?\n\n  quote Quote @relation(fields: [quoteId], references: [id], onDelete: Cascade)\n\n  @@index([quoteId])\n  @@map("quote_installments")\n}\n\n/// ===============================\n///  ENUMS\n/// ===============================\n\nenum PaymentType {\n  UNDEFINED\n  PIX\n  BOLETO\n  CREDIT_CARD\n  CASH\n  TRANSFER\n}\n\nenum QuoteStatus {\n  DRAFT // Em edi\xE7\xE3o\n  PUBLISHED // Link p\xFAblico ativo\n  SENT // Enviado ao cliente\n  VIEWED // Cliente visualizou\n  APPROVED // Cliente aprovou\n  REJECTED // Cliente recusou\n  EXPIRED // Passou da validade\n  CONVERTED // Virou venda\n  CANCELED // Cancelado\n}\n\n// ========== notification.prisma ==========\n/// ===============================\n///  NOTIFICATION STRUCTURE\n///  - Sistema unificado de notifica\xE7\xF5es.\n///  - Cada notifica\xE7\xE3o pertence a um usu\xE1rio e loja.\n///  - Pode ser enviada via v\xE1rios canais (push, email, sms).\n///  - Base para alertas autom\xE1ticos, workflows e IA.\n/// ===============================\n\nmodel Notification {\n  id String @id @default(cuid())\n\n  // Associa\xE7\xE3o principal\n  userId  String\n  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n  storeId String?\n  store   Store?  @relation(fields: [storeId], references: [id], onDelete: SetNull)\n\n  // Conte\xFAdo\n  title    String\n  message  String\n  type     NotificationType     @default(INFO)\n  priority NotificationPriority @default(MEDIUM)\n\n  // Estado de leitura\n  isRead Boolean   @default(false)\n  readAt DateTime?\n\n  // Entrega e canais\n  channel       NotificationChannel @default(IN_APP)\n  sentAt        DateTime?\n  deliveredAt   DateTime?\n  deliveryError String?\n\n  // Expira\xE7\xE3o e a\xE7\xE3o\n  actionUrl String?\n  expiresAt DateTime?\n  data      Json? // dados adicionais (ex: { productId, movementId, severity })\n\n  // Auditoria e controle\n  deletedAt DateTime?\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n\n  // \xCDndices\n  @@index([userId])\n  @@index([storeId])\n  @@index([type])\n  @@index([isRead])\n  @@index([priority])\n  @@index([createdAt])\n  @@map("notifications")\n}\n\nenum NotificationType {\n  INFO // Informa\xE7\xE3o geral\n  SUCCESS // Sucesso/confirma\xE7\xE3o\n  WARNING // Aviso ou aten\xE7\xE3o\n  ERROR // Erro ou falha\n  STOCK_ALERT // Alerta de estoque baixo\n  MOVEMENT // Movimenta\xE7\xE3o de estoque\n  PERMISSION // Permiss\xE3o / acesso\n  SYSTEM // Sistema / manuten\xE7\xE3o\n  BILLING // Assinatura, cobran\xE7a, pagamento\n  WORKFLOW // Fluxo automatizado\n}\n\nenum NotificationPriority {\n  LOW\n  MEDIUM\n  HIGH\n  URGENT\n}\n\nenum NotificationChannel {\n  IN_APP // Notifica\xE7\xE3o interna do app\n  PUSH // Push Notification\n  EMAIL // E-mail\n  SMS // SMS\n  SYSTEM // Notifica\xE7\xE3o do sistema\n}\n\n// ========== audit.prisma ==========\n/// ===============================\n///  AUDIT LOG STRUCTURE\n///  - Rastreia todas as a\xE7\xF5es importantes do sistema.\n///  - Cada log registra o que mudou, quem fez e onde.\n///  - Base para auditorias, relat\xF3rios e seguran\xE7a.\n/// ===============================\n\nmodel AuditLog {\n  id String @id @default(cuid())\n\n  // Entidade e a\xE7\xE3o auditada\n  entity   AuditEntity\n  entityId String?\n  action   AuditAction\n\n  // Contexto e origem\n  userId    String?\n  user      User?   @relation(fields: [userId], references: [id], onDelete: SetNull)\n  storeId   String? // para rastrear logs por loja\n  store     Store?  @relation(fields: [storeId], references: [id], onDelete: SetNull)\n  ipAddress String? // IP de origem da a\xE7\xE3o\n  userAgent String? // navegador / dispositivo\n  source    String? // origem da a\xE7\xE3o: "web", "mobile", "api", "system"\n\n  // Dados de mudan\xE7a\n  before   Json? // estado anterior do registro\n  after    Json? // estado ap\xF3s a mudan\xE7a\n  metadata Json? // informa\xE7\xF5es adicionais (ex: rota, payload, headers)\n\n  // Auditoria temporal\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  // \xCDndices e otimiza\xE7\xE3o\n  @@index([entity])\n  @@index([storeId])\n  @@index([userId])\n  @@index([action])\n  @@index([createdAt])\n  @@map("audit_logs")\n}\n\nenum AuditAction {\n  CREATE\n  UPDATE\n  DELETE\n  LOGIN\n  LOGOUT\n  VERIFY\n  RESTORE\n}\n\nenum AuditEntity {\n  USER\n  STORE\n  PRODUCT\n  SUPPLIER\n  MOVEMENT\n  CATEGORY\n  QUOTE\n  FLOW\n  SYSTEM\n}\n\n// ========== media.prisma ==========\n/// ===============================\n///  MEDIA STRUCTURE\n///  - Representa qualquer arquivo enviado (imagem, v\xEDdeo, documento).\n///  - Associ\xE1vel a produto, fornecedor, loja ou usu\xE1rio.\n///  - Cont\xE9m informa\xE7\xF5es t\xE9cnicas e de origem.\n/// ===============================\n\nmodel Media {\n  id String @id @default(cuid())\n\n  // Identifica\xE7\xE3o b\xE1sica\n  url       String // link p\xFAblico (Cloudinary, S3, Supabase, etc.)\n  name      String? // nome do arquivo original\n  type      String? // MIME type (ex: image/png, application/pdf)\n  extension String? // extens\xE3o (ex: jpg, pdf)\n  size      Int? // tamanho em bytes\n  hash      String? // hash opcional (para evitar duplica\xE7\xF5es)\n\n  // Origem e propriedade\n  storeId      String?\n  store        Store?  @relation(fields: [storeId], references: [id], onDelete: SetNull)\n  uploadedById String?\n  uploadedBy   User?   @relation(fields: [uploadedById], references: [id], onDelete: SetNull)\n\n  // Armazenamento e provider\n  provider    StorageProvider @default(SYSTEM)\n  storagePath String? // caminho interno no provider (ex: /products/uuid.png)\n  bucket      String? // bucket do S3 / Supabase\n  visibility  MediaVisibility @default(PRIVATE) // controle de acesso\n  status      MediaStatus     @default(ACTIVE)\n\n  // Metadados\n  metadata Json? // ex: { width, height, tags, detectedLabels, thumbnailUrl }\n\n  // Auditoria\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n  deletedAt DateTime?\n\n  // Rela\xE7\xF5es\n  productMedia  ProductMedia[]\n  supplierMedia SupplierMedia[]\n  userMedia     UserMedia[]\n  storeMedia    StoreMedia[]\n\n  // \xCDndices\n  @@index([storeId])\n  @@index([uploadedById])\n  @@index([status])\n  @@index([visibility])\n  @@index([deletedAt])\n  @@map("media")\n}\n\n/// ===============================\n///  RELATION TABLES (many-to-many)\n///  - Permitem anexar m\xFAltiplos arquivos a produtos, usu\xE1rios, etc.\n/// ===============================\n\nmodel ProductMedia {\n  id        String  @id @default(cuid())\n  productId String\n  mediaId   String\n  isPrimary Boolean @default(false)\n  altText   String? // descri\xE7\xE3o alternativa para SEO / acessibilidade\n  sortOrder Int     @default(0)\n\n  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)\n  media   Media   @relation(fields: [mediaId], references: [id], onDelete: Cascade)\n\n  @@unique([productId, mediaId])\n  @@index([productId])\n  @@map("product_media")\n}\n\nmodel SupplierMedia {\n  id         String @id @default(cuid())\n  supplierId String\n  mediaId    String\n\n  supplier Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)\n  media    Media    @relation(fields: [mediaId], references: [id], onDelete: Cascade)\n\n  @@unique([supplierId, mediaId])\n  @@map("supplier_media")\n}\n\nmodel UserMedia {\n  id      String @id @default(cuid())\n  userId  String\n  mediaId String\n\n  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)\n  media Media @relation(fields: [mediaId], references: [id], onDelete: Cascade)\n\n  @@unique([userId, mediaId])\n  @@map("user_media")\n}\n\nmodel StoreMedia {\n  id      String @id @default(cuid())\n  storeId String\n  mediaId String\n\n  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)\n  media Media @relation(fields: [mediaId], references: [id], onDelete: Cascade)\n\n  @@unique([storeId, mediaId])\n  @@map("store_media")\n}\n\n/// ===============================\n///  ENUMS\n/// ===============================\n\nenum StorageProvider {\n  SYSTEM // Armazenamento local padr\xE3o\n  S3 // Amazon S3 / R2 / Wasabi\n  SUPABASE // Supabase Storage\n  CLOUDINARY // Cloudinary\n  GOOGLE_DRIVE // Google Drive API\n}\n\nenum MediaVisibility {\n  PRIVATE // vis\xEDvel apenas internamente\n  PUBLIC // acess\xEDvel publicamente\n  RESTRICTED // acess\xEDvel sob regra (ex: usu\xE1rios logados)\n}\n\nenum MediaStatus {\n  ACTIVE\n  ARCHIVED\n  DELETED\n  PROCESSING\n}\n\n// ========== roadmap.prisma ==========\n/// ===============================\n///  ROADMAP STRUCTURE\n///  - Representa planos, metas ou projetos.\n///  - Pode estar associado a uma loja ou usu\xE1rio.\n///  - Cont\xE9m milestones (etapas com progresso e status).\n/// ===============================\n\nmodel Roadmap {\n  id String @id @default(cuid())\n\n  // Associa\xE7\xE3o\n  storeId String?\n  store   Store?  @relation(fields: [storeId], references: [id], onDelete: Cascade)\n  userId  String?\n  user    User?   @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  // Identifica\xE7\xE3o e descri\xE7\xE3o\n  title       String\n  description String?\n\n  // Controle e status\n  status     RoadmapStatus     @default(ACTIVE)\n  visibility RoadmapVisibility @default(PRIVATE)\n  priority   RoadmapPriority   @default(MEDIUM)\n  progress   Int               @default(0) // progresso geral (m\xE9dia das milestones)\n  archived   Boolean           @default(false)\n  deletedAt  DateTime? // soft delete\n\n  // Datas\n  startDate DateTime?\n  endDate   DateTime?\n\n  // Auditoria\n  createdById String?\n  updatedById String?\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n\n  // Rela\xE7\xF5es\n  milestones Milestone[]\n\n  // Metadados\n  tags     Json? // ex: ["estoque", "IA", "meta de venda"]\n  metadata Json? // configura\xE7\xF5es extras ou IA\n\n  // \xCDndices\n  @@index([storeId])\n  @@index([userId])\n  @@index([status])\n  @@index([archived])\n  @@index([deletedAt])\n  @@index([createdAt])\n  @@map("roadmaps")\n}\n\n/// ===============================\n///  MILESTONE STRUCTURE\n///  - Etapas dentro de um roadmap.\n///  - Controla progresso, status e prazos.\n/// ===============================\n\nmodel Milestone {\n  id        String  @id @default(cuid())\n  roadmapId String\n  roadmap   Roadmap @relation(fields: [roadmapId], references: [id], onDelete: Cascade)\n\n  // Identifica\xE7\xE3o\n  title       String\n  description String?\n\n  // Controle\n  status      MilestoneStatus @default(PENDING)\n  progress    Int             @default(0) // % conclu\xEDda (0\u2013100)\n  order       Int             @default(0) // posi\xE7\xE3o na timeline\n  priority    RoadmapPriority @default(MEDIUM)\n  blockedById String? // milestone dependente (opcional)\n  blockedBy   Milestone?      @relation("MilestoneDependency", fields: [blockedById], references: [id])\n  blocking    Milestone[]     @relation("MilestoneDependency") // milestones bloqueados por este\n\n  // Datas\n  startDate   DateTime?\n  endDate     DateTime?\n  completedAt DateTime?\n\n  // Auditoria\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n  deletedAt DateTime?\n\n  // Metadados\n  metadata Json? // informa\xE7\xF5es adicionais ou IA\n\n  // \xCDndices\n  @@index([roadmapId])\n  @@index([status])\n  @@index([priority])\n  @@index([order])\n  @@map("milestones")\n}\n\nenum RoadmapStatus {\n  ACTIVE\n  COMPLETED\n  ARCHIVED\n}\n\nenum RoadmapVisibility {\n  PRIVATE\n  PUBLIC\n  INTERNAL\n}\n\nenum RoadmapPriority {\n  LOW\n  MEDIUM\n  HIGH\n  CRITICAL\n}\n\nenum MilestoneStatus {\n  PENDING\n  IN_PROGRESS\n  COMPLETED\n  BLOCKED\n}\n\n// ========== crm.prisma ==========\n/// ===============================\n///  CRM STAGE STRUCTURE\n///  - Etapa (coluna) do pipeline de CRM.\n///  - Cada loja possui seu pr\xF3prio conjunto de etapas.\n/// ===============================\n\nmodel CrmStage {\n  id          String   @id @default(cuid())\n  storeId     String\n  name        String\n  color       String? // cor no front-end\n  order       Int      @default(0) // posi\xE7\xE3o na ordem do pipeline\n  description String? // ex: "Clientes interessados"\n  isDefault   Boolean  @default(false) // primeira etapa padr\xE3o\n  isFinal     Boolean  @default(false) // etapa de fechamento (ganho/perda)\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n\n  store   Store       @relation(fields: [storeId], references: [id], onDelete: Cascade)\n  clients CrmClient[]\n\n  @@unique([storeId, name])\n  @@index([storeId])\n  @@index([order])\n  @@map("crm_stages")\n}\n\n/// ===============================\n///  CRM CLIENT STRUCTURE\n///  - Representa um cliente / lead dentro do pipeline.\n///  - Pode se mover entre etapas (Kanban).\n/// ===============================\n\nmodel CrmClient {\n  id              String          @id @default(cuid())\n  storeId         String\n  stageId         String?\n  name            String\n  email           String?\n  phone           String?\n  cpfCnpj         String?\n  company         String?\n  position        String? // cargo (ex: comprador, gerente)\n  source          String? // origem do lead (ex: site, whatsapp, indica\xE7\xE3o)\n  status          CrmClientStatus @default(ACTIVE)\n  tags            Json? // ex: ["venda recorrente", "novo cliente"]\n  notes           String?\n  lastContactAt   DateTime?\n  nextContactAt   DateTime?\n  lastInteraction Json? // ex: { type: "call", date: "2025-10-31", userId: "..." }\n  ownerId         String? // respons\xE1vel pelo cliente\n  owner           User?           @relation(fields: [ownerId], references: [id], onDelete: SetNull)\n  archivedAt      DateTime? // lead arquivado\n  deletedAt       DateTime? // soft delete\n  createdAt       DateTime        @default(now())\n  updatedAt       DateTime        @updatedAt\n\n  store Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)\n  stage CrmStage? @relation(fields: [stageId], references: [id], onDelete: SetNull)\n\n  @@index([storeId])\n  @@index([stageId])\n  @@index([ownerId])\n  @@index([status])\n  @@index([archivedAt])\n  @@map("crm_clients")\n}\n\n/// ===============================\n///  ENUMS\n/// ===============================\n\nenum CrmClientStatus {\n  ACTIVE // Lead ativo no pipeline\n  WON // Neg\xF3cio fechado com sucesso\n  LOST // Neg\xF3cio perdido\n  INACTIVE // Cliente desativado\n  ARCHIVED // Lead arquivado manualmente\n}\n\n// ========== flow.prisma ==========\n/// ===============================\n///  FLOW AUTOMATION STRUCTURE\n///  - Sistema de automa\xE7\xE3o baseado em nodes.\n///  - Cada flow pertence a uma loja e a um usu\xE1rio.\n///  - Pode conter triggers, conditions, actions e notifications.\n///  - Base para IA, notifica\xE7\xF5es autom\xE1ticas e rotinas.\n/// ===============================\n\nmodel Flow {\n  id String @id @default(cuid())\n\n  // Identifica\xE7\xE3o\n  name        String\n  description String?\n  version     Int     @default(1) // para controle de vers\xF5es\n  category    String? // ex: "notifica\xE7\xE3o", "estoque", "CRM"\n\n  // Estrutura do workflow (ReactFlow)\n  nodes    Json // array de nodes\n  edges    Json // conex\xF5es entre nodes\n  metadata Json? // metadados do flow (layout, vari\xE1veis globais, etc.)\n\n  // Controle de status\n  status    FlowStatus @default(DRAFT)\n  isPublic  Boolean    @default(false)\n  deletedAt DateTime? // soft delete\n\n  // Associa\xE7\xE3o\n  storeId   String\n  store     Store  @relation(fields: [storeId], references: [id], onDelete: Cascade)\n  createdBy String\n  creator   User   @relation(fields: [createdBy], references: [id], onDelete: Cascade)\n\n  // Auditoria\n  createdAt  DateTime             @default(now())\n  updatedAt  DateTime             @updatedAt\n  lastRunAt  DateTime?\n  lastStatus FlowExecutionStatus?\n\n  // Rela\xE7\xF5es\n  flowNodes  FlowNode[]\n  executions FlowExecution[]\n\n  // \xCDndices\n  @@index([storeId])\n  @@index([status])\n  @@index([deletedAt])\n  @@index([createdAt])\n  @@map("flows")\n}\n\nmodel FlowNode {\n  id           String       @id @default(cuid())\n  flowId       String\n  nodeId       String // ID do node (ReactFlow ID)\n  type         FlowNodeType\n  name         String? // nome vis\xEDvel no editor\n  config       Json // configura\xE7\xE3o do node (ex: { "trigger": "stock_low" })\n  order        Int          @default(0)\n  parentNodeId String? // para nodes agrupados\n  position     Json? // posi\xE7\xE3o no editor (x, y)\n  metadata     Json? // metadados adicionais\n\n  // Auditoria\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  flow Flow @relation(fields: [flowId], references: [id], onDelete: Cascade)\n\n  @@unique([flowId, nodeId])\n  @@index([type])\n  @@index([order])\n  @@map("flow_nodes")\n}\n\nmodel FlowExecution {\n  id     String @id @default(cuid())\n  flowId String\n  flow   Flow   @relation(fields: [flowId], references: [id], onDelete: Cascade)\n\n  // Execu\xE7\xE3o\n  status       FlowExecutionStatus @default(RUNNING)\n  triggerType  String // ex: "stock_alert", "manual", "schedule"\n  triggerData  Json // payload do evento disparador\n  context      Json? // contexto adicional (ex: { "productId": "...", "userId": "..." })\n  executionLog Json? // logs detalhados (por node)\n  error        String?\n  durationMs   Int? // dura\xE7\xE3o total\n  startedAt    DateTime            @default(now())\n  completedAt  DateTime?\n\n  // Auditoria\n  executedById String?\n  executedBy   User?   @relation(fields: [executedById], references: [id], onDelete: SetNull)\n  storeId      String?\n  store        Store?  @relation(fields: [storeId], references: [id], onDelete: SetNull)\n\n  @@index([flowId])\n  @@index([status])\n  @@index([startedAt])\n  @@index([storeId])\n  @@map("flow_executions")\n}\n\n/// ===============================\n///  ENUMS\n/// ===============================\n\nenum FlowStatus {\n  ACTIVE\n  INACTIVE\n  DRAFT\n}\n\nenum FlowNodeType {\n  TRIGGER\n  CONDITION\n  ACTION\n  NOTIFICATION\n}\n\nenum FlowExecutionStatus {\n  SUCCESS\n  FAILED\n  RUNNING\n  CANCELLED\n}\n\n// ========== chat.prisma ==========\n/// ===============================\n///  CHAT FEATURE (AI ASSISTANT)\n///  - Sistema de chat com IA integrado ao 25Stock.\n///  - Cada sess\xE3o pertence a um usu\xE1rio (e opcionalmente a uma loja).\n///  - Permite m\xFAltiplas sess\xF5es simult\xE2neas.\n/// ===============================\n\nmodel ChatSession {\n  id          String    @id @default(cuid())\n  userId      String\n  storeId     String?\n  title       String? // t\xEDtulo exibido no hist\xF3rico (ex: "Reajuste de pre\xE7os")\n  model       String? // modelo usado (ex: gpt-4-turbo)\n  temperature Float? // temperatura padr\xE3o da sess\xE3o\n  context     Json? // contexto global da sess\xE3o (loja, user, hist\xF3rico)\n  metadata    Json? // dados adicionais (ex: tags, origem)\n  active      Boolean   @default(true)\n  isPinned    Boolean   @default(false) // fixado no topo\n  deletedAt   DateTime? // soft delete\n\n  createdAt      DateTime  @default(now())\n  updatedAt      DateTime  @updatedAt\n  lastActivityAt DateTime? // \xFAltima mensagem trocada\n\n  // Rela\xE7\xF5es\n  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  store    Store?        @relation(fields: [storeId], references: [id], onDelete: SetNull)\n  messages ChatMessage[]\n\n  @@index([userId])\n  @@index([storeId])\n  @@index([createdAt])\n  @@index([deletedAt])\n  @@map("chat_sessions")\n}\n\n/// ===============================\n///  CHAT MESSAGE\n///  - Cada mensagem trocada (usu\xE1rio \u2194 IA)\n/// ===============================\n\nmodel ChatMessage {\n  id        String          @id @default(cuid())\n  sessionId String\n  role      ChatMessageRole @default(USER)\n  content   String\n  tokens    Int? // n\xFAmero de tokens consumidos\n  model     String? // modelo usado nessa resposta (pode mudar)\n  context   Json? // contexto adicional (dados da loja, produto, etc.)\n  options   Json? // par\xE2metros de gera\xE7\xE3o (temperature, top_p, etc.)\n  error     String? // erro da gera\xE7\xE3o (se houver)\n  cost      Decimal?        @db.Decimal(10, 4) // custo da requisi\xE7\xE3o\n  latencyMs Int? // dura\xE7\xE3o da requisi\xE7\xE3o\n  isFinal   Boolean         @default(false) // resposta finalizada\n  createdAt DateTime        @default(now())\n  updatedAt DateTime        @updatedAt\n\n  session ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)\n\n  @@index([sessionId])\n  @@index([role])\n  @@index([createdAt])\n  @@map("chat_messages")\n}\n\n/// ===============================\n///  ENUMS\n/// ===============================\n\nenum ChatMessageRole {\n  USER // Usu\xE1rio humano\n  ASSISTANT // Resposta da IA\n  SYSTEM // Mensagem de sistema ou contexto\n  TOOL // Execu\xE7\xE3o de ferramenta (ex: busca, a\xE7\xE3o)\n}\n',
      "inlineSchemaHash": "af5e5d601a9d3c66d82a3a2b9c8496857ae5f51f95e70ab26427db6ea9945f44",
      "copyEngine": true
    };
    var fs3 = require("fs");
    config.dirname = __dirname;
    if (!fs3.existsSync(path4.join(__dirname, "schema.prisma"))) {
      const alternativePaths = [
        "src/generated/prisma",
        "generated/prisma"
      ];
      const alternativePath = alternativePaths.find((altPath) => {
        return fs3.existsSync(path4.join(process.cwd(), altPath, "schema.prisma"));
      }) ?? alternativePaths[0];
      config.dirname = path4.join(process.cwd(), alternativePath);
      config.isBundled = true;
    }
    config.runtimeDataModel = JSON.parse('{"models":{"User":{"dbName":"users","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreToUser","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"isOwner","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedBy","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserDeleted","relationFromFields":["deletedById"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"suspendedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"invitedById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"invitedBy","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserInviter","relationFromFields":["invitedById"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"acceptedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"inviteCode","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"pendingInvitation","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"ownedStore","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreOwner","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"lastLoginAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastActiveAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emailVerified","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"emailVerificationToken","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emailVerificationCode","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"emailVerificationCodeExpires","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"resetPasswordToken","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"resetPasswordExpires","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"permissions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserPermission","nativeType":null,"relationName":"UserToUserPermission","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"preferences","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserPreferences","nativeType":null,"relationName":"UserToUserPreferences","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"notifications","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Notification","nativeType":null,"relationName":"NotificationToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserMedia","nativeType":null,"relationName":"UserToUserMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"uploadedMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"quotes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Quote","nativeType":null,"relationName":"QuoteToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"subscription","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Subscription","nativeType":null,"relationName":"SubscriptionToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"auditLogs","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"AuditLog","nativeType":null,"relationName":"AuditLogToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"movements","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Movement","nativeType":null,"relationName":"MovementToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"roadmaps","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Roadmap","nativeType":null,"relationName":"RoadmapToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"createdFlows","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Flow","nativeType":null,"relationName":"FlowToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"flowExecutions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"FlowExecution","nativeType":null,"relationName":"FlowExecutionToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"crmClients","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmClient","nativeType":null,"relationName":"CrmClientToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"chatSessions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ChatSession","nativeType":null,"relationName":"ChatSessionToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"invitedUsers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserInviter","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"deletedUsers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserDeleted","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"UserPermission":{"dbName":"user_permissions","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserToUserPermission","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"action","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"resource","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"scope","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"grant","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"conditions","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[["userId","action","resource"]],"uniqueIndexes":[{"name":null,"fields":["userId","action","resource"]}],"isGenerated":false},"UserPreferences":{"dbName":"user_preferences","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserToUserPreferences","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"theme","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"light","isGenerated":false,"isUpdatedAt":false},{"name":"primaryColor","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"sidebarCollapsed","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"compactMode","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"uiScale","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Float","nativeType":null,"default":1,"isGenerated":false,"isUpdatedAt":false},{"name":"language","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"pt-BR","isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"timezone","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"America/Sao_Paulo","isGenerated":false,"isUpdatedAt":false},{"name":"dateFormat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"DD/MM/YYYY","isGenerated":false,"isUpdatedAt":false},{"name":"timeFormat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"24h","isGenerated":false,"isUpdatedAt":false},{"name":"numberFormat","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"pt-BR","isGenerated":false,"isUpdatedAt":false},{"name":"emailNotifications","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"pushNotifications","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"smsNotifications","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"notificationTypes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"dashboardLayout","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"defaultPage","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"itemsPerPage","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":20,"isGenerated":false,"isUpdatedAt":false},{"name":"autoRefresh","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"refreshInterval","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":30,"isGenerated":false,"isUpdatedAt":false},{"name":"customSettings","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"aiAssistantSettings","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Store":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"ownerId","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"owner","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"StoreOwner","relationFromFields":["ownerId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cnpj","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"logoUrl","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"website","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cep","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"city","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"state","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"suspendedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"plan","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"timezone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"America/Sao_Paulo","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"users","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"StoreToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"categories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Category","nativeType":null,"relationName":"CategoryToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"suppliers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"StoreToSupplier","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"movements","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Movement","nativeType":null,"relationName":"MovementToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StoreMedia","nativeType":null,"relationName":"StoreToStoreMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"uploadedMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"roadmaps","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Roadmap","nativeType":null,"relationName":"RoadmapToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"crmStages","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmStage","nativeType":null,"relationName":"CrmStageToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"crmClients","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmClient","nativeType":null,"relationName":"CrmClientToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"flows","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Flow","nativeType":null,"relationName":"FlowToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"flowExecutions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"FlowExecution","nativeType":null,"relationName":"FlowExecutionToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"auditLogs","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"AuditLog","nativeType":null,"relationName":"AuditLogToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"notifications","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Notification","nativeType":null,"relationName":"NotificationToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"quotes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Quote","nativeType":null,"relationName":"QuoteToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"chatSessions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ChatSession","nativeType":null,"relationName":"ChatSessionToStore","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"settings","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Product":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"sku","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"barcode","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"referenceCode","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"unitOfMeasure","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UnitOfMeasure","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"referencePrice","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"costPrice","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"markupPercent","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["5","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"stockCurrent","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"stockMin","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"stockMax","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"alertPercentage","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":["SmallInt",[]],"default":20,"isGenerated":false,"isUpdatedAt":false},{"name":"allowNegative","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"batchTracked","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"expirationDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"supplierId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"ProductToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"supplier","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"ProductToSupplier","relationFromFields":["supplierId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"movements","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Movement","nativeType":null,"relationName":"MovementToProduct","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"categories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductCategory","nativeType":null,"relationName":"ProductToProductCategory","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductMedia","nativeType":null,"relationName":"ProductToProductMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"quotes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"QuoteItem","nativeType":null,"relationName":"ProductToQuoteItem","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Category":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"code","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"color","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"icon","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"parentId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"parent","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Category","nativeType":null,"relationName":"CategoryHierarchy","relationFromFields":["parentId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"children","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Category","nativeType":null,"relationName":"CategoryHierarchy","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"CategoryToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductCategory","nativeType":null,"relationName":"CategoryToProductCategory","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["code","storeId"]],"uniqueIndexes":[{"name":null,"fields":["code","storeId"]}],"isGenerated":false},"ProductCategory":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"categoryId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToProductCategory","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"category","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Category","nativeType":null,"relationName":"CategoryToProductCategory","relationFromFields":["categoryId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["productId","categoryId"]],"uniqueIndexes":[{"name":null,"fields":["productId","categoryId"]}],"isGenerated":false},"Supplier":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"corporateName","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"tradeName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cnpj","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"ie","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"website","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cep","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"city","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"state","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"address","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"complement","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreToSupplier","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"products","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToSupplier","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"movements","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Movement","nativeType":null,"relationName":"MovementToSupplier","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"responsibles","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SupplierResponsible","nativeType":null,"relationName":"SupplierToSupplierResponsible","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SupplierMedia","nativeType":null,"relationName":"SupplierToSupplierMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["cnpj","storeId"]],"uniqueIndexes":[{"name":null,"fields":["cnpj","storeId"]}],"isGenerated":false},"SupplierResponsible":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"supplierId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"supplier","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"SupplierToSupplierResponsible","relationFromFields":["supplierId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cpf","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"whatsapp","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"mainContact","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"notes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Movement":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MovementType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"origin","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MovementOrigin","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"referenceCode","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"note","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"price","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"totalValue","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"balanceBefore","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"balanceAfter","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"batch","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiration","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"MovementToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"MovementToProduct","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"supplierId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"supplier","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"MovementToSupplier","relationFromFields":["supplierId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"MovementToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"verified","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"verifiedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"verifiedBy","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"verificationNote","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelled","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelledAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelledBy","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancellationReason","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Subscription":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"SubscriptionToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"polarCustomerId","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"polarSubscriptionId","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"polarProductId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"polarPlanName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"SubscriptionStatus","nativeType":null,"default":"ACTIVE","isGenerated":false,"isUpdatedAt":false},{"name":"currentPeriodEnd","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"trialEndsAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cancelledAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"renewalCount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"priceAmount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"priceInterval","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PlanInterval","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"invoices","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Invoice","nativeType":null,"relationName":"InvoiceToSubscription","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Invoice":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"subscriptionId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"subscription","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Subscription","nativeType":null,"relationName":"InvoiceToSubscription","relationFromFields":["subscriptionId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"polarInvoiceId","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"InvoiceStatus","nativeType":null,"default":"PENDING","isGenerated":false,"isUpdatedAt":false},{"name":"paymentDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"dueDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Quote":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"QuoteToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"QuoteToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"customerId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"customerName","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"publicId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"authCode","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"QuoteStatus","nativeType":null,"default":"DRAFT","isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"viewedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"approvedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"rejectedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"convertedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"canceledAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"approvalNote","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"ipAddress","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"viewedBy","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"subtotal","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"discount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"interest","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"total","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"currency","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":"BRL","isGenerated":false,"isUpdatedAt":false},{"name":"paymentType","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"PaymentType","nativeType":null,"default":"UNDEFINED","isGenerated":false,"isUpdatedAt":false},{"name":"paymentTerms","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentDueDays","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"observations","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"notesInternal","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"items","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"QuoteItem","nativeType":null,"relationName":"QuoteToQuoteItem","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"installments","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"QuoteInstallment","nativeType":null,"relationName":"QuoteToQuoteInstallment","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"QuoteItem":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"quoteId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"unitPrice","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"subtotal","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"discount","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"note","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quote","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Quote","nativeType":null,"relationName":"QuoteToQuoteItem","relationFromFields":["quoteId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToQuoteItem","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["quoteId","productId"]],"uniqueIndexes":[{"name":null,"fields":["quoteId","productId"]}],"isGenerated":false},"QuoteInstallment":{"dbName":"quote_installments","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"quoteId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"number","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"dueDate","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"amount","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"interest","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","2"]],"isGenerated":false,"isUpdatedAt":false},{"name":"paidAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"quote","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Quote","nativeType":null,"relationName":"QuoteToQuoteInstallment","relationFromFields":["quoteId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Notification":{"dbName":"notifications","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"NotificationToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"NotificationToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"message","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"NotificationType","nativeType":null,"default":"INFO","isGenerated":false,"isUpdatedAt":false},{"name":"priority","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"NotificationPriority","nativeType":null,"default":"MEDIUM","isGenerated":false,"isUpdatedAt":false},{"name":"isRead","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"readAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"channel","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"NotificationChannel","nativeType":null,"default":"IN_APP","isGenerated":false,"isUpdatedAt":false},{"name":"sentAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deliveredAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deliveryError","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"actionUrl","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"expiresAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"data","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"AuditLog":{"dbName":"audit_logs","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"entity","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"AuditEntity","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"entityId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"action","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"AuditAction","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"AuditLogToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"AuditLogToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"ipAddress","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"userAgent","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"source","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"before","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"after","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Media":{"dbName":"media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"url","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"extension","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"size","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"hash","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"MediaToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"uploadedById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"uploadedBy","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"MediaToUser","relationFromFields":["uploadedById"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"StorageProvider","nativeType":null,"default":"SYSTEM","isGenerated":false,"isUpdatedAt":false},{"name":"storagePath","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"bucket","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"visibility","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"MediaVisibility","nativeType":null,"default":"PRIVATE","isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"MediaStatus","nativeType":null,"default":"ACTIVE","isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ProductMedia","nativeType":null,"relationName":"MediaToProductMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"supplierMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SupplierMedia","nativeType":null,"relationName":"MediaToSupplierMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"userMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"UserMedia","nativeType":null,"relationName":"MediaToUserMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"storeMedia","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"StoreMedia","nativeType":null,"relationName":"MediaToStoreMedia","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ProductMedia":{"dbName":"product_media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mediaId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isPrimary","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"altText","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"sortOrder","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"ProductToProductMedia","relationFromFields":["productId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToProductMedia","relationFromFields":["mediaId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["productId","mediaId"]],"uniqueIndexes":[{"name":null,"fields":["productId","mediaId"]}],"isGenerated":false},"SupplierMedia":{"dbName":"supplier_media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"supplierId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mediaId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"supplier","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Supplier","nativeType":null,"relationName":"SupplierToSupplierMedia","relationFromFields":["supplierId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToSupplierMedia","relationFromFields":["mediaId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["supplierId","mediaId"]],"uniqueIndexes":[{"name":null,"fields":["supplierId","mediaId"]}],"isGenerated":false},"UserMedia":{"dbName":"user_media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mediaId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"UserToUserMedia","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToUserMedia","relationFromFields":["mediaId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["userId","mediaId"]],"uniqueIndexes":[{"name":null,"fields":["userId","mediaId"]}],"isGenerated":false},"StoreMedia":{"dbName":"store_media","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"mediaId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"StoreToStoreMedia","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"media","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Media","nativeType":null,"relationName":"MediaToStoreMedia","relationFromFields":["mediaId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["storeId","mediaId"]],"uniqueIndexes":[{"name":null,"fields":["storeId","mediaId"]}],"isGenerated":false},"Roadmap":{"dbName":"roadmaps","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"RoadmapToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"RoadmapToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"RoadmapStatus","nativeType":null,"default":"ACTIVE","isGenerated":false,"isUpdatedAt":false},{"name":"visibility","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"RoadmapVisibility","nativeType":null,"default":"PRIVATE","isGenerated":false,"isUpdatedAt":false},{"name":"priority","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"RoadmapPriority","nativeType":null,"default":"MEDIUM","isGenerated":false,"isUpdatedAt":false},{"name":"progress","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"archived","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"startDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"endDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"updatedById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"milestones","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Milestone","nativeType":null,"relationName":"MilestoneToRoadmap","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Milestone":{"dbName":"milestones","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"roadmapId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"roadmap","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Roadmap","nativeType":null,"relationName":"MilestoneToRoadmap","relationFromFields":["roadmapId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"MilestoneStatus","nativeType":null,"default":"PENDING","isGenerated":false,"isUpdatedAt":false},{"name":"progress","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"order","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"priority","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"RoadmapPriority","nativeType":null,"default":"MEDIUM","isGenerated":false,"isUpdatedAt":false},{"name":"blockedById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"blockedBy","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Milestone","nativeType":null,"relationName":"MilestoneDependency","relationFromFields":["blockedById"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"blocking","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Milestone","nativeType":null,"relationName":"MilestoneDependency","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"startDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"endDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"completedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"CrmStage":{"dbName":"crm_stages","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"color","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"order","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isDefault","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"isFinal","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"CrmStageToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"clients","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmClient","nativeType":null,"relationName":"CrmClientToCrmStage","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["storeId","name"]],"uniqueIndexes":[{"name":null,"fields":["storeId","name"]}],"isGenerated":false},"CrmClient":{"dbName":"crm_clients","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"stageId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cpfCnpj","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"position","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"source","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"CrmClientStatus","nativeType":null,"default":"ACTIVE","isGenerated":false,"isUpdatedAt":false},{"name":"tags","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"notes","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastContactAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"nextContactAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastInteraction","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"ownerId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"owner","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"CrmClientToUser","relationFromFields":["ownerId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"archivedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"CrmClientToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"stage","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CrmStage","nativeType":null,"relationName":"CrmClientToCrmStage","relationFromFields":["stageId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Flow":{"dbName":"flows","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"version","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":1,"isGenerated":false,"isUpdatedAt":false},{"name":"category","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"nodes","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"edges","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"FlowStatus","nativeType":null,"default":"DRAFT","isGenerated":false,"isUpdatedAt":false},{"name":"isPublic","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"FlowToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"createdBy","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"creator","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"FlowToUser","relationFromFields":["createdBy"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"lastRunAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"lastStatus","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"FlowExecutionStatus","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"flowNodes","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"FlowNode","nativeType":null,"relationName":"FlowToFlowNode","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"executions","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"FlowExecution","nativeType":null,"relationName":"FlowToFlowExecution","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"FlowNode":{"dbName":"flow_nodes","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"flowId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"nodeId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"type","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"FlowNodeType","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"config","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"order","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","nativeType":null,"default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"parentNodeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"position","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"flow","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Flow","nativeType":null,"relationName":"FlowToFlowNode","relationFromFields":["flowId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[["flowId","nodeId"]],"uniqueIndexes":[{"name":null,"fields":["flowId","nodeId"]}],"isGenerated":false},"FlowExecution":{"dbName":"flow_executions","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"flowId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"flow","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Flow","nativeType":null,"relationName":"FlowToFlowExecution","relationFromFields":["flowId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"FlowExecutionStatus","nativeType":null,"default":"RUNNING","isGenerated":false,"isUpdatedAt":false},{"name":"triggerType","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"triggerData","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"context","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"executionLog","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"durationMs","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"startedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"completedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"executedById","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"executedBy","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"FlowExecutionToUser","relationFromFields":["executedById"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"FlowExecutionToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ChatSession":{"dbName":"chat_sessions","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"storeId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"model","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"temperature","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"context","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"metadata","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"active","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":true,"isGenerated":false,"isUpdatedAt":false},{"name":"isPinned","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"deletedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"lastActivityAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"ChatSessionToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"store","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Store","nativeType":null,"relationName":"ChatSessionToStore","relationFromFields":["storeId"],"relationToFields":["id"],"relationOnDelete":"SetNull","isGenerated":false,"isUpdatedAt":false},{"name":"messages","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ChatMessage","nativeType":null,"relationName":"ChatMessageToChatSession","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"ChatMessage":{"dbName":"chat_messages","schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"cuid","args":[1]},"isGenerated":false,"isUpdatedAt":false},{"name":"sessionId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"ChatMessageRole","nativeType":null,"default":"USER","isGenerated":false,"isUpdatedAt":false},{"name":"content","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"tokens","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"model","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"context","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"options","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"error","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"cost","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Decimal","nativeType":["Decimal",["10","4"]],"isGenerated":false,"isUpdatedAt":false},{"name":"latencyMs","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"isFinal","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","nativeType":null,"default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"session","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ChatSession","nativeType":null,"relationName":"ChatMessageToChatSession","relationFromFields":["sessionId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{"UnitOfMeasure":{"values":[{"name":"UNIDADE","dbName":null},{"name":"KG","dbName":null},{"name":"L","dbName":null},{"name":"ML","dbName":null},{"name":"M","dbName":null},{"name":"CM","dbName":null},{"name":"MM","dbName":null},{"name":"UN","dbName":null},{"name":"DZ","dbName":null},{"name":"CX","dbName":null},{"name":"PCT","dbName":null},{"name":"KIT","dbName":null},{"name":"PAR","dbName":null},{"name":"H","dbName":null},{"name":"D","dbName":null}],"dbName":null},"MovementType":{"values":[{"name":"INBOUND","dbName":null},{"name":"OUTBOUND","dbName":null},{"name":"LOSS","dbName":null}],"dbName":null},"MovementOrigin":{"values":[{"name":"PURCHASE","dbName":null},{"name":"SALE","dbName":null},{"name":"RETURN","dbName":null},{"name":"SUPPLIER_RETURN","dbName":null},{"name":"ADJUSTMENT","dbName":null},{"name":"TRANSFER","dbName":null},{"name":"INVENTORY","dbName":null},{"name":"DAMAGE","dbName":null},{"name":"EXPIRATION","dbName":null},{"name":"OTHER","dbName":null}],"dbName":null},"SubscriptionStatus":{"values":[{"name":"ACTIVE","dbName":null},{"name":"INACTIVE","dbName":null},{"name":"CANCELLED","dbName":null},{"name":"TRIAL","dbName":null},{"name":"EXPIRED","dbName":null},{"name":"PAST_DUE","dbName":null}],"dbName":null},"PlanInterval":{"values":[{"name":"MONTHLY","dbName":null},{"name":"YEARLY","dbName":null}],"dbName":null},"InvoiceStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"PAID","dbName":null},{"name":"FAILED","dbName":null},{"name":"REFUNDED","dbName":null}],"dbName":null},"PaymentType":{"values":[{"name":"UNDEFINED","dbName":null},{"name":"PIX","dbName":null},{"name":"BOLETO","dbName":null},{"name":"CREDIT_CARD","dbName":null},{"name":"CASH","dbName":null},{"name":"TRANSFER","dbName":null}],"dbName":null},"QuoteStatus":{"values":[{"name":"DRAFT","dbName":null},{"name":"PUBLISHED","dbName":null},{"name":"SENT","dbName":null},{"name":"VIEWED","dbName":null},{"name":"APPROVED","dbName":null},{"name":"REJECTED","dbName":null},{"name":"EXPIRED","dbName":null},{"name":"CONVERTED","dbName":null},{"name":"CANCELED","dbName":null}],"dbName":null},"NotificationType":{"values":[{"name":"INFO","dbName":null},{"name":"SUCCESS","dbName":null},{"name":"WARNING","dbName":null},{"name":"ERROR","dbName":null},{"name":"STOCK_ALERT","dbName":null},{"name":"MOVEMENT","dbName":null},{"name":"PERMISSION","dbName":null},{"name":"SYSTEM","dbName":null},{"name":"BILLING","dbName":null},{"name":"WORKFLOW","dbName":null}],"dbName":null},"NotificationPriority":{"values":[{"name":"LOW","dbName":null},{"name":"MEDIUM","dbName":null},{"name":"HIGH","dbName":null},{"name":"URGENT","dbName":null}],"dbName":null},"NotificationChannel":{"values":[{"name":"IN_APP","dbName":null},{"name":"PUSH","dbName":null},{"name":"EMAIL","dbName":null},{"name":"SMS","dbName":null},{"name":"SYSTEM","dbName":null}],"dbName":null},"AuditAction":{"values":[{"name":"CREATE","dbName":null},{"name":"UPDATE","dbName":null},{"name":"DELETE","dbName":null},{"name":"LOGIN","dbName":null},{"name":"LOGOUT","dbName":null},{"name":"VERIFY","dbName":null},{"name":"RESTORE","dbName":null}],"dbName":null},"AuditEntity":{"values":[{"name":"USER","dbName":null},{"name":"STORE","dbName":null},{"name":"PRODUCT","dbName":null},{"name":"SUPPLIER","dbName":null},{"name":"MOVEMENT","dbName":null},{"name":"CATEGORY","dbName":null},{"name":"QUOTE","dbName":null},{"name":"FLOW","dbName":null},{"name":"SYSTEM","dbName":null}],"dbName":null},"StorageProvider":{"values":[{"name":"SYSTEM","dbName":null},{"name":"S3","dbName":null},{"name":"SUPABASE","dbName":null},{"name":"CLOUDINARY","dbName":null},{"name":"GOOGLE_DRIVE","dbName":null}],"dbName":null},"MediaVisibility":{"values":[{"name":"PRIVATE","dbName":null},{"name":"PUBLIC","dbName":null},{"name":"RESTRICTED","dbName":null}],"dbName":null},"MediaStatus":{"values":[{"name":"ACTIVE","dbName":null},{"name":"ARCHIVED","dbName":null},{"name":"DELETED","dbName":null},{"name":"PROCESSING","dbName":null}],"dbName":null},"RoadmapStatus":{"values":[{"name":"ACTIVE","dbName":null},{"name":"COMPLETED","dbName":null},{"name":"ARCHIVED","dbName":null}],"dbName":null},"RoadmapVisibility":{"values":[{"name":"PRIVATE","dbName":null},{"name":"PUBLIC","dbName":null},{"name":"INTERNAL","dbName":null}],"dbName":null},"RoadmapPriority":{"values":[{"name":"LOW","dbName":null},{"name":"MEDIUM","dbName":null},{"name":"HIGH","dbName":null},{"name":"CRITICAL","dbName":null}],"dbName":null},"MilestoneStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"IN_PROGRESS","dbName":null},{"name":"COMPLETED","dbName":null},{"name":"BLOCKED","dbName":null}],"dbName":null},"CrmClientStatus":{"values":[{"name":"ACTIVE","dbName":null},{"name":"WON","dbName":null},{"name":"LOST","dbName":null},{"name":"INACTIVE","dbName":null},{"name":"ARCHIVED","dbName":null}],"dbName":null},"FlowStatus":{"values":[{"name":"ACTIVE","dbName":null},{"name":"INACTIVE","dbName":null},{"name":"DRAFT","dbName":null}],"dbName":null},"FlowNodeType":{"values":[{"name":"TRIGGER","dbName":null},{"name":"CONDITION","dbName":null},{"name":"ACTION","dbName":null},{"name":"NOTIFICATION","dbName":null}],"dbName":null},"FlowExecutionStatus":{"values":[{"name":"SUCCESS","dbName":null},{"name":"FAILED","dbName":null},{"name":"RUNNING","dbName":null},{"name":"CANCELLED","dbName":null}],"dbName":null},"ChatMessageRole":{"values":[{"name":"USER","dbName":null},{"name":"ASSISTANT","dbName":null},{"name":"SYSTEM","dbName":null},{"name":"TOOL","dbName":null}],"dbName":null}},"types":{}}');
    defineDmmfProperty2(exports2.Prisma, config.runtimeDataModel);
    config.engineWasm = void 0;
    config.compilerWasm = void 0;
    var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
    warnEnvConflicts2({
      rootEnvPath: config.relativeEnvPaths.rootEnvPath && path4.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
      schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path4.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
    });
    var PrismaClient2 = getPrismaClient2(config);
    exports2.PrismaClient = PrismaClient2;
    Object.assign(exports2, Prisma);
    path4.join(__dirname, "query_engine-windows.dll.node");
    path4.join(process.cwd(), "src/generated/prisma/query_engine-windows.dll.node");
    path4.join(__dirname, "schema.prisma");
    path4.join(process.cwd(), "src/generated/prisma/schema.prisma");
  }
});

// src/server.ts
var import_node_path3 = __toESM(require("path"));
var import_cors = __toESM(require("@fastify/cors"));
var import_fastify = __toESM(require("fastify"));

// src/plugins/prisma.ts
var import_prisma = __toESM(require_prisma());
var prisma = new import_prisma.PrismaClient();
var db = prisma;
async function dbPlugin(app) {
  app.decorate("db", db);
  app.addHook("onClose", async () => {
    await db.$disconnect();
  });
}
async function connectDb() {
  try {
    await db.$connect();
  } catch (error) {
    console.error("Falha ao conectar com o banco de dados:", error);
    throw error;
  }
}

// src/plugins/push.ts
var import_web_push = __toESM(require("web-push"));
var vapidKeys = {
  publicKey: process.env.VAPID_PUBLIC_KEY || "",
  privateKey: process.env.VAPID_PRIVATE_KEY || ""
};
if (vapidKeys.publicKey && vapidKeys.privateKey) {
  import_web_push.default.setVapidDetails(
    process.env.VAPID_SUBJECT || "mailto:admin@example.com",
    vapidKeys.publicKey,
    vapidKeys.privateKey
  );
} else {
  console.warn("\u26A0\uFE0F VAPID keys n\xE3o configuradas. Configure VAPID_PUBLIC_KEY e VAPID_PRIVATE_KEY");
}
async function sendPushNotification(subscription2, payload) {
  try {
    const notificationPayload = JSON.stringify({
      title: payload.title,
      body: payload.body,
      icon: payload.icon,
      badge: payload.badge,
      data: payload.data,
      actions: payload.actions
    });
    const result = await import_web_push.default.sendNotification(subscription2, notificationPayload);
    return result;
  } catch (error) {
    if (error.statusCode === 410) {
      throw new Error("Push subscription expired or invalid");
    }
    throw error;
  }
}
var pushPlugin = async (fastify2) => {
  fastify2.decorate(
    "sendPushNotification",
    async (subscription2, payload) => {
      try {
        const notificationPayload = JSON.stringify({
          title: payload.title,
          body: payload.body,
          icon: payload.icon,
          badge: payload.badge,
          data: payload.data,
          actions: payload.actions
        });
        const result = await import_web_push.default.sendNotification(subscription2, notificationPayload);
        fastify2.log.info("Push notification sent successfully");
        return result;
      } catch (error) {
        fastify2.log.error(`Error sending push notification: ${error.message}`);
        if (error.statusCode === 410) {
          fastify2.log.warn("Push subscription expired or invalid");
        }
        throw error;
      }
    }
  );
  fastify2.decorate(
    "sendPushToSubscriptions",
    async (subscriptions, payload) => {
      let success = 0;
      let failed = 0;
      await Promise.allSettled(
        subscriptions.map(async (subscription2) => {
          try {
            await fastify2.sendPushNotification(subscription2, payload);
            success++;
          } catch (error) {
            failed++;
            fastify2.log.error(`Failed to send push notification: ${error.message}`);
          }
        })
      );
      return { success, failed };
    }
  );
  fastify2.decorate("validatePushSubscription", (subscription2) => {
    try {
      return !!(subscription2.endpoint && subscription2.keys && subscription2.keys.p256dh && subscription2.keys.auth);
    } catch {
      return false;
    }
  });
  fastify2.decorate("getVapidPublicKey", () => {
    return vapidKeys.publicKey;
  });
};

// src/utils/bootstrap.ts
var import_node_os = __toESM(require("os"));
var import_chalk = __toESM(require("chalk"));
var import_ora = __toESM(require("ora"));
var BootstrapUI = class {
  constructor() {
    this.spinner = null;
    this.steps = [];
    this.currentStep = 0;
    this.startTime = Date.now();
    this.logMode = false;
    this.logBuffer = [];
    this.maxLogLines = 50;
    this.renderTimeout = null;
    this.originalConsoleLog = null;
    this.originalConsoleError = null;
    this.originalConsoleWarn = null;
    this.originalConsoleInfo = null;
    this.keyListener = null;
    this.fastifyInstance = null;
    this.hooksSetup = false;
    this.requestStartTimes = /* @__PURE__ */ new Map();
    this.colors = {
      primary: import_chalk.default.cyanBright,
      success: import_chalk.default.greenBright,
      error: import_chalk.default.redBright,
      warning: import_chalk.default.yellowBright,
      info: import_chalk.default.blueBright,
      dim: import_chalk.default.dim
    };
  }
  formatTime(ms) {
    if (ms < 1e3) return `${ms}ms`;
    return `${(ms / 1e3).toFixed(2)}s`;
  }
  log(message, type = "info") {
    const icons = {
      info: "\u2139\uFE0F",
      success: "\u2705",
      error: "\u274C",
      warning: "\u26A0\uFE0F"
    };
    const colors = {
      info: this.colors.info,
      success: this.colors.success,
      error: this.colors.error,
      warning: this.colors.warning
    };
    console.log(`${icons[type]} ${colors[type](message)}`);
  }
  async executeStep(step) {
    const startTime = Date.now();
    this.currentStep++;
    const stepLabel = `${this.currentStep}/${this.steps.length}`;
    const prefix = this.colors.dim(`[${stepLabel}]`);
    this.spinner = (0, import_ora.default)({
      text: `${prefix} ${this.colors.primary(step.name)}...`,
      spinner: "dots",
      color: "cyan"
    }).start();
    try {
      await step.action();
      const duration = Date.now() - startTime;
      this.spinner.succeed(
        `${prefix} ${this.colors.success(step.name)} ${this.colors.dim(`(${this.formatTime(duration)})`)}`
      );
      return true;
    } catch (error) {
      const duration = Date.now() - startTime;
      if (step.optional) {
        this.spinner.warn(
          `${prefix} ${this.colors.warning(step.name)} ${this.colors.dim(`(opcional - ${this.formatTime(duration)})`)}`
        );
        return true;
      }
      this.spinner.fail(
        `${prefix} ${this.colors.error(step.name)} ${this.colors.dim(`(${this.formatTime(duration)})`)}`
      );
      this.log(`Erro: ${error.message}`, "error");
      return false;
    } finally {
      this.spinner = null;
    }
  }
  async run(steps) {
    this.steps = steps;
    this.currentStep = 0;
    this.startTime = Date.now();
    console.log("\n");
    console.log(
      this.colors.primary("\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557")
    );
    console.log(
      this.colors.primary("\u2551") + this.colors.info("           Iniciando Servidor Fastify") + this.colors.primary("                      \u2551")
    );
    console.log(
      this.colors.primary("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D")
    );
    console.log("");
    for (const step of steps) {
      const success = await this.executeStep(step);
      if (!success && !step.optional) {
        return false;
      }
    }
    const totalTime = Date.now() - this.startTime;
    console.log("");
    this.log(
      `Colocando o servidor em execu\xE7\xE3o conclu\xEDdo em ${this.formatTime(totalTime)}`,
      "success"
    );
    console.log("");
    return true;
  }
  setupFastifyHooks(fastify2) {
    if (this.hooksSetup) {
      return;
    }
    this.hooksSetup = true;
    this.fastifyInstance = fastify2;
    const requestId = () => `${Date.now()}-${Math.random()}`;
    fastify2.addHook("onRequest", async (request) => {
      const id = requestId();
      request.__logId = id;
      this.requestStartTimes.set(id, Date.now());
      const timestamp = (/* @__PURE__ */ new Date()).toISOString();
      const method = request.method;
      const url = request.url;
      this.addLog(`[${timestamp}] ${method} ${url}`, "info", this.logMode);
    });
    fastify2.addHook("onResponse", async (request, reply) => {
      const id = request.__logId;
      const startTime = this.requestStartTimes.get(id || "");
      if (startTime) {
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        const method = request.method;
        const url = request.url;
        const statusCode = reply.statusCode;
        const responseTime = Date.now() - startTime;
        this.requestStartTimes.delete(id || "");
        this.addLog(
          `[${timestamp}] ${method} ${url} ${statusCode} ${responseTime.toFixed(2)}ms`,
          statusCode >= 400 ? "error" : "info",
          this.logMode
        );
      }
    });
  }
  setupConsoleInterception() {
    if (this.originalConsoleLog !== null) {
      return;
    }
    this.originalConsoleLog = console.log;
    this.originalConsoleError = console.error;
    this.originalConsoleWarn = console.warn;
    this.originalConsoleInfo = console.info;
    console.log = (...args) => {
      const message = args.map((arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)).join(" ");
      this.addLog(message, "log", false);
      if (!this.logMode) {
        this.originalConsoleLog?.apply(console, args);
      }
    };
    console.error = (...args) => {
      const message = args.map((arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)).join(" ");
      this.addLog(message, "error", false);
      if (!this.logMode) {
        this.originalConsoleError?.apply(console, args);
      }
    };
    console.warn = (...args) => {
      const message = args.map((arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)).join(" ");
      this.addLog(message, "warn", false);
      if (!this.logMode) {
        this.originalConsoleWarn?.apply(console, args);
      }
    };
    console.info = (...args) => {
      const message = args.map((arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : String(arg)).join(" ");
      this.addLog(message, "info", false);
      if (!this.logMode) {
        this.originalConsoleInfo?.apply(console, args);
      }
    };
  }
  restoreConsole() {
    if (this.originalConsoleLog) console.log = this.originalConsoleLog;
    if (this.originalConsoleError) console.error = this.originalConsoleError;
    if (this.originalConsoleWarn) console.warn = this.originalConsoleWarn;
    if (this.originalConsoleInfo) console.info = this.originalConsoleInfo;
  }
  addLog(message, type = "log", shouldRender = true) {
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("pt-BR");
    const colors = {
      log: this.colors.info,
      error: this.colors.error,
      warn: this.colors.warning,
      info: this.colors.info
    };
    const coloredMessage = `[${timestamp}] ${colors[type](message)}`;
    this.logBuffer.push(coloredMessage);
    if (this.logBuffer.length > this.maxLogLines) {
      this.logBuffer.shift();
    }
    if (this.logMode && shouldRender) {
      if (this.renderTimeout) {
        clearTimeout(this.renderTimeout);
      }
      this.renderTimeout = setTimeout(() => {
        this.renderLogs();
        this.renderTimeout = null;
      }, 50);
    }
  }
  clearScreen() {
    process.stdout.write("\x1B[2J");
    process.stdout.write("\x1B[0f");
  }
  renderLogs() {
    this.clearScreen();
    console.log("");
    console.log(
      this.colors.primary("\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557")
    );
    console.log(
      `${this.colors.primary("\u2551")}${this.colors.info("              \u{1F4CB} Logs em Tempo Real")}${this.colors.primary("                     \u2551")}`
    );
    console.log(
      this.colors.primary("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563")
    );
    console.log(
      `${this.colors.primary("\u2551")}  ${this.colors.dim("Pressione L para voltar \xE0 visualiza\xE7\xE3o normal")}${this.colors.primary("  \u2551")}`
    );
    console.log(
      this.colors.primary("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563")
    );
    console.log("");
    const logsToShow = this.logBuffer.slice(-this.maxLogLines);
    if (logsToShow.length === 0) {
      console.log(this.colors.dim("  Aguardando logs..."));
    } else {
      for (const log of logsToShow) {
        console.log(`  ${log}`);
      }
    }
    console.log("");
    console.log(
      this.colors.primary("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563")
    );
    console.log(
      `${this.colors.primary("\u2551")}  ${this.colors.dim("Total de logs:")} ${this.colors.info(String(this.logBuffer.length))}${this.colors.primary("                                 \u2551")}`
    );
    console.log(
      this.colors.primary("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D")
    );
  }
  setupKeyboardListener() {
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
      process.stdin.resume();
      process.stdin.setEncoding("utf8");
      this.keyListener = () => {
        process.stdin.on("data", (key) => {
          if (key === "") {
            this.restoreConsole();
            process.exit(0);
          }
          if (key === "l" || key === "L") {
            this.toggleLogMode();
          }
        });
      };
      this.keyListener();
    }
  }
  toggleLogMode() {
    this.logMode = !this.logMode;
    if (this.logMode) {
      if (this.renderTimeout) {
        clearTimeout(this.renderTimeout);
        this.renderTimeout = null;
      }
      this.renderLogs();
    } else {
      if (this.renderTimeout) {
        clearTimeout(this.renderTimeout);
        this.renderTimeout = null;
      }
      this.clearScreen();
      if (this.fastifyInstance) {
        const port = Number(process.env.PORT) || 3e3;
        const host = "0.0.0.0";
        this.showServerInfo(this.fastifyInstance, port, host);
      }
    }
  }
  showServerInfo(fastify2, port, host) {
    this.fastifyInstance = fastify2;
    if (!this.keyListener) {
      this.setupKeyboardListener();
      this.setupConsoleInterception();
    }
    const networkInterfaces = import_node_os.default.networkInterfaces();
    const addresses = [];
    for (const netInterface of Object.values(networkInterfaces)) {
      if (netInterface) {
        for (const iface of netInterface) {
          if (iface.family === "IPv4" && !iface.internal) {
            addresses.push(iface.address);
          }
        }
      }
    }
    const uniqueAddresses = Array.from(new Set(addresses));
    console.log("");
    console.log(
      this.colors.primary("\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557")
    );
    console.log(
      `${this.colors.primary("\u2551")}${this.colors.success("              \u2705 Servidor em Execu\xE7\xE3o")}${this.colors.primary("                      \u2551")}`
    );
    console.log(
      this.colors.primary("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563")
    );
    const localUrl = `http://127.0.0.1:${port}`;
    const localPadding = " ".repeat(Math.max(0, 47 - localUrl.length));
    console.log(
      `${this.colors.primary("\u2551")}  ${this.colors.info("Local:")}    ${this.colors.success(localUrl)}${localPadding}${this.colors.primary("\u2551")}`
    );
    if (host === "0.0.0.0") {
      const networkUrl = `http://${host}:${port}`;
      const networkPadding = " ".repeat(Math.max(0, 47 - networkUrl.length));
      console.log(
        `${this.colors.primary("\u2551")}  ${this.colors.info("Rede:")}     ${this.colors.success(networkUrl)}${networkPadding}${this.colors.primary("\u2551")}`
      );
    }
    for (const addr of uniqueAddresses.slice(0, 3)) {
      const url = `http://${addr}:${port}`;
      const padding = " ".repeat(Math.max(0, 47 - url.length));
      console.log(
        `${this.colors.primary("\u2551")}  ${this.colors.info("Rede:")}     ${this.colors.success(url)}${padding}${this.colors.primary("\u2551")}`
      );
    }
    console.log(
      this.colors.primary("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563")
    );
    const healthUrl = `http://127.0.0.1:${port}/health`;
    const healthPadding = " ".repeat(Math.max(0, 23 - "/health".length));
    console.log(
      `${this.colors.primary("\u2551")}  ${this.colors.dim("Healthcheck:")} ${this.colors.info(healthUrl)}${healthPadding}${this.colors.primary("\u2551")}`
    );
    console.log(
      this.colors.primary("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D")
    );
    console.log("");
    console.log(this.colors.dim("Pressione Ctrl+C para encerrar o servidor"));
    console.log(this.colors.dim("Pressione L para visualizar logs em tempo real"));
    console.log("");
  }
  showError(message, error) {
    console.log("");
    this.log(message, "error");
    if (error) {
      console.log(this.colors.error(error.stack || error.message));
    }
    console.log("");
  }
};
var bootstrapUI = new BootstrapUI();

// src/features/auth/commands/auth.commands.ts
var import_node_crypto = __toESM(require("crypto"));
var import_node_util = require("util");
var import_jsonwebtoken = __toESM(require("jsonwebtoken"));

// src/plugins/polar.ts
var import_sdk = require("@polar-sh/sdk");
var polar = new import_sdk.Polar({
  accessToken: process.env.POLAR_ACCESS_KEY,
  server: "sandbox"
  //"sandbox") as "production" | "sandbox"
});

// src/features/polar/queries/polar.queries.ts
var PolarQueries = {
  async list({ page, limit }) {
    try {
      const { result } = await polar.products.list({
        organizationId: process.env.POLAR_ORGANIZATION_ID,
        page,
        limit
      });
      return {
        items: result.items,
        pagination: {
          page,
          limit
        }
      };
    } catch (error) {
      console.error("Polar products list error:", error);
      throw new Error(`Failed to fetch products: ${error}`);
    }
  },
  async getFreePlan() {
    try {
      const { result } = await polar.products.list({
        organizationId: process.env.POLAR_ORGANIZATION_ID,
        page: 1,
        limit: 10
      });
      console.log(result);
      const freeProduct = result.items.find(
        (product) => product.prices.some((price) => price.amountType === "free")
      );
      return freeProduct || null;
    } catch (error) {
      console.error("Polar get free plan error:", error);
      return null;
    }
  }
};

// src/services/email/email.service.ts
var import_resend = require("resend");

// src/services/email/templates/welcome.ts
var generateWelcomeEmailHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Bem-vindo ao 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F389} Bem-vindo ao 25Stock!</h1>
          <p>Sua conta foi criada com sucesso</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>\xC9 um prazer t\xEA-lo conosco no 25Stock, a plataforma completa para gest\xE3o de estoque.</p>
          <p>Com sua conta, voc\xEA poder\xE1:</p>
          <ul>
            <li>Gerenciar produtos e categorias</li>
            <li>Controlar movimenta\xE7\xF5es de estoque</li>
            <li>Gerar relat\xF3rios detalhados</li>
            <li>Colaborar com sua equipe</li>
            <li>E muito mais!</li>
          </ul>
          <p>Clique no bot\xE3o abaixo para acessar sua conta:</p>
          <a href="${data.loginUrl}" class="button">Acessar Minha Conta</a>
          <p>Se voc\xEA n\xE3o criou esta conta, pode ignorar este email.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
};
var generateWelcomeEmailText = (data) => {
  return `
Bem-vindo ao 25Stock!

Ol\xE1, ${data.name}!

\xC9 um prazer t\xEA-lo conosco no 25Stock, a plataforma completa para gest\xE3o de estoque.

Com sua conta, voc\xEA poder\xE1:
- Gerenciar produtos e categorias
- Controlar movimenta\xE7\xF5es de estoque
- Gerar relat\xF3rios detalhados
- Colaborar com sua equipe
- E muito mais!

Acesse sua conta em: ${data.loginUrl}

Se voc\xEA n\xE3o criou esta conta, pode ignorar este email.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
};

// src/services/email/templates/reset_password.ts
var generatePasswordResetEmailHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Redefini\xE7\xE3o de Senha - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .code-box { background: #fff; border: 2px solid #e74c3c; padding: 20px; text-align: center; border-radius: 10px; margin: 20px 0; }
        .reset-code { font-size: 32px; font-weight: bold; color: #e74c3c; letter-spacing: 5px; margin: 10px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F510} Redefini\xE7\xE3o de Senha</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>Recebemos uma solicita\xE7\xE3o para redefinir a senha da sua conta no 25Stock.</p>
          <p>Use o c\xF3digo abaixo para redefinir sua senha:</p>
          <div class="code-box">
            <p style="margin: 0 0 10px 0; color: #666;">Seu c\xF3digo de redefini\xE7\xE3o:</p>
            <div class="reset-code">${data.resetCode}</div>
          </div>
          <div class="warning">
            <strong>\u26A0\uFE0F Importante:</strong>
            <ul>
              <li>Este c\xF3digo expira em ${data.expiresIn}</li>
              <li>Se voc\xEA n\xE3o solicitou esta redefini\xE7\xE3o, ignore este email</li>
              <li>Sua senha atual continuar\xE1 funcionando at\xE9 ser alterada</li>
              <li>N\xE3o compartilhe este c\xF3digo com ningu\xE9m</li>
            </ul>
          </div>
          <p>Digite este c\xF3digo na tela de redefini\xE7\xE3o de senha do aplicativo.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
};
var generatePasswordResetEmailText = (data) => {
  return `
Redefini\xE7\xE3o de Senha - 25Stock

Ol\xE1, ${data.name}!

Recebemos uma solicita\xE7\xE3o para redefinir a senha da sua conta no 25Stock.

Use o c\xF3digo abaixo para redefinir sua senha:

SEU C\xD3DIGO DE REDEFINI\xC7\xC3O: ${data.resetCode}

IMPORTANTE:
- Este c\xF3digo expira em ${data.expiresIn}
- Se voc\xEA n\xE3o solicitou esta redefini\xE7\xE3o, ignore este email
- Sua senha atual continuar\xE1 funcionando at\xE9 ser alterada
- N\xE3o compartilhe este c\xF3digo com ningu\xE9m

Digite este c\xF3digo na tela de redefini\xE7\xE3o de senha do aplicativo.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
};

// src/services/email/templates/stock_low.ts
var generateStockLowEmailHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${data.title} - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #f39c12; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u26A0\uFE0F ${data.title}</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <div class="warning">
            <strong>\u{1F6A8} Aten\xE7\xE3o:</strong>
            <p>${data.message}</p>
          </div>
          <p>\xC9 recomendado que voc\xEA fa\xE7a um novo pedido para este produto o quanto antes para evitar a falta de estoque.</p>
          ${data.actionUrl ? `<a href="${data.actionUrl}" class="button">${data.actionText || "Ver Produto"}</a>` : ""}
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
};
var generateStockLowEmailText = (data) => {
  return `
${data.title} - 25Stock

Ol\xE1, ${data.name}!

\u{1F6A8} ATEN\xC7\xC3O: ${data.message}

\xC9 recomendado que voc\xEA fa\xE7a um novo pedido para este produto o quanto antes para evitar a falta de estoque.

${data.actionUrl ? `Acesse: ${data.actionUrl}` : ""}

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
};

// src/services/email/templates/notification.ts
var generateNotificationEmailHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${data.title} - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #3498db; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F4E2} ${data.title}</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>${data.message}</p>
          ${data.actionUrl ? `<a href="${data.actionUrl}" class="button">${data.actionText || "Ver Detalhes"}</a>` : ""}
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
};
var generateNotificationEmailText = (data) => {
  return `
${data.title} - 25Stock

Ol\xE1, ${data.name}!

${data.message}

${data.actionUrl ? `Acesse: ${data.actionUrl}` : ""}

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
};

// src/services/email/templates/store_invite.ts
var generateStoreInviteEmailHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Convite para Loja - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .button { display: inline-block; background: #27ae60; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .info { background: #e8f5e8; border: 1px solid #27ae60; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F3EA} Convite para Loja</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p><strong>${data.inviterName}</strong> convidou voc\xEA para colaborar na loja <strong>"${data.storeName}"</strong> no 25Stock.</p>
          <div class="info">
            <strong>\u{1F4CB} Detalhes do Convite:</strong>
            <ul>
              <li><strong>Loja:</strong> ${data.storeName}</li>
              <li><strong>Convidado por:</strong> ${data.inviterName}</li>
              <li><strong>Expira em:</strong> ${data.expiresIn}</li>
            </ul>
          </div>
          <p>Clique no bot\xE3o abaixo para aceitar o convite:</p>
          <a href="${data.acceptUrl}" class="button">Aceitar Convite</a>
          <p>Se voc\xEA n\xE3o conhece esta pessoa ou n\xE3o deseja participar desta loja, pode ignorar este email.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
};
var generateStoreInviteEmailText = (data) => {
  return `
Convite para Loja - 25Stock

Ol\xE1, ${data.name}!

${data.inviterName} convidou voc\xEA para colaborar na loja "${data.storeName}" no 25Stock.

Detalhes do Convite:
- Loja: ${data.storeName}
- Convidado por: ${data.inviterName}
- Expira em: ${data.expiresIn}

Aceite o convite em: ${data.acceptUrl}

Se voc\xEA n\xE3o conhece esta pessoa ou n\xE3o deseja participar desta loja, pode ignorar este email.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
};

// src/services/email/templates/email_verification.ts
var generateEmailVerificationHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Confirma\xE7\xE3o de Email - 25Stock</title>
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
        .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
        .code-container { background: #fff; border: 2px solid #667eea; padding: 20px; border-radius: 10px; text-align: center; margin: 20px 0; }
        .verification-code { font-size: 32px; font-weight: bold; color: #667eea; letter-spacing: 8px; margin: 10px 0; }
        .button { display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; margin: 20px 0; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>\u{1F510} Confirma\xE7\xE3o de Email</h1>
          <p>25Stock - Sistema de Gest\xE3o de Estoque</p>
        </div>
        <div class="content">
          <h2>Ol\xE1, ${data.name}!</h2>
          <p>Bem-vindo ao 25Stock! Para confirmar sua conta, use o c\xF3digo de verifica\xE7\xE3o abaixo:</p>
          
          <div class="code-container">
            <p style="margin: 0 0 10px 0; font-size: 18px; color: #666;">Seu c\xF3digo de verifica\xE7\xE3o \xE9:</p>
            <div class="verification-code">${data.verificationCode}</div>
            <p style="margin: 10px 0 0 0; font-size: 14px; color: #666;">Este c\xF3digo expira em ${data.expiresIn}</p>
          </div>

          <p>Digite este c\xF3digo no aplicativo para confirmar seu email e ativar sua conta.</p>
          
          <div class="warning">
            <strong>\u26A0\uFE0F Importante:</strong>
            <ul>
              <li>Este c\xF3digo \xE9 v\xE1lido por ${data.expiresIn}</li>
              <li>N\xE3o compartilhe este c\xF3digo com ningu\xE9m</li>
              <li>Se voc\xEA n\xE3o solicitou esta conta, ignore este email</li>
            </ul>
          </div>

          <p>Se voc\xEA n\xE3o conseguir usar o c\xF3digo, pode solicitar um novo c\xF3digo de verifica\xE7\xE3o no aplicativo.</p>
        </div>
        <div class="footer">
          <p>Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.</p>
          <p>&copy; 2024 25Stock. Todos os direitos reservados.</p>
        </div>
      </div>
    </body>
    </html>
  `;
};
var generateEmailVerificationText = (data) => {
  return `
Confirma\xE7\xE3o de Email - 25Stock

Ol\xE1, ${data.name}!

Bem-vindo ao 25Stock! Para confirmar sua conta, use o c\xF3digo de verifica\xE7\xE3o abaixo:

C\xD3DIGO DE VERIFICA\xC7\xC3O: ${data.verificationCode}

Este c\xF3digo expira em ${data.expiresIn}

Digite este c\xF3digo no aplicativo para confirmar seu email e ativar sua conta.

IMPORTANTE:
- Este c\xF3digo \xE9 v\xE1lido por ${data.expiresIn}
- N\xE3o compartilhe este c\xF3digo com ningu\xE9m
- Se voc\xEA n\xE3o solicitou esta conta, ignore este email

Se voc\xEA n\xE3o conseguir usar o c\xF3digo, pode solicitar um novo c\xF3digo de verifica\xE7\xE3o no aplicativo.

---
Este \xE9 um email autom\xE1tico, n\xE3o responda a esta mensagem.
\xA9 2024 25Stock. Todos os direitos reservados.
  `;
};

// src/services/email/email.service.ts
var resend = new import_resend.Resend(process.env.RESEND_API_KEY);
var EmailService = {
  /**
   * Envia email de boas-vindas para novos usurios
   */
  sendWelcomeEmail: async (data) => {
    try {
      const html = generateWelcomeEmailHTML(data);
      const text = generateWelcomeEmailText(data);
      const result = await resend.emails.send({
        from: process.env.FROM_EMAIL || "noreply@25stock.com",
        to: data.email,
        subject: `Bem-vindo ao 25Stock, ${data.name}!`,
        html,
        text
      });
      console.log("Welcome email sent:", result.data?.id);
      return true;
    } catch (error) {
      console.error("Error sending welcome email:", error);
      return false;
    }
  },
  /**
   * Envia email de redefinio de senha
   */
  sendPasswordResetEmail: async (data) => {
    try {
      const html = generatePasswordResetEmailHTML(data);
      const text = generatePasswordResetEmailText(data);
      const result = await resend.emails.send({
        from: process.env.FROM_EMAIL || "noreply@25stock.com",
        to: data.email,
        subject: "Redefini\xE7\xE3o de senha - 25Stock",
        html,
        text
      });
      console.log("Password reset email sent:", result.data?.id);
      return true;
    } catch (error) {
      console.error("Error sending password reset email:", error);
      return false;
    }
  },
  /**
   * Envia email de notificao
   */
  sendNotificationEmail: async (data) => {
    try {
      const html = generateNotificationEmailHTML(data);
      const text = generateNotificationEmailText(data);
      const result = await resend.emails.send({
        from: process.env.FROM_EMAIL || "noreply@25stock.com",
        to: data.email,
        subject: `Notifica\xE7\xE3o - ${data.title}`,
        html,
        text
      });
      console.log("Notification email sent:", result.data?.id);
      return true;
    } catch (error) {
      console.error("Error sending notification email:", error);
      return false;
    }
  },
  /**
   * Envia convite para loja
   */
  sendStoreInviteEmail: async (data) => {
    try {
      const html = generateStoreInviteEmailHTML(data);
      const text = generateStoreInviteEmailText(data);
      const result = await resend.emails.send({
        from: process.env.FROM_EMAIL || "noreply@25stock.com",
        to: data.email,
        subject: `Convite para loja ${data.storeName} - 25Stock`,
        html,
        text
      });
      console.log("Store invite email sent:", result.data?.id);
      return true;
    } catch (error) {
      console.error("Error sending store invite email:", error);
      return false;
    }
  },
  /**
   * Envia email de notificao de estoque baixo
   */
  sendStockLowEmail: async (data) => {
    try {
      const html = generateStockLowEmailHTML(data);
      const text = generateStockLowEmailText(data);
      const result = await resend.emails.send({
        from: process.env.FROM_EMAIL || "noreply@25stock.com",
        to: data.email,
        subject: `\u26A0\uFE0F ${data.title} - 25Stock`,
        html,
        text
      });
      console.log("Stock low email sent:", result.data?.id);
      return true;
    } catch (error) {
      console.error("Error sending stock low email:", error);
      return false;
    }
  },
  /**
   * Envia email de verificao com cdigo de 6 dgitos
   */
  sendEmailVerification: async (data) => {
    try {
      const html = generateEmailVerificationHTML(data);
      const text = generateEmailVerificationText(data);
      const result = await resend.emails.send({
        from: process.env.FROM_EMAIL || "noreply@25stock.com",
        to: data.email,
        subject: "Confirma\xE7\xE3o de Email - 25Stock",
        html,
        text
      });
      console.log("Email verification sent:", result.data?.id);
      return true;
    } catch (error) {
      console.error("Error sending email verification:", error);
      return false;
    }
  },
  /**
   * Envia email genrico
   */
  sendEmail: async (template) => {
    try {
      const result = await resend.emails.send({
        from: process.env.FROM_EMAIL || "noreply@25stock.com",
        to: template.to,
        subject: template.subject,
        html: template.html,
        text: template.text
      });
      console.log("Email sent:", result.data?.id);
      return true;
    } catch (error) {
      console.error("Error sending email:", error);
      return false;
    }
  }
};

// src/features/auth/commands/auth.commands.ts
var import_google_auth_library = require("google-auth-library");

// src/features/polar/commands/polar.commands.ts
var PolarCommands = {
  async checkout(data) {
    try {
      const checkout = await polar.checkouts.create({
        customerBillingAddress: {
          country: "BR"
        },
        customerEmail: data.customer.email,
        customerName: data.customer.name,
        products: [data.productId]
      });
      if (!checkout) {
        throw new Error("Failed to create checkout");
      }
      return checkout;
    } catch (error) {
      console.error("Polar checkout error:", error);
      throw new Error("Failed to create checkout");
    }
  },
  async webhook(event) {
    try {
      const type = event?.type || "";
      const data = event?.data || {};
      const findOrCreateSubscriptionByUserId = async (userId) => {
        let subscription3 = await db.subscription.findUnique({ where: { userId } });
        if (!subscription3) {
          subscription3 = await db.subscription.create({
            data: {
              userId,
              status: "ACTIVE"
            }
          });
        }
        return subscription3;
      };
      const findSubscriptionByPolarOrEmail = async (opts) => {
        const { polarCustomerId, email } = opts;
        if (polarCustomerId) {
          const byPolar = await db.subscription.findUnique({
            where: { polarCustomerId }
          });
          if (byPolar) return byPolar;
        }
        if (email) {
          const user = await db.user.findFirst({ where: { email } });
          if (user) return await findOrCreateSubscriptionByUserId(user.id);
        }
        return null;
      };
      const setSubscriptionPlanAndStatus = async (subscriptionId, polarProductId, status, renewalDate, trialEndsAt) => {
        return await db.subscription.update({
          where: { id: subscriptionId },
          data: {
            polarProductId: polarProductId || null,
            status,
            currentPeriodEnd: renewalDate || null,
            trialEndsAt: trialEndsAt || null
          }
        });
      };
      const upsertInvoice = async (subscriptionId, amountCents, polarInvoiceId, status = "PENDING", paymentDate) => {
        if (!amountCents && !polarInvoiceId) return null;
        const amount = amountCents ? Number(amountCents) / 100 : 0;
        const existing = polarInvoiceId ? await db.invoice.findUnique({ where: { polarInvoiceId } }) : null;
        if (existing) {
          return await db.invoice.update({
            where: { id: existing.id },
            data: {
              status,
              paymentDate: paymentDate || existing.paymentDate || null
            }
          });
        }
        return await db.invoice.create({
          data: {
            subscriptionId,
            amount,
            status,
            polarInvoiceId: polarInvoiceId || null,
            paymentDate: paymentDate || null
          }
        });
      };
      const checkout = data?.checkout_session;
      const subscription2 = data?.subscription;
      switch (type) {
        case "checkout.succeeded": {
          const userIdFromMetadata = checkout?.metadata?.user_id;
          const polarCustomerId = checkout?.customer_id;
          const polarSubscriptionId = checkout?.subscription_id;
          if (userIdFromMetadata) {
            const subscription3 = await findOrCreateSubscriptionByUserId(userIdFromMetadata);
            await db.subscription.update({
              where: { id: subscription3.id },
              data: {
                polarCustomerId: polarCustomerId || subscription3.polarCustomerId || null,
                polarSubscriptionId: polarSubscriptionId || subscription3.polarSubscriptionId || null
              }
            });
          } else if (polarCustomerId) {
            const subscription3 = await findSubscriptionByPolarOrEmail({
              polarCustomerId,
              email: null
            });
            if (subscription3) {
              await db.subscription.update({
                where: { id: subscription3.id },
                data: {
                  polarCustomerId,
                  polarSubscriptionId: polarSubscriptionId || subscription3.polarSubscriptionId || null
                }
              });
            }
          }
          break;
        }
        case "subscription.created":
        case "subscription.updated":
        case "subscription.canceled": {
          const polarCustomerId = subscription2?.customer_id;
          const polarSubscriptionId = subscription2?.id;
          if (polarCustomerId || polarSubscriptionId) {
            const sub = await findSubscriptionByPolarOrEmail({ polarCustomerId, email: null });
            if (sub) {
              await db.subscription.update({
                where: { id: sub.id },
                data: {
                  polarCustomerId: polarCustomerId || sub.polarCustomerId || null,
                  polarSubscriptionId: polarSubscriptionId || sub.polarSubscriptionId || null
                }
              });
            }
          }
          break;
        }
        // === NOVOS EVENTOS DE ORDER ===
        case "order.created":
        case "order.updated": {
          const order = data;
          const polarCustomerId = order?.customer_id || order?.customerId;
          const email = order?.customer?.email || order?.email;
          const productId = order?.product_id || order?.productId;
          const sub = await findSubscriptionByPolarOrEmail({ polarCustomerId, email });
          if (sub) {
            await db.subscription.update({
              where: { id: sub.id },
              data: {
                polarCustomerId: polarCustomerId || sub.polarCustomerId || null,
                polarProductId: productId || sub.polarProductId || null
              }
            });
          }
          break;
        }
        case "order.paid": {
          const order = data;
          const polarCustomerId = order?.customer_id || order?.customerId;
          const email = order?.customer?.email || order?.email;
          const productId = order?.product_id || order?.productId;
          const amountCents = order?.amount || order?.amount_cents || order?.total_amount_cents;
          const invoiceId = order?.invoice_id || order?.invoiceId;
          const currentPeriodEndIso = order?.current_period_end;
          const sub = await findSubscriptionByPolarOrEmail({ polarCustomerId, email });
          if (!sub) break;
          const renewalDate = currentPeriodEndIso ? new Date(currentPeriodEndIso) : null;
          await setSubscriptionPlanAndStatus(sub.id, productId || null, "ACTIVE", renewalDate, null);
          await upsertInvoice(sub.id, amountCents, invoiceId || null, "PAID", /* @__PURE__ */ new Date());
          break;
        }
        case "order.refunded": {
          const order = data;
          const polarCustomerId = order?.customer_id || order?.customerId;
          const email = order?.customer?.email || order?.email;
          const invoiceId = order?.invoice_id || order?.invoiceId;
          const sub = await findSubscriptionByPolarOrEmail({ polarCustomerId, email });
          if (!sub) break;
          await setSubscriptionPlanAndStatus(sub.id, sub.polarProductId, "INACTIVE", null, null);
          await upsertInvoice(sub.id, null, invoiceId || null, "REFUNDED", null);
          break;
        }
        case "customer.state_changed": {
          const email = data?.email;
          const polarCustomerId = data?.id;
          const activeSub = Array.isArray(data?.active_subscriptions) && data.active_subscriptions.length > 0 ? data.active_subscriptions[0] : null;
          const sub = await findSubscriptionByPolarOrEmail({ polarCustomerId, email });
          if (!sub) break;
          const productId = activeSub?.product_id;
          const statusMap = {
            active: "ACTIVE",
            trialing: "TRIAL",
            canceled: "CANCELLED",
            paused: "INACTIVE",
            past_due: "PAST_DUE",
            expired: "EXPIRED"
          };
          const subStatus = activeSub?.status;
          const mappedStatus = subStatus && statusMap[subStatus] ? statusMap[subStatus] : "ACTIVE";
          const renewalDate = activeSub?.current_period_end ? new Date(activeSub.current_period_end) : null;
          const trialEndsAt = activeSub?.trial_end ? new Date(activeSub.trial_end) : null;
          await db.subscription.update({
            where: { id: sub.id },
            data: {
              polarCustomerId: polarCustomerId || sub.polarCustomerId || null,
              polarSubscriptionId: activeSub?.id || sub.polarSubscriptionId || null
            }
          });
          await setSubscriptionPlanAndStatus(
            sub.id,
            productId || null,
            mappedStatus,
            renewalDate,
            trialEndsAt
          );
          break;
        }
        default:
          break;
      }
      return { success: true };
    } catch (error) {
      console.error("Polar webhook error:", error);
      return { success: false, error: error?.message || "Internal error" };
    }
  },
  async createSubscription(data) {
    try {
      const subscription2 = await polar.subscriptions.create({
        customerId: data.customerId,
        productId: data.productId
      });
      return subscription2;
    } catch (error) {
      console.error("Polar create subscription error:", error);
      return null;
    }
  },
  async createCustomer(data) {
    try {
      const customer = await polar.customers.create({
        email: data.email,
        name: data.name,
        externalId: data.externalId
        //organizationId: process.env.POLAR_ORGANIZATION_ID as string,
      });
      return customer;
    } catch (error) {
      console.error("Polar create customer error:", error);
      return null;
    }
  }
};

// src/features/auth/commands/auth.commands.ts
var scrypt = (0, import_node_util.promisify)(import_node_crypto.default.scrypt);
async function hashPassword(password) {
  const salt = import_node_crypto.default.randomBytes(16).toString("hex");
  const derivedKey = await scrypt(password, salt, 64);
  return `${salt}:${derivedKey.toString("hex")}`;
}
async function comparePassword(password, hash) {
  const [salt, key] = hash.split(":");
  const derivedKey = await scrypt(password, salt, 64);
  const keyBuffer = Buffer.from(key, "hex");
  return import_node_crypto.default.timingSafeEqual(derivedKey, keyBuffer);
}
var AuthCommands = {
  async register(data) {
    const { name, email, password, phone } = data;
    const existingUser = await db.user.findUnique({
      where: { email }
    });
    if (existingUser) {
      throw new Error("User already exists with this email");
    }
    const hashedPassword = await hashPassword(password);
    const verificationCode = AuthCommands.generateVerificationCode();
    const verificationToken = AuthCommands.generateVerificationToken();
    const codeExpires = new Date(Date.now() + 15 * 60 * 1e3);
    const user = await db.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
        phone: phone || null,
        emailVerified: false,
        emailVerificationCode: verificationCode,
        emailVerificationToken: verificationToken,
        emailVerificationCodeExpires: codeExpires,
        status: true,
        isOwner: false
      },
      select: {
        id: true,
        name: true,
        email: true,
        phone: true,
        emailVerified: true,
        isOwner: true,
        storeId: true,
        createdAt: true
      }
    });
    try {
      const freePlan = await PolarQueries.getFreePlan();
      if (freePlan) {
        const polarCustomer = await PolarCommands.createCustomer({
          email: user.email,
          name: user.name || "",
          externalId: user.id
        });
        let polarSubscription = null;
        if (polarCustomer?.id) {
          polarSubscription = await PolarCommands.createSubscription({
            customerId: polarCustomer.id,
            productId: freePlan.id
          });
        }
        await db.subscription.create({
          data: {
            userId: user.id,
            status: "ACTIVE",
            polarCustomerId: polarCustomer?.id || null,
            polarSubscriptionId: polarSubscription?.id || null,
            polarProductId: freePlan.id,
            polarPlanName: freePlan.name,
            priceAmount: 0,
            priceInterval: freePlan.recurringInterval === "month" ? "MONTHLY" : "YEARLY",
            currency: "BRL"
          }
        });
      } else {
        console.warn("Nenhum plano free encontrado no Polar");
      }
    } catch (e) {
      console.error("Falha ao associar plano free ao usu\xE1rio:", e);
    }
    try {
      await EmailService.sendEmailVerification({
        email: user.email,
        name: user.name || "",
        verificationCode,
        expiresIn: "15 minutos"
      });
      console.log(`User ${email} registered - verification code sent`);
    } catch (error) {
      console.error("Failed to send verification email:", error);
    }
    return user;
  },
  async login(data) {
    const { email, password } = data;
    const user = await db.user.findUnique({
      where: { email, status: true }
    });
    if (!user) {
      throw new Error("Invalid credentials");
    }
    const isValidPassword = await comparePassword(password, user.password);
    if (!isValidPassword) {
      throw new Error("Invalid credentials");
    }
    if (!user.emailVerified) {
      throw new Error("Email verification required");
    }
    await db.user.update({
      where: { id: user.id },
      data: { lastLoginAt: /* @__PURE__ */ new Date() }
    });
    const store = user.storeId ? await db.store.findUnique({
      where: { id: user.storeId },
      select: {
        id: true,
        name: true,
        cnpj: true,
        email: true,
        phone: true,
        status: true,
        cep: true,
        city: true,
        state: true,
        address: true,
        createdAt: true,
        updatedAt: true
      }
    }) : null;
    const token = AuthCommands.generateJWT({
      userId: user.id,
      email: user.email
    });
    return {
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        emailVerified: user.emailVerified,
        lastLoginAt: /* @__PURE__ */ new Date()
      },
      store: store || void 0,
      token
    };
  },
  async forgotPassword(email) {
    const user = await db.user.findUnique({
      where: { email, status: true }
    });
    if (!user) {
      throw new Error("User not found");
    }
    const resetToken = AuthCommands.generateResetToken();
    const resetExpires = new Date(Date.now() + 15 * 60 * 1e3);
    await db.user.update({
      where: { id: user.id },
      data: {
        resetPasswordToken: resetToken,
        resetPasswordExpires: resetExpires
      }
    });
    try {
      await EmailService.sendPasswordResetEmail({
        name: user.name || "Usu\xE1rio",
        email: user.email,
        resetCode: resetToken,
        expiresIn: "15 minutos"
      });
    } catch (error) {
      console.error("Failed to send reset password email:", error);
    }
    return { message: "Reset password token sent to email" };
  },
  async verifyResetCode(email, code) {
    const user = await db.user.findFirst({
      where: {
        email,
        resetPasswordToken: code,
        resetPasswordExpires: {
          gt: /* @__PURE__ */ new Date()
        }
      }
    });
    if (!user) {
      throw new Error("Invalid or expired reset code");
    }
    if (user.resetPasswordExpires && user.resetPasswordExpires < /* @__PURE__ */ new Date()) {
      throw new Error("Reset code expired");
    }
    return { message: "Reset code verified successfully" };
  },
  async resetPassword(email, code, newPassword) {
    const user = await db.user.findFirst({
      where: {
        email,
        resetPasswordToken: code,
        resetPasswordExpires: {
          gt: /* @__PURE__ */ new Date()
        }
      }
    });
    if (!user) {
      throw new Error("Invalid or expired reset code");
    }
    if (user.resetPasswordExpires && user.resetPasswordExpires < /* @__PURE__ */ new Date()) {
      throw new Error("Reset code expired");
    }
    const hashedPassword = await hashPassword(newPassword);
    await db.user.update({
      where: { id: user.id },
      data: {
        password: hashedPassword,
        resetPasswordToken: null,
        resetPasswordExpires: null
      }
    });
    return { message: "Password reset successfully" };
  },
  async verifyEmail(token) {
    const user = await db.user.findFirst({
      where: {
        emailVerificationToken: token,
        status: true
      }
    });
    if (!user) {
      throw new Error("Invalid or expired verification token");
    }
    if (user.emailVerified) {
      throw new Error("Email already verified");
    }
    const updatedUser = await db.user.update({
      where: { id: user.id },
      data: {
        emailVerified: true,
        emailVerificationToken: null,
        emailVerificationCode: null,
        emailVerificationCodeExpires: null
      },
      select: {
        id: true,
        name: true,
        email: true,
        emailVerified: true,
        createdAt: true
      }
    });
    return updatedUser;
  },
  async verifyEmailCode(email, code) {
    const user = await db.user.findFirst({
      where: {
        email,
        emailVerificationCode: code,
        status: true
      }
    });
    if (!user) {
      throw new Error("Invalid verification code");
    }
    if (user.emailVerified) {
      throw new Error("Email already verified");
    }
    if (user.emailVerificationCodeExpires && user.emailVerificationCodeExpires < /* @__PURE__ */ new Date()) {
      throw new Error("Verification code has expired");
    }
    const updatedUser = await db.user.update({
      where: { id: user.id },
      data: {
        emailVerified: true,
        emailVerificationToken: null,
        emailVerificationCode: null,
        emailVerificationCodeExpires: null
      },
      select: {
        id: true,
        name: true,
        email: true,
        emailVerified: true,
        createdAt: true
      }
    });
    return updatedUser;
  },
  async resendVerification(email) {
    const user = await db.user.findUnique({
      where: { email, status: true }
    });
    if (!user) {
      throw new Error("User not found");
    }
    if (user.emailVerified) {
      throw new Error("Email already verified");
    }
    const verificationCode = AuthCommands.generateVerificationCode();
    const verificationToken = AuthCommands.generateVerificationToken();
    const codeExpires = new Date(Date.now() + 15 * 60 * 1e3);
    await db.user.update({
      where: { id: user.id },
      data: {
        emailVerificationCode: verificationCode,
        emailVerificationToken: verificationToken,
        emailVerificationCodeExpires: codeExpires
      }
    });
    try {
      await EmailService.sendEmailVerification({
        email: user.email,
        name: user.name || "Usu\xE1rio",
        verificationCode,
        expiresIn: "15 minutos"
      });
    } catch (error) {
      console.error("Failed to send verification email:", error);
      throw new Error("Failed to send verification email");
    }
    return { message: "Verification email sent successfully" };
  },
  async refreshToken(userId) {
    const user = await db.user.findUnique({
      where: { id: userId, status: true }
    });
    if (!user) {
      throw new Error("User not found");
    }
    const token = AuthCommands.generateJWT({
      userId: user.id,
      email: user.email
    });
    return { token, message: "Token refreshed successfully" };
  },
  generateJWT(payload) {
    const secret = process.env.JWT_SECRET || "your-secret-key";
    return import_jsonwebtoken.default.sign(payload, secret, { expiresIn: "7d" });
  },
  generateResetToken() {
    return import_node_crypto.default.randomBytes(32).toString("hex");
  },
  generateVerificationToken() {
    return import_node_crypto.default.randomBytes(32).toString("hex");
  },
  generateVerificationCode() {
    return Math.floor(1e5 + Math.random() * 9e5).toString();
  },
  verifyToken(token) {
    const secret = process.env.JWT_SECRET || "your-secret-key";
    return import_jsonwebtoken.default.verify(token, secret);
  },
  extractToken(authHeader) {
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      throw new Error("Invalid authorization header");
    }
    return authHeader.substring(7);
  },
  async googleLogin(token) {
    if (!process.env.GOOGLE_CLIENT_ID) {
      throw new Error("Google OAuth configuration missing");
    }
    const client = new import_google_auth_library.OAuth2Client(process.env.GOOGLE_CLIENT_ID);
    try {
      const ticket = await client.verifyIdToken({
        idToken: token,
        audience: process.env.GOOGLE_CLIENT_ID
      });
      const payload = ticket.getPayload();
      if (!payload || !payload.email || !payload.name) {
        throw new Error("Invalid Google token payload");
      }
      let user = await db.user.findUnique({
        where: { email: payload.email }
      });
      if (!user) {
        user = await db.user.create({
          data: {
            name: payload.name,
            email: payload.email,
            password: "",
            // Empty for OAuth users
            emailVerified: true,
            // Google j verifica o email
            status: true,
            isOwner: false,
            lastLoginAt: /* @__PURE__ */ new Date()
          }
        });
        try {
          const freePlan = await PolarQueries.getFreePlan();
          if (freePlan) {
            const polarCustomer = await PolarCommands.createCustomer({
              email: user.email,
              name: user.name || "",
              externalId: user.id
            });
            let polarSubscription = null;
            if (polarCustomer?.id) {
              polarSubscription = await PolarCommands.createSubscription({
                customerId: polarCustomer.id,
                productId: freePlan.id
              });
            }
            await db.subscription.create({
              data: {
                userId: user.id,
                status: "ACTIVE",
                polarCustomerId: polarCustomer?.id || null,
                polarSubscriptionId: polarSubscription?.id || null,
                polarProductId: freePlan.id,
                polarPlanName: freePlan.name,
                priceAmount: 0,
                priceInterval: freePlan.recurringInterval === "month" ? "MONTHLY" : "YEARLY",
                currency: "BRL"
              }
            });
          } else {
            console.warn("Nenhum plano free encontrado no Polar (Google login)");
          }
        } catch (e) {
          console.error("Falha ao associar plano free (Google):", e);
        }
      } else {
        await db.user.update({
          where: { id: user.id },
          data: { lastLoginAt: /* @__PURE__ */ new Date() }
        });
      }
      if (!user.status) {
        throw new Error("User account is disabled");
      }
      const store = user.storeId ? await db.store.findUnique({
        where: { id: user.storeId },
        select: {
          id: true,
          name: true,
          cnpj: true,
          email: true,
          phone: true,
          status: true,
          cep: true,
          city: true,
          state: true,
          address: true,
          createdAt: true,
          updatedAt: true
        }
      }) : null;
      const jwtToken = AuthCommands.generateJWT({
        userId: user.id,
        email: user.email
      });
      return {
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          emailVerified: user.emailVerified,
          lastLoginAt: user.lastLoginAt
        },
        store: store || void 0,
        token: jwtToken
      };
    } catch (error) {
      console.error("Google Login Error:", error);
      if (error.message === "Google OAuth configuration missing") {
        throw new Error("Google OAuth configuration missing");
      }
      if (error.message === "Invalid Google token payload") {
        throw new Error("Invalid Google token");
      }
      if (error.message === "User account is disabled") {
        throw new Error("User account is disabled");
      }
      throw new Error("Invalid Google token");
    }
  }
};

// src/features/auth/auth.controller.ts
var AuthController = {
  async register(request, reply) {
    try {
      const { name, email, password, phone } = request.body;
      const user = await AuthCommands.register({
        name,
        email,
        phone,
        password
      });
      return reply.status(201).send({
        user,
        message: "Usu\xE1rio registrado com sucesso. Verifique seu email para o c\xF3digo de confirma\xE7\xE3o de 6 d\xEDgitos."
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User already exists with this email") {
        return reply.status(409).send({
          error: "J\xE1 existe um usu\xE1rio com este email"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async login(request, reply) {
    try {
      const { email, password } = request.body;
      const result = await AuthCommands.login({
        email,
        password
      });
      return reply.send({
        user: result.user,
        store: result.store,
        token: result.token,
        message: "Login successful"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid credentials") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Email verification required") {
        return reply.status(403).send({
          error: "Necess\xE1rio verificar o email"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forgotPassword(request, reply) {
    try {
      const { email } = request.body;
      await AuthCommands.forgotPassword(email);
      return reply.send({
        message: "If the email exists, a reset password code has been sent."
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: "If the email exists, a reset password code has been sent."
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyResetCode(request, reply) {
    try {
      const { email, code } = request.body;
      await AuthCommands.verifyResetCode(email, code);
      return reply.send({
        message: "Reset code verified successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid or expired reset code") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Reset code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resetPassword(request, reply) {
    try {
      const { email, code, password } = request.body;
      await AuthCommands.resetPassword(email, code, password);
      return reply.send({
        message: "Password reset successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid or expired reset code") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "Reset code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyEmail(request, reply) {
    try {
      const { token } = request.body;
      await AuthCommands.verifyEmail(token);
      return reply.send({
        message: "Email verified successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid verification token") {
        return reply.status(401).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifyEmailCode(request, reply) {
    try {
      const { email, code } = request.body;
      const user = await AuthCommands.verifyEmailCode(email, code);
      return reply.send({
        message: "Email verified successfully",
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          emailVerified: user.emailVerified
        }
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid verification code" || error.message === "Verification code expired") {
        return reply.status(401).send({
          error: error.message
        });
      }
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resendVerification(request, reply) {
    try {
      const { email } = request.body;
      await AuthCommands.resendVerification(email);
      return reply.send({
        message: "Verification email sent successfully"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already verified") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async refreshToken(request, reply) {
    try {
      const authHeader = request.headers.authorization;
      if (!authHeader) {
        return reply.status(401).send({
          error: "Authorization header required"
        });
      }
      const token = AuthCommands.extractToken(authHeader);
      const payload = AuthCommands.verifyToken(token);
      const result = await AuthCommands.refreshToken(payload.userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid authorization header" || error.message === "User not found") {
        return reply.status(401).send({
          error: "Invalid token"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async googleLogin(request, reply) {
    try {
      const { id_token } = request.body;
      const result = await AuthCommands.googleLogin(id_token);
      return reply.send({
        user: result.user,
        store: result.store,
        token: result.token,
        message: "Google login successful"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Google OAuth configuration missing") {
        return reply.status(500).send({
          error: "Google OAuth n\xE3o configurado no servidor"
        });
      }
      if (error.message === "Invalid Google token") {
        return reply.status(401).send({
          error: "Token do Google inv\xE1lido"
        });
      }
      if (error.message === "User account is disabled") {
        return reply.status(403).send({
          error: "Conta de usu\xE1rio desabilitada"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/auth/auth.schema.ts
var registerSchema = {
  body: {
    type: "object",
    required: ["name", "email", "password"],
    properties: {
      name: {
        type: "string",
        minLength: 2,
        maxLength: 100,
        description: "User full name"
      },
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      password: {
        type: "string",
        minLength: 6,
        maxLength: 100,
        description: "User password (minimum 6 characters)"
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    409: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var loginSchema = {
  body: {
    type: "object",
    required: ["email", "password"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      password: {
        type: "string",
        description: "User password"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time" }
          }
        },
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var forgotPasswordSchema = {
  body: {
    type: "object",
    required: ["email"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyResetCodeSchema = {
  body: {
    type: "object",
    required: ["email", "code"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit reset code"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var resetPasswordSchema = {
  body: {
    type: "object",
    required: ["email", "code", "password"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit reset code"
      },
      password: {
        type: "string",
        minLength: 6,
        maxLength: 100,
        description: "New password (minimum 6 characters)"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyEmailSchema = {
  body: {
    type: "object",
    required: ["token"],
    properties: {
      token: {
        type: "string",
        description: "Email verification token"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var verifyEmailCodeSchema = {
  body: {
    type: "object",
    required: ["email", "code"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      },
      code: {
        type: "string",
        pattern: "^[0-9]{6}$",
        description: "6-digit verification code"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var resendVerificationSchema = {
  body: {
    type: "object",
    required: ["email"],
    properties: {
      email: {
        type: "string",
        format: "email",
        description: "User email address"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var refreshTokenSchema = {
  headers: {
    type: "object",
    properties: {
      authorization: {
        type: "string",
        description: "Bearer token"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var googleLoginSchema = {
  body: {
    type: "object",
    required: ["id_token"],
    properties: {
      id_token: {
        type: "string",
        description: "Google ID token from client-side authentication"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            emailVerified: { type: "boolean" },
            lastLoginAt: { type: ["string", "null"], format: "date-time" }
          }
        },
        store: {
          type: ["object", "null"],
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" },
            email: { type: ["string", "null"] },
            phone: { type: ["string", "null"] },
            status: { type: "boolean" },
            cep: { type: ["string", "null"] },
            city: { type: ["string", "null"] },
            state: { type: ["string", "null"] },
            address: { type: ["string", "null"] },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" }
          }
        },
        token: { type: "string" },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var AuthSchemas = {
  register: registerSchema,
  login: loginSchema,
  forgotPassword: forgotPasswordSchema,
  verifyResetCode: verifyResetCodeSchema,
  resetPassword: resetPasswordSchema,
  verifyEmail: verifyEmailSchema,
  verifyEmailCode: verifyEmailCodeSchema,
  resendVerification: resendVerificationSchema,
  refreshToken: refreshTokenSchema,
  googleLogin: googleLoginSchema
};

// src/features/auth/auth.routes.ts
async function AuthRoutes(fastify2) {
  fastify2.post("/signup", {
    schema: AuthSchemas.register,
    handler: AuthController.register
  });
  fastify2.post("/signin", {
    schema: AuthSchemas.login,
    handler: AuthController.login
  });
  fastify2.post("/forgot-password", {
    schema: AuthSchemas.forgotPassword,
    handler: AuthController.forgotPassword
  });
  fastify2.post("/verify-reset-code", {
    schema: AuthSchemas.verifyResetCode,
    handler: AuthController.verifyResetCode
  });
  fastify2.post("/reset-password", {
    schema: AuthSchemas.resetPassword,
    handler: AuthController.resetPassword
  });
  fastify2.post("/verify-email", {
    schema: AuthSchemas.verifyEmail,
    handler: AuthController.verifyEmail
  });
  fastify2.post("/verify-email-code", {
    schema: AuthSchemas.verifyEmailCode,
    handler: AuthController.verifyEmailCode
  });
  fastify2.post("/google", {
    schema: AuthSchemas.googleLogin,
    handler: AuthController.googleLogin
  });
  fastify2.post("/resend-verification", {
    schema: AuthSchemas.resendVerification,
    handler: AuthController.resendVerification
  });
  fastify2.post("/refresh-token", {
    schema: AuthSchemas.refreshToken,
    handler: AuthController.refreshToken
  });
}

// src/middlewares/auth.middleware.ts
var import_jsonwebtoken2 = __toESM(require("jsonwebtoken"));
async function Auth(request, reply) {
  try {
    const authHeader = request.headers.authorization;
    if (!authHeader?.startsWith("Bearer ")) {
      return reply.status(401).send({ error: "Authorization header missing or invalid" });
    }
    const token = authHeader.slice(7);
    const secret = process.env.JWT_SECRET;
    if (!secret) {
      throw new Error("JWT secret not configured");
    }
    const payload = import_jsonwebtoken2.default.verify(token, secret);
    const user = await db.user.findUnique({
      where: { id: payload.userId, status: true },
      select: {
        id: true,
        email: true,
        name: true,
        emailVerified: true,
        status: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    if (!user) {
      return reply.status(403).send({ error: "User not found or inactive" });
    }
    request.user = user;
    return user;
  } catch (error) {
    if (error instanceof import_jsonwebtoken2.default.TokenExpiredError) {
      return reply.status(401).send({ error: "Token expired" });
    }
    if (error instanceof import_jsonwebtoken2.default.JsonWebTokenError) {
      return reply.status(401).send({ error: "Invalid token" });
    }
    console.error("Auth middleware error:", error);
    return reply.status(500).send({ error: "Internal server error" });
  }
}

// src/middlewares/permission.middleware.ts
var Permission = (resource, action) => {
  return async (request, reply) => {
    try {
      if (!request.user?.id) {
        return reply.status(401).send({
          error: "Unauthorized - User not authenticated"
        });
      }
      const hasPermission = await db.userPermission.findFirst({
        where: {
          userId: request.user.id,
          resource,
          action
        }
      });
      if (!hasPermission) {
        return reply.status(403).send({
          error: "Forbidden - Insufficient permissions",
          details: `Required permission: ${action} on ${resource}`
        });
      }
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  };
};

// src/middlewares/store.middleware.ts
var Store = async (request, reply) => {
  try {
    const store = await db.store.findFirst({
      where: {
        OR: [{ ownerId: request.user?.id }, { users: { some: { id: request.user?.id } } }]
      },
      select: { id: true, name: true }
    });
    if (!store) {
      return reply.status(404).send({
        error: "Store not found for this user"
      });
    }
    request.store = store;
    return;
  } catch (error) {
    request.log.error(error);
    return reply.status(500).send({
      error: "Internal server error"
    });
  }
};

// src/middlewares/index.ts
var Middlewares = {
  auth: Auth,
  store: Store,
  permission: Permission
};

// src/features/category/commands/category.commands.ts
var CategoryCommands = {
  async create(data) {
    return await db.category.create({
      data: {
        ...data,
        status: data.status ?? true
      },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async update(id, data) {
    return await db.category.update({
      where: { id },
      data,
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async delete(id) {
    return await db.category.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.category.update({
      where: { id },
      data: { status },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async moveToParent(id, parentId) {
    return await db.category.update({
      where: { id },
      data: { parentId },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async bulkDelete(ids) {
    if (!ids || ids.length === 0) {
      throw new Error("No category IDs provided");
    }
    const errors = [];
    let deletedCount = 0;
    for (const id of ids) {
      try {
        const category = await db.category.findUnique({
          where: { id },
          include: {
            _count: {
              select: {
                children: true,
                products: true
              }
            }
          }
        });
        if (!category) {
          errors.push(`Category ${id} not found`);
          continue;
        }
        if (category._count.children > 0) {
          errors.push(`Category ${id} has children and cannot be deleted`);
          continue;
        }
        if (category._count.products > 0) {
          errors.push(`Category ${id} has products and cannot be deleted`);
          continue;
        }
        await db.category.delete({
          where: { id }
        });
        deletedCount++;
      } catch (error) {
        errors.push(`Failed to delete category ${id}: ${error.message}`);
      }
    }
    return {
      deleted: deletedCount,
      errors
    };
  }
};

// src/features/category/queries/category.queries.ts
var CategoryQueries = {
  async getById(id) {
    return await db.category.findUnique({
      where: { id },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, parentId, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (parentId !== void 0) {
      if (parentId === null) {
        where.parentId = null;
      } else {
        where.parentId = parentId;
      }
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } },
        { code: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.category.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          parent: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true
            }
          },
          children: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true,
              status: true,
              color: true,
              icon: true
            }
          },
          products: {
            select: {
              id: true,
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  status: true
                }
              }
            },
            take: 5
          },
          _count: {
            select: {
              children: true,
              products: true
            }
          }
        }
      }),
      db.category.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, storeId, params = {}) {
    const { page = 1, limit = 10 } = params;
    const skip2 = (page - 1) * limit;
    const where = {
      storeId,
      OR: [
        { name: { contains: term, mode: "insensitive" } },
        { description: { contains: term, mode: "insensitive" } },
        { code: { contains: term, mode: "insensitive" } }
      ]
    };
    const [items, total] = await Promise.all([
      db.category.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          parent: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true
            }
          },
          children: {
            select: {
              id: true,
              name: true,
              description: true,
              code: true,
              status: true,
              color: true,
              icon: true
            }
          },
          _count: {
            select: {
              children: true,
              products: true
            }
          }
        }
      }),
      db.category.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getActive(storeId) {
    return await db.category.findMany({
      where: {
        status: true,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getStats(storeId) {
    const [total, active, inactive, withChildren, withoutChildren] = await Promise.all([
      db.category.count({ where: { storeId } }),
      db.category.count({ where: { status: true, storeId } }),
      db.category.count({ where: { status: false, storeId } }),
      db.category.count({
        where: {
          storeId,
          children: { some: {} }
        }
      }),
      db.category.count({
        where: {
          storeId,
          children: { none: {} }
        }
      })
    ]);
    return {
      total,
      active,
      inactive,
      withChildren,
      withoutChildren
    };
  },
  async getRootCategories(storeId, status) {
    const where = {
      parentId: null,
      storeId
    };
    if (status !== void 0) {
      where.status = status;
    }
    return await db.category.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getChildren(parentId, storeId) {
    return await db.category.findMany({
      where: {
        parentId,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getHierarchy(storeId) {
    const rootCategories = await CategoryQueries.getRootCategories(storeId);
    const buildHierarchy = async (categories) => {
      for (const category of categories) {
        category.children = await CategoryQueries.getChildren(category.id, storeId);
        if (category.children.length > 0) {
          await buildHierarchy(category.children);
        }
      }
    };
    await buildHierarchy(rootCategories);
    return rootCategories;
  },
  async getByCode(code, storeId) {
    return await db.category.findUnique({
      where: {
        code_storeId: {
          code,
          storeId
        }
      },
      include: {
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        children: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            status: true,
            color: true,
            icon: true
          }
        },
        products: {
          select: {
            id: true,
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                status: true
              }
            }
          },
          take: 5
        },
        _count: {
          select: {
            children: true,
            products: true
          }
        }
      }
    });
  },
  async getTopCategoriesByProducts(storeId, params) {
    const { limit = 10, status, includeInactive = false } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    where.products = {
      some: {}
    };
    return await db.category.findMany({
      where,
      take: limit,
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      select: {
        id: true,
        name: true,
        description: true,
        code: true,
        status: true,
        color: true,
        icon: true,
        parentId: true,
        createdAt: true,
        updatedAt: true,
        parent: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true
          }
        },
        _count: {
          select: {
            products: true,
            children: true
          }
        }
      }
    });
  },
  async getTopCategoriesByProductsWithDetails(storeId, params) {
    const { limit = 10, status, includeInactive = false, includeProductDetails = false } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    where.products = {
      some: {}
    };
    const include = {
      parent: {
        select: {
          id: true,
          name: true,
          description: true,
          code: true
        }
      },
      _count: {
        select: {
          products: true,
          children: true
        }
      }
    };
    if (includeProductDetails) {
      include.products = {
        select: {
          id: true,
          product: {
            select: {
              id: true,
              name: true,
              description: true,
              status: true,
              sku: true,
              price: true,
              stock: true
            }
          }
        },
        take: 5
        // Limitar a 5 produtos por categoria para no sobrecarregar
      };
    }
    return await db.category.findMany({
      where,
      take: limit,
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      select: {
        id: true,
        name: true,
        description: true,
        code: true,
        status: true,
        color: true,
        icon: true,
        parentId: true,
        createdAt: true,
        updatedAt: true,
        ...include
      }
    });
  },
  async getCategoryCreationEvolution(storeId, params) {
    const { period = "month", startDate, endDate, status, includeInactive = false } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = startDate;
      }
      if (endDate) {
        where.createdAt.lte = endDate;
      }
    }
    const categories = await db.category.findMany({
      where,
      select: {
        id: true,
        name: true,
        status: true,
        createdAt: true
      },
      orderBy: {
        createdAt: "asc"
      }
    });
    const groupedData = CategoryQueries.groupByPeriod(categories, period);
    const totalCategories = categories.length;
    const activeCategories = categories.filter((cat) => cat.status).length;
    const inactiveCategories = totalCategories - activeCategories;
    const periods = Object.keys(groupedData).sort();
    const growthRate = CategoryQueries.calculateGrowthRate(groupedData, periods);
    return {
      data: groupedData,
      metadata: {
        totalCategories,
        activeCategories,
        inactiveCategories,
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        growthRate,
        description: `Evolu\xE7\xE3o de cria\xE7\xE3o de categorias por ${period}`,
        chartType: "line"
      }
    };
  },
  async getCategoryCreationEvolutionDetailed(storeId, params) {
    const {
      period = "month",
      startDate,
      endDate,
      status,
      includeInactive = false,
      includeDetails = false
    } = params;
    const where = {
      storeId
    };
    if (!includeInactive) {
      where.status = status !== void 0 ? status : true;
    } else if (status !== void 0) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = startDate;
      }
      if (endDate) {
        where.createdAt.lte = endDate;
      }
    }
    const selectFields = {
      id: true,
      name: true,
      status: true,
      createdAt: true
    };
    if (includeDetails) {
      selectFields.parent = {
        select: {
          id: true,
          name: true
        }
      };
      selectFields._count = {
        select: {
          children: true,
          products: true
        }
      };
    }
    const categories = await db.category.findMany({
      where,
      select: selectFields,
      orderBy: {
        createdAt: "asc"
      }
    });
    const groupedData = CategoryQueries.groupByPeriod(categories, period);
    const totalCategories = categories.length;
    const activeCategories = categories.filter((cat) => cat.status).length;
    const inactiveCategories = totalCategories - activeCategories;
    const periods = Object.keys(groupedData).sort();
    const growthRate = CategoryQueries.calculateGrowthRate(groupedData, periods);
    const periodStats = CategoryQueries.calculatePeriodStats(groupedData, periods);
    return {
      data: groupedData,
      periodStats,
      metadata: {
        totalCategories,
        activeCategories,
        inactiveCategories,
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        growthRate,
        description: `Evolu\xE7\xE3o detalhada de cria\xE7\xE3o de categorias por ${period}`,
        chartType: "line"
      }
    };
  },
  // Mtodos auxiliares privados
  groupByPeriod(categories, period) {
    const grouped = {};
    for (const category of categories) {
      const date = new Date(category.createdAt);
      let key;
      switch (period) {
        case "day":
          key = date.toISOString().split("T")[0];
          break;
        case "week":
          {
            const weekStart = new Date(date);
            weekStart.setDate(date.getDate() - date.getDay());
            key = weekStart.toISOString().split("T")[0];
          }
          break;
        case "month":
          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
          break;
        case "year":
          key = String(date.getFullYear());
          break;
      }
      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push(category);
    }
    const chartData = {};
    for (const key of Object.keys(grouped)) {
      chartData[key] = {
        count: grouped[key].length,
        categories: grouped[key]
      };
    }
    return chartData;
  },
  calculateGrowthRate(groupedData, periods) {
    if (periods.length < 2) return 0;
    const firstPeriod = periods[0];
    const lastPeriod = periods[periods.length - 1];
    const firstCount = groupedData[firstPeriod]?.count || 0;
    const lastCount = groupedData[lastPeriod]?.count || 0;
    if (firstCount === 0) return lastCount > 0 ? 100 : 0;
    return (lastCount - firstCount) / firstCount * 100;
  },
  calculatePeriodStats(groupedData, periods) {
    const stats = {
      averagePerPeriod: 0,
      maxPerPeriod: 0,
      minPerPeriod: Number.POSITIVE_INFINITY,
      totalPeriods: periods.length,
      periodsWithGrowth: 0,
      periodsWithDecline: 0,
      periodsStable: 0
    };
    if (periods.length === 0) return stats;
    let totalCount = 0;
    let previousCount = 0;
    periods.forEach((period, index) => {
      const count = groupedData[period]?.count || 0;
      totalCount += count;
      stats.maxPerPeriod = Math.max(stats.maxPerPeriod, count);
      stats.minPerPeriod = Math.min(stats.minPerPeriod, count);
      if (index > 0) {
        if (count > previousCount) {
          stats.periodsWithGrowth++;
        } else if (count < previousCount) {
          stats.periodsWithDecline++;
        } else {
          stats.periodsStable++;
        }
      }
      previousCount = count;
    });
    stats.averagePerPeriod = totalCount / periods.length;
    stats.minPerPeriod = stats.minPerPeriod === Number.POSITIVE_INFINITY ? 0 : stats.minPerPeriod;
    return stats;
  },
  async getActiveInactiveRatio(storeId, params) {
    const { includeDetails = false, includeHierarchy = false } = params;
    const [activeCount, inactiveCount, totalCount] = await Promise.all([
      db.category.count({ where: { status: true, storeId } }),
      db.category.count({ where: { status: false, storeId } }),
      db.category.count({ where: { storeId } })
    ]);
    const activePercentage = totalCount > 0 ? activeCount / totalCount * 100 : 0;
    const inactivePercentage = totalCount > 0 ? inactiveCount / totalCount * 100 : 0;
    const hygieneScore = activePercentage;
    const result = {
      active: {
        count: activeCount,
        percentage: Math.round(activePercentage * 100) / 100
      },
      inactive: {
        count: inactiveCount,
        percentage: Math.round(inactivePercentage * 100) / 100
      },
      total: totalCount,
      hygieneScore: Math.round(hygieneScore * 100) / 100,
      metadata: {
        description: "Taxa de categorias ativas vs inativas",
        chartType: "donut",
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    if (includeDetails) {
      const [activeCategories, inactiveCategories] = await Promise.all([
        db.category.findMany({
          where: { status: true, storeId },
          select: {
            id: true,
            name: true,
            code: true,
            createdAt: true,
            updatedAt: true,
            _count: {
              select: {
                children: true,
                products: true
              }
            }
          },
          orderBy: { createdAt: "desc" },
          take: 10
          // Limitar para no sobrecarregar
        }),
        db.category.findMany({
          where: { status: false, storeId },
          select: {
            id: true,
            name: true,
            code: true,
            createdAt: true,
            updatedAt: true,
            _count: {
              select: {
                children: true,
                products: true
              }
            }
          },
          orderBy: { updatedAt: "desc" },
          take: 10
          // Limitar para no sobrecarregar
        })
      ]);
      result.active.recentCategories = activeCategories;
      result.inactive.recentCategories = inactiveCategories;
    }
    if (includeHierarchy) {
      const [
        activeWithChildren,
        inactiveWithChildren,
        activeWithoutChildren,
        inactiveWithoutChildren
      ] = await Promise.all([
        db.category.count({
          where: {
            storeId,
            status: true,
            children: { some: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: false,
            children: { some: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: true,
            children: { none: {} }
          }
        }),
        db.category.count({
          where: {
            storeId,
            status: false,
            children: { none: {} }
          }
        })
      ]);
      result.hierarchy = {
        activeWithChildren,
        inactiveWithChildren,
        activeWithoutChildren,
        inactiveWithoutChildren,
        totalWithChildren: activeWithChildren + inactiveWithChildren,
        totalWithoutChildren: activeWithoutChildren + inactiveWithoutChildren
      };
    }
    return result;
  },
  async getActiveInactiveTrend(storeId, params) {
    const { period = "month", startDate, endDate } = params;
    const where = {
      storeId
    };
    if (startDate || endDate) {
      where.updatedAt = {};
      if (startDate) {
        where.updatedAt.gte = startDate;
      }
      if (endDate) {
        where.updatedAt.lte = endDate;
      }
    }
    const categories = await db.category.findMany({
      where,
      select: {
        id: true,
        name: true,
        status: true,
        createdAt: true,
        updatedAt: true
      },
      orderBy: {
        updatedAt: "asc"
      }
    });
    const groupedData = CategoryQueries.groupByPeriod(categories, period);
    const trendData = {};
    for (const periodKey of Object.keys(groupedData)) {
      const periodCategories = groupedData[periodKey].categories;
      const active = periodCategories.filter((cat) => cat.status).length;
      const inactive = periodCategories.filter((cat) => !cat.status).length;
      trendData[periodKey] = {
        active,
        inactive,
        total: active + inactive
      };
    }
    return {
      trendData,
      metadata: {
        period,
        startDate: startDate || null,
        endDate: endDate || null,
        description: `Tend\xEAncia de categorias ativas vs inativas por ${period}`,
        chartType: "line"
      }
    };
  }
};

// src/features/category/category.controller.ts
var CategoryController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const storeId = request.store?.id;
      const body = request.body;
      const result = await CategoryCommands.create({
        ...body,
        storeId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Category with this name or code already exists"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await CategoryQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Category not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = request.body;
      const result = await CategoryCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Category with this name or code already exists"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await CategoryCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Cannot delete category with children or products"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkDelete(request, reply) {
    try {
      const { ids } = request.body;
      if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return reply.status(400).send({
          error: "Category IDs are required and must be a non-empty array"
        });
      }
      const result = await CategoryCommands.bulkDelete(ids);
      return reply.send({
        deleted: result.deleted,
        errors: result.errors,
        message: `Successfully deleted ${result.deleted} categories${result.errors.length > 0 ? ` with ${result.errors.length} errors` : ""}`
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: error.message || "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, parentId } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CategoryQueries.list({
        page,
        limit,
        search,
        status,
        parentId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await CategoryQueries.getActive(request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Categories not found"
        });
      }
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await CategoryQueries.getStats(request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Categories not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, page = 1, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CategoryQueries.search(q, storeId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRootCategories(request, reply) {
    try {
      const { status } = request.query;
      const result = await CategoryQueries.getRootCategories(status);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getChildren(request, reply) {
    try {
      const { id } = request.params;
      const result = await CategoryQueries.getChildren(id, request.store?.id);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getHierarchy(request, reply) {
    try {
      const result = await CategoryQueries.getHierarchy(request.store?.id);
      return reply.send({ categories: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCode(request, reply) {
    try {
      const { code } = request.params;
      const result = await CategoryQueries.getByCode(code, request.store?.id);
      if (!result) {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await CategoryCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async moveToParent(request, reply) {
    try {
      const { id } = request.params;
      const { parentId } = request.body;
      const result = await CategoryCommands.moveToParent(id, parentId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Category not found"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid parent category reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === RELATRIOS ===
  async getTopCategoriesByProducts(request, reply) {
    try {
      const {
        limit = 10,
        status,
        includeInactive = false,
        includeProductDetails = false
      } = request.query;
      const result = await CategoryQueries.getTopCategoriesByProductsWithDetails(
        request.store?.id,
        {
          limit: Number.parseInt(limit),
          status,
          includeInactive: includeInactive === "true",
          includeProductDetails: includeProductDetails === "true"
        }
      );
      return reply.send({
        categories: result,
        metadata: {
          total: result.length,
          limit: Number.parseInt(limit),
          description: "Top categorias com mais produtos",
          chartType: "horizontalBar",
          recommendedLimit: Math.min(Number.parseInt(limit), 10)
        }
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCategoryCreationEvolution(request, reply) {
    try {
      const {
        period = "month",
        startDate,
        endDate,
        status,
        includeInactive = false,
        includeDetails = false
      } = request.query;
      const startDateObj = startDate ? new Date(startDate) : void 0;
      const endDateObj = endDate ? new Date(endDate) : void 0;
      if (startDateObj && Number.isNaN(startDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de in\xEDcio inv\xE1lida"
        });
      }
      if (endDateObj && Number.isNaN(endDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de fim inv\xE1lida"
        });
      }
      if (startDateObj && endDateObj && startDateObj > endDateObj) {
        return reply.status(400).send({
          error: "Data de in\xEDcio deve ser anterior \xE0 data de fim"
        });
      }
      const result = await CategoryQueries.getCategoryCreationEvolutionDetailed(request.store?.id, {
        period,
        startDate: startDateObj,
        endDate: endDateObj,
        status,
        includeInactive: includeInactive === "true",
        includeDetails: includeDetails === "true"
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActiveInactiveRatio(request, reply) {
    try {
      const { includeDetails = false, includeHierarchy = false } = request.query;
      const result = await CategoryQueries.getActiveInactiveRatio(request.store?.id, {
        includeDetails: includeDetails === "true",
        includeHierarchy: includeHierarchy === "true"
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActiveInactiveTrend(request, reply) {
    try {
      const { period = "month", startDate, endDate } = request.query;
      const startDateObj = startDate ? new Date(startDate) : void 0;
      const endDateObj = endDate ? new Date(endDate) : void 0;
      if (startDateObj && Number.isNaN(startDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de in\xEDcio inv\xE1lida"
        });
      }
      if (endDateObj && Number.isNaN(endDateObj.getTime())) {
        return reply.status(400).send({
          error: "Data de fim inv\xE1lida"
        });
      }
      if (startDateObj && endDateObj && startDateObj > endDateObj) {
        return reply.status(400).send({
          error: "Data de in\xEDcio deve ser anterior \xE0 data de fim"
        });
      }
      const result = await CategoryQueries.getActiveInactiveTrend(request.store?.id, {
        period,
        startDate: startDateObj,
        endDate: endDateObj
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/category/category.schema.ts
var createCategorySchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      description: { type: "string" },
      code: { type: "string" },
      status: { type: "boolean", default: true },
      color: { type: "string" },
      icon: { type: "string" },
      parentId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var updateCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      description: { type: "string" },
      code: { type: "string" },
      status: { type: "boolean" },
      color: { type: "string" },
      icon: { type: "string" },
      parentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var getCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        code: { type: "string", nullable: true },
        status: { type: "boolean" },
        color: { type: "string", nullable: true },
        icon: { type: "string", nullable: true },
        parentId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var listCategoriesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" },
      parentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteCategorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        parent: { type: "object", nullable: true },
        children: { type: "array" },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            children: { type: "number" },
            products: { type: "number" }
          }
        }
      }
    }
  }
};
var getChildrenSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getRootCategoriesSchema = {
  querystring: {
    type: "object",
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: { type: "object", nullable: true },
              children: { type: "array" },
              products: { type: "array" },
              _count: {
                type: "object",
                properties: {
                  children: { type: "number" },
                  products: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getTopCategoriesByProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      limit: {
        type: "number",
        minimum: 1,
        maximum: 50,
        default: 10,
        description: "N\xFAmero m\xE1ximo de categorias a retornar (recomendado: 5-10 para gr\xE1ficos)"
      },
      status: {
        type: "boolean",
        description: "Filtrar por status da categoria (true = ativa, false = inativa)"
      },
      includeInactive: {
        type: "boolean",
        default: false,
        description: "Incluir categorias inativas no resultado"
      },
      includeProductDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes dos produtos em cada categoria"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              status: { type: "boolean" },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true },
              parentId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              parent: {
                type: "object",
                nullable: true,
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  description: { type: "string", nullable: true },
                  code: { type: "string", nullable: true }
                }
              },
              products: {
                type: "array",
                nullable: true,
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    product: {
                      type: "object",
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" },
                        description: { type: "string", nullable: true },
                        status: { type: "boolean" },
                        sku: { type: "string", nullable: true },
                        price: { type: "number", nullable: true },
                        stock: { type: "number", nullable: true }
                      }
                    }
                  }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  children: { type: "number" }
                }
              }
            }
          }
        },
        metadata: {
          type: "object",
          properties: {
            total: { type: "number" },
            limit: { type: "number" },
            description: { type: "string" },
            chartType: { type: "string" },
            recommendedLimit: { type: "number" }
          }
        }
      }
    }
  }
};
var getCategoryCreationEvolutionSchema = {
  querystring: {
    type: "object",
    properties: {
      period: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month",
        description: "Per\xEDodo de agrupamento dos dados"
      },
      startDate: {
        type: "string",
        format: "date",
        description: "Data de in\xEDcio do per\xEDodo (YYYY-MM-DD)"
      },
      endDate: {
        type: "string",
        format: "date",
        description: "Data de fim do per\xEDodo (YYYY-MM-DD)"
      },
      status: {
        type: "boolean",
        description: "Filtrar por status da categoria (true = ativa, false = inativa)"
      },
      includeInactive: {
        type: "boolean",
        default: false,
        description: "Incluir categorias inativas no resultado"
      },
      includeDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes adicionais das categorias"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        data: {
          type: "object",
          additionalProperties: {
            type: "object",
            properties: {
              count: { type: "number" },
              categories: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    status: { type: "boolean" },
                    createdAt: { type: "string", format: "date-time" },
                    parent: {
                      type: "object",
                      nullable: true,
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" }
                      }
                    },
                    _count: {
                      type: "object",
                      nullable: true,
                      properties: {
                        children: { type: "number" },
                        products: { type: "number" }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        periodStats: {
          type: "object",
          properties: {
            averagePerPeriod: { type: "number" },
            maxPerPeriod: { type: "number" },
            minPerPeriod: { type: "number" },
            totalPeriods: { type: "number" },
            periodsWithGrowth: { type: "number" },
            periodsWithDecline: { type: "number" },
            periodsStable: { type: "number" }
          }
        },
        metadata: {
          type: "object",
          properties: {
            totalCategories: { type: "number" },
            activeCategories: { type: "number" },
            inactiveCategories: { type: "number" },
            period: { type: "string" },
            startDate: { type: "string", nullable: true },
            endDate: { type: "string", nullable: true },
            growthRate: { type: "number" },
            description: { type: "string" },
            chartType: { type: "string" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getActiveInactiveRatioSchema = {
  querystring: {
    type: "object",
    properties: {
      includeDetails: {
        type: "boolean",
        default: false,
        description: "Incluir detalhes das categorias recentes"
      },
      includeHierarchy: {
        type: "boolean",
        default: false,
        description: "Incluir an\xE1lise hier\xE1rquica das categorias"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        active: {
          type: "object",
          properties: {
            count: { type: "number" },
            percentage: { type: "number" },
            recentCategories: {
              type: "array",
              nullable: true,
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  code: { type: "string", nullable: true },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  _count: {
                    type: "object",
                    properties: {
                      children: { type: "number" },
                      products: { type: "number" }
                    }
                  }
                }
              }
            }
          }
        },
        inactive: {
          type: "object",
          properties: {
            count: { type: "number" },
            percentage: { type: "number" },
            recentCategories: {
              type: "array",
              nullable: true,
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  code: { type: "string", nullable: true },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  _count: {
                    type: "object",
                    properties: {
                      children: { type: "number" },
                      products: { type: "number" }
                    }
                  }
                }
              }
            }
          }
        },
        total: { type: "number" },
        hygieneScore: { type: "number" },
        hierarchy: {
          type: "object",
          nullable: true,
          properties: {
            activeWithChildren: { type: "number" },
            inactiveWithChildren: { type: "number" },
            activeWithoutChildren: { type: "number" },
            inactiveWithoutChildren: { type: "number" },
            totalWithChildren: { type: "number" },
            totalWithoutChildren: { type: "number" }
          }
        },
        metadata: {
          type: "object",
          properties: {
            description: { type: "string" },
            chartType: { type: "string" },
            lastUpdated: { type: "string", format: "date-time" }
          }
        }
      }
    }
  }
};
var getActiveInactiveTrendSchema = {
  querystring: {
    type: "object",
    properties: {
      period: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "month",
        description: "Per\xEDodo de agrupamento dos dados"
      },
      startDate: {
        type: "string",
        format: "date",
        description: "Data de in\xEDcio do per\xEDodo (YYYY-MM-DD)"
      },
      endDate: {
        type: "string",
        format: "date",
        description: "Data de fim do per\xEDodo (YYYY-MM-DD)"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        trendData: {
          type: "object",
          additionalProperties: {
            type: "object",
            properties: {
              active: { type: "number" },
              inactive: { type: "number" },
              total: { type: "number" }
            }
          }
        },
        metadata: {
          type: "object",
          properties: {
            period: { type: "string" },
            startDate: { type: "string", nullable: true },
            endDate: { type: "string", nullable: true },
            description: { type: "string" },
            chartType: { type: "string" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var bulkDeleteCategoriesSchema = {
  body: {
    type: "object",
    required: ["ids"],
    properties: {
      ids: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        deleted: { type: "number" },
        errors: {
          type: "array",
          items: { type: "string" }
        },
        message: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var CategorySchemas = {
  create: createCategorySchema,
  update: updateCategorySchema,
  get: getCategorySchema,
  delete: deleteCategorySchema,
  list: listCategoriesSchema,
  updateStatus: updateStatusSchema,
  getChildren: getChildrenSchema,
  getRoot: getRootCategoriesSchema,
  getTopCategoriesByProducts: getTopCategoriesByProductsSchema,
  getCategoryCreationEvolution: getCategoryCreationEvolutionSchema,
  getActiveInactiveRatio: getActiveInactiveRatioSchema,
  getActiveInactiveTrend: getActiveInactiveTrendSchema,
  bulkDelete: bulkDeleteCategoriesSchema
};

// src/features/category/category.routes.ts
async function CategoryRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: CategorySchemas.create,
    handler: CategoryController.create
  });
  fastify2.get("/", {
    schema: CategorySchemas.list,
    handler: CategoryController.list
  });
  fastify2.post("/bulk-delete", {
    schema: CategorySchemas.bulkDelete,
    handler: CategoryController.bulkDelete
  });
  fastify2.get("/:id", {
    schema: CategorySchemas.get,
    handler: CategoryController.get
  });
  fastify2.put("/:id", {
    schema: CategorySchemas.update,
    handler: CategoryController.update
  });
  fastify2.delete("/:id", {
    schema: CategorySchemas.delete,
    handler: CategoryController.delete
  });
  fastify2.get("/active", {
    handler: CategoryController.getActive
  });
  fastify2.get("/stats", {
    handler: CategoryController.getStats
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          q: { type: "string" },
          limit: { type: "number" }
        },
        required: ["q"]
      }
    },
    handler: CategoryController.search
  });
  fastify2.get("/root", {
    schema: CategorySchemas.getRoot,
    handler: CategoryController.getRootCategories
  });
  fastify2.get("/:id/children", {
    schema: CategorySchemas.getChildren,
    handler: CategoryController.getChildren
  });
  fastify2.get("/hierarchy", {
    handler: CategoryController.getHierarchy
  });
  fastify2.get("/code/:code", {
    schema: {
      params: {
        type: "object",
        properties: {
          code: { type: "string" }
        },
        required: ["code"]
      }
    },
    handler: CategoryController.getByCode
  });
  fastify2.patch("/:id/status", {
    schema: CategorySchemas.updateStatus,
    handler: CategoryController.updateStatus
  });
  fastify2.patch("/:id/move", {
    schema: {
      params: {
        type: "object",
        properties: {
          id: { type: "string" }
        },
        required: ["id"]
      },
      body: {
        type: "object",
        properties: {
          parentId: { type: "string", nullable: true }
        }
      }
    },
    handler: CategoryController.moveToParent
  });
  fastify2.get("/reports/top-by-products", {
    schema: CategorySchemas.getTopCategoriesByProducts,
    handler: CategoryController.getTopCategoriesByProducts
  });
  fastify2.get("/reports/creation-evolution", {
    schema: CategorySchemas.getCategoryCreationEvolution,
    handler: CategoryController.getCategoryCreationEvolution
  });
  fastify2.get("/reports/active-inactive-ratio", {
    schema: CategorySchemas.getActiveInactiveRatio,
    handler: CategoryController.getActiveInactiveRatio
  });
  fastify2.get("/reports/active-inactive-trend", {
    schema: CategorySchemas.getActiveInactiveTrend,
    handler: CategoryController.getActiveInactiveTrend
  });
}

// src/features/movement/queries/movement.queries.ts
var MovementQueries = {
  async getById(id) {
    console.log("MovementQueries.getById: Searching for movement with id:", id);
    const movement = await db.movement.findUnique({
      where: { id },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!movement) {
      console.log("MovementQueries.getById: Movement not found");
      return null;
    }
    console.log("MovementQueries.getById: Found movement with relations:", {
      id: movement.id,
      storeId: movement.storeId,
      productId: movement.productId,
      supplierId: movement.supplierId,
      userId: movement.userId,
      store: movement.store,
      product: movement.product,
      supplier: movement.supplier,
      user: movement.user
    });
    const result = {
      ...movement,
      store: movement.store || null,
      product: movement.product || null,
      supplier: movement.supplier || null,
      user: movement.user || null
    };
    console.log("MovementQueries.getById: Final result:", JSON.stringify(result, null, 2));
    return result;
  },
  async list(params) {
    const {
      page = 1,
      limit = 10,
      search,
      type,
      storeId,
      productId,
      supplierId,
      startDate,
      endDate
    } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (type) {
      where.type = type;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (productId) {
      where.productId = productId;
    }
    if (supplierId) {
      where.supplierId = supplierId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    if (search) {
      where.OR = [
        {
          product: {
            name: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          store: {
            name: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          supplier: {
            corporateName: {
              contains: search,
              mode: "insensitive"
            }
          }
        },
        {
          batch: {
            contains: search,
            mode: "insensitive"
          }
        },
        {
          note: {
            contains: search,
            mode: "insensitive"
          }
        }
      ];
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    if (items.length > 0) {
      console.log("MovementQueries.list - Sample item:", {
        movementId: items[0].id,
        storeId: items[0].storeId,
        store: items[0].store,
        productId: items[0].productId,
        product: items[0].product,
        supplierId: items[0].supplierId,
        supplier: items[0].supplier,
        userId: items[0].userId,
        user: items[0].user
      });
    }
    const serializedItems = items.map((item) => {
      const serialized = {
        ...item,
        store: item.store && Object.keys(item.store).length > 0 ? item.store : null,
        product: item.product && Object.keys(item.product).length > 0 ? item.product : null,
        supplier: item.supplier && Object.keys(item.supplier).length > 0 ? item.supplier : null,
        user: item.user && Object.keys(item.user).length > 0 ? item.user : null
      };
      if (item.storeId && !serialized.store) {
        console.log(`Warning: Movement ${item.id} has storeId ${item.storeId} but store is empty`);
      }
      if (item.productId && !serialized.product) {
        console.log(
          `Warning: Movement ${item.id} has productId ${item.productId} but product is empty`
        );
      }
      return serialized;
    });
    return {
      items: serializedItems,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, storeId, params = {}) {
    const { page = 1, limit = 10 } = params;
    const skip2 = (page - 1) * limit;
    const where = {
      storeId,
      OR: [
        {
          product: {
            name: {
              contains: term,
              mode: "insensitive"
            }
          }
        },
        {
          store: {
            name: {
              contains: term,
              mode: "insensitive"
            }
          }
        },
        {
          supplier: {
            corporateName: {
              contains: term,
              mode: "insensitive"
            }
          }
        },
        {
          batch: {
            contains: term,
            mode: "insensitive"
          }
        }
      ]
    };
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByStore(storeId, params) {
    const { page = 1, limit = 10, type, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = { storeId };
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByProduct(productId, params) {
    const { page = 1, limit = 10, type, startDate, endDate, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = { productId };
    if (storeId) {
      where.storeId = storeId;
    }
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getBySupplier(supplierId, params) {
    const { page = 1, limit = 10, type, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = { supplierId };
    if (type) {
      where.type = type;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStockHistory(productId, storeId, params) {
    const { startDate, endDate } = params;
    const where = { productId, storeId };
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    return await db.movement.findMany({
      where,
      orderBy: { createdAt: "asc" },
      select: {
        id: true,
        type: true,
        quantity: true,
        balanceAfter: true,
        createdAt: true,
        batch: true,
        price: true,
        note: true,
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
  },
  async getCurrentStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    let stock = 0;
    for (const movement of movements) {
      if (movement.type === "INBOUND") {
        stock += movement.quantity;
      } else if (movement.type === "OUTBOUND" || movement.type === "LOSS") {
        stock -= movement.quantity;
      }
    }
    return Math.max(0, stock);
  },
  async getStats() {
    const [
      total,
      inbound,
      outbound,
      loss,
      totalValue,
      averageValue,
      _byType,
      byStore,
      byProduct,
      bySupplier
    ] = await Promise.all([
      db.movement.count(),
      db.movement.count({ where: { type: "INBOUND" } }),
      db.movement.count({ where: { type: "OUTBOUND" } }),
      db.movement.count({ where: { type: "LOSS" } }),
      db.movement.aggregate({
        _sum: {
          price: true
        }
      }),
      db.movement.aggregate({
        _avg: {
          price: true
        }
      }),
      db.movement.groupBy({
        by: ["type"],
        _count: {
          id: true
        }
      }),
      db.movement.groupBy({
        by: ["storeId"],
        _count: {
          id: true
        },
        _sum: {
          price: true
        }
      }),
      db.movement.groupBy({
        by: ["productId"],
        _count: {
          id: true
        },
        _sum: {
          quantity: true
        }
      }),
      db.movement.groupBy({
        by: ["supplierId"],
        _count: {
          id: true
        },
        _sum: {
          price: true
        },
        where: {
          supplierId: {
            not: null
          }
        }
      })
    ]);
    const storeIds = byStore.map((item) => item.storeId);
    const productIds = byProduct.map((item) => item.productId);
    const supplierIds = bySupplier.map((item) => item.supplierId).filter(Boolean);
    const [stores, products, suppliers] = await Promise.all([
      storeIds.length > 0 ? db.store.findMany({
        where: { id: { in: storeIds } },
        select: { id: true, name: true }
      }) : [],
      productIds.length > 0 ? db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true, name: true }
      }) : [],
      supplierIds.length > 0 ? db.supplier.findMany({
        where: { id: { in: supplierIds } },
        select: { id: true, corporateName: true }
      }) : []
    ]);
    const storeMap = new Map(stores.map((store) => [store.id, store.name]));
    const productMap = new Map(
      products.map((product) => [product.id, product.name])
    );
    const supplierMap = new Map(
      suppliers.map((supplier) => [supplier.id, supplier.corporateName])
    );
    return {
      total,
      inbound,
      outbound,
      loss,
      totalValue: totalValue._sum.price || 0,
      averageValue: averageValue._avg.price || 0,
      byType: {
        INBOUND: inbound,
        OUTBOUND: outbound,
        LOSS: loss
      },
      byStore: byStore.map((item) => ({
        storeId: item.storeId,
        storeName: storeMap.get(item.storeId) || "Unknown",
        count: item._count.id,
        totalValue: item._sum.price || 0
      })),
      byProduct: byProduct.map((item) => ({
        productId: item.productId,
        productName: productMap.get(item.productId) || "Unknown",
        count: item._count.id,
        totalQuantity: item._sum.quantity || 0
      })),
      bySupplier: bySupplier.map((item) => ({
        supplierId: item.supplierId,
        supplierName: supplierMap.get(item.supplierId) || "Unknown",
        count: item._count.id,
        totalValue: item._sum.price || 0
      }))
    };
  },
  async getLowStockProducts(storeId) {
    const where = {};
    if (storeId) {
      where.storeId = storeId;
    }
    const products = await db.product.findMany({
      where: {
        ...where,
        status: true
      },
      include: {
        movements: {
          where: {
            storeId: storeId || void 0
          },
          orderBy: {
            createdAt: "desc"
          }
        },
        store: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const lowStockProducts = [];
    for (const product of products) {
      const currentStock = await MovementQueries.getCurrentStock(product.id, product.storeId);
      const alertThreshold = Math.floor(product.stockMin * product.alertPercentage / 100);
      if (currentStock <= alertThreshold) {
        lowStockProducts.push({
          product: {
            id: product.id,
            name: product.name,
            unitOfMeasure: product.unitOfMeasure
          },
          store: product.store,
          currentStock,
          stockMin: product.stockMin,
          stockMax: product.stockMax,
          alertThreshold,
          status: currentStock === 0 ? "OUT_OF_STOCK" : "LOW_STOCK"
        });
      }
    }
    return lowStockProducts.sort((a, b) => a.currentStock - b.currentStock);
  },
  // === FUNES ADICIONAIS DE MOVIMENTAO ===
  async getMovementReport(params) {
    const { storeId, productId, supplierId, type, startDate, endDate } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        store: { select: { id: true, name: true } },
        product: { select: { id: true, name: true, unitOfMeasure: true } },
        supplier: { select: { id: true, corporateName: true } },
        user: { select: { id: true, name: true, email: true } }
      }
    });
    return {
      movements,
      summary: {
        total: movements.length,
        totalValue: movements.reduce((sum, m) => sum + (Number(m.price) || 0), 0),
        byType: movements.reduce(
          (acc, m) => {
            acc[m.type] = (acc[m.type] || 0) + 1;
            return acc;
          },
          {}
        )
      }
    };
  },
  async getVerifiedMovements(params) {
    const { page = 1, limit = 10, storeId, verified, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (verified !== void 0) where.verified = verified;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getCancelledMovements(params) {
    const { page = 1, limit = 10, storeId, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = { cancelled: true };
    if (storeId) where.storeId = storeId;
    if (startDate || endDate) {
      where.cancelledAt = {};
      if (startDate) where.cancelledAt.gte = new Date(startDate);
      if (endDate) where.cancelledAt.lte = new Date(endDate);
    }
    const [items, total] = await Promise.all([
      db.movement.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { cancelledAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          product: {
            select: {
              id: true,
              name: true,
              unitOfMeasure: true
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.movement.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getMovementAnalytics(params) {
    const { storeId, productId, supplierId, startDate, endDate } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const [
      totalMovements,
      totalValue,
      averageValue,
      byType,
      byMonth,
      byStore,
      byProduct,
      bySupplier,
      verifiedCount,
      cancelledCount
    ] = await Promise.all([
      db.movement.count({ where }),
      db.movement.aggregate({
        where,
        _sum: { price: true }
      }),
      db.movement.aggregate({
        where,
        _avg: { price: true }
      }),
      db.movement.groupBy({
        by: ["type"],
        where,
        _count: { id: true },
        _sum: { quantity: true, price: true }
      }),
      db.movement.groupBy({
        by: ["createdAt"],
        where,
        _count: { id: true },
        _sum: { price: true },
        orderBy: { createdAt: "asc" }
      }),
      db.movement.groupBy({
        by: ["storeId"],
        where,
        _count: { id: true },
        _sum: { price: true }
      }),
      db.movement.groupBy({
        by: ["productId"],
        where,
        _count: { id: true },
        _sum: { quantity: true, price: true }
      }),
      db.movement.groupBy({
        by: ["supplierId"],
        where: { ...where, supplierId: { not: null } },
        _count: { id: true },
        _sum: { price: true }
      }),
      db.movement.count({ where: { ...where, verified: true } }),
      db.movement.count({ where: { ...where, cancelled: true } })
    ]);
    const storeIds = byStore.map((item) => item.storeId);
    const productIds = byProduct.map((item) => item.productId);
    const supplierIds = bySupplier.map((item) => item.supplierId).filter(Boolean);
    const [stores, products, suppliers] = await Promise.all([
      storeIds.length > 0 ? db.store.findMany({
        where: { id: { in: storeIds } },
        select: { id: true, name: true }
      }) : [],
      productIds.length > 0 ? db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true, name: true }
      }) : [],
      supplierIds.length > 0 ? db.supplier.findMany({
        where: { id: { in: supplierIds } },
        select: { id: true, corporateName: true }
      }) : []
    ]);
    const storeMap = new Map(stores.map((store) => [store.id, store.name]));
    const productMap = new Map(
      products.map(
        (product) => [product.id, product.name]
      )
    );
    const supplierMap = new Map(
      suppliers.map((supplier) => [supplier.id, supplier.corporateName])
    );
    return {
      summary: {
        totalMovements,
        totalValue: totalValue._sum.price || 0,
        averageValue: averageValue._avg.price || 0,
        verifiedCount,
        cancelledCount,
        verificationRate: totalMovements > 0 ? verifiedCount / totalMovements * 100 : 0,
        cancellationRate: totalMovements > 0 ? cancelledCount / totalMovements * 100 : 0
      },
      byType: byType.map((item) => ({
        type: item.type,
        count: item._count.id,
        quantity: item._sum.quantity || 0,
        value: item._sum.price || 0
      })),
      byMonth: byMonth.map((item) => ({
        month: item.createdAt.toISOString().substring(0, 7),
        count: item._count.id,
        value: item._sum.price || 0
      })),
      byStore: byStore.map((item) => ({
        storeId: item.storeId,
        storeName: storeMap.get(item.storeId) || "Unknown",
        count: item._count.id,
        value: item._sum.price || 0
      })),
      byProduct: byProduct.map((item) => ({
        productId: item.productId,
        productName: productMap.get(item.productId) || "Unknown",
        count: item._count.id,
        quantity: item._sum.quantity || 0,
        value: item._sum.price || 0
      })),
      bySupplier: bySupplier.map((item) => ({
        supplierId: item.supplierId,
        supplierName: supplierMap.get(item.supplierId) || "Unknown",
        count: item._count.id,
        value: item._sum.price || 0
      }))
    };
  },
  async getProductSummary(productId, params) {
    const { startDate, endDate, storeId } = params;
    const product = await db.product.findUnique({
      where: { id: productId },
      select: {
        id: true,
        name: true,
        unitOfMeasure: true,
        stockMin: true,
        stockMax: true,
        alertPercentage: true
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const where = { productId };
    if (storeId) {
      where.storeId = storeId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      orderBy: { createdAt: "desc" },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const totalMovements = movements.length;
    const inboundMovements = movements.filter((m) => m.type === "INBOUND");
    const outboundMovements = movements.filter((m) => m.type === "OUTBOUND");
    const lossMovements = movements.filter((m) => m.type === "LOSS");
    const totalInbound = inboundMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalOutbound = outboundMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalLoss = lossMovements.reduce((sum, m) => sum + m.quantity, 0);
    const totalValue = movements.reduce((sum, m) => sum + (Number(m.price) || 0), 0);
    const averageValue = totalMovements > 0 ? totalValue / totalMovements : 0;
    const stores = [...new Set(movements.map((m) => m.storeId))];
    const currentStockByStore = await Promise.all(
      stores.map(async (storeId2) => {
        const currentStock = await MovementQueries.getCurrentStock(productId, storeId2);
        const store = movements.find((m) => m.storeId === storeId2)?.store;
        return {
          storeId: storeId2,
          storeName: store?.name || "Unknown",
          currentStock
        };
      })
    );
    return {
      product: {
        id: product.id,
        name: product.name,
        unitOfMeasure: product.unitOfMeasure,
        stockMin: product.stockMin,
        stockMax: product.stockMax,
        alertPercentage: product.alertPercentage
      },
      period: {
        startDate: startDate || null,
        endDate: endDate || null,
        storeId: storeId || null
      },
      statistics: {
        totalMovements,
        inbound: {
          count: inboundMovements.length,
          quantity: totalInbound
        },
        saida: {
          count: outboundMovements.length,
          quantity: totalOutbound
        },
        perda: {
          count: lossMovements.length,
          quantity: totalLoss
        },
        totalValue,
        averageValue
      },
      currentStockByStore,
      recentMovements: movements.slice(0, 10).map((m) => ({
        id: m.id,
        type: m.type,
        quantity: m.quantity,
        price: m.price,
        batch: m.batch,
        createdAt: m.createdAt,
        store: m.store,
        supplier: m.supplier,
        user: m.user
      }))
    };
  }
};

// src/features/product/queries/product.queries.ts
async function calculateCurrentStock(productId) {
  const movements = await db.movement.findMany({
    where: { productId },
    select: {
      type: true,
      quantity: true
    }
  });
  let currentStock = 0;
  for (const movement of movements) {
    if (movement.type === "INBOUND") {
      currentStock += movement.quantity;
    } else {
      currentStock -= movement.quantity;
    }
  }
  return currentStock;
}
var ProductQueries = {
  async getById(id, storeId) {
    const product = await db.product.findUnique({
      where: { id, storeId },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    if (!product) {
      return null;
    }
    const currentStock = await calculateCurrentStock(product.id);
    const transformedProduct = {
      ...product,
      categories: product.categories.map((pc) => pc.category),
      currentStock
    };
    return transformedProduct;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, categoryIds, supplierId, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (categoryIds && categoryIds.length > 0) {
      where.categories = {
        some: {
          categoryId: { in: categoryIds }
        }
      };
    }
    if (supplierId) {
      where.supplierId = supplierId;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  code: true,
                  color: true,
                  icon: true
                }
              }
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true,
              tradeName: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const itemsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          categories: product.categories.map((pc) => pc.category),
          currentStock
        };
      })
    );
    return {
      items: itemsWithStock,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, params = {}) {
    const { page = 1, limit = 10, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = {
      OR: [
        { name: { contains: term, mode: "insensitive" } },
        { description: { contains: term, mode: "insensitive" } },
        { categories: { some: { category: { name: { contains: term, mode: "insensitive" } } } } },
        { supplier: { corporateName: { contains: term, mode: "insensitive" } } },
        { supplier: { tradeName: { contains: term, mode: "insensitive" } } }
      ]
    };
    if (storeId) {
      where.storeId = storeId;
    }
    const [products, total] = await Promise.all([
      db.product.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          categories: {
            select: {
              category: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  code: true,
                  color: true,
                  icon: true
                }
              }
            }
          },
          supplier: {
            select: {
              id: true,
              corporateName: true,
              cnpj: true,
              tradeName: true
            }
          },
          store: {
            select: {
              id: true,
              name: true,
              cnpj: true
            }
          }
        }
      }),
      db.product.count({ where })
    ]);
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          categories: product.categories.map((pc) => pc.category),
          currentStock
        };
      })
    );
    return {
      items: productsWithStock,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getActive(storeId) {
    const products = await db.product.findMany({
      where: {
        status: true,
        storeId
      },
      orderBy: { createdAt: "desc" },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    const productsWithStock = await Promise.all(
      products.map(async (product) => {
        const currentStock = await calculateCurrentStock(product.id);
        return {
          ...product,
          categories: product.categories.map((pc) => pc.category),
          currentStock
        };
      })
    );
    return productsWithStock;
  },
  async getStats(storeId) {
    const [total, active, inactive] = await Promise.all([
      db.product.count({ where: { storeId } }),
      db.product.count({ where: { status: true, storeId } }),
      db.product.count({ where: { status: false, storeId } })
    ]);
    return {
      total,
      active,
      inactive
    };
  }
};

// src/features/supplier/queries/supplier.queries.ts
var SupplierQueries = {
  async getById(id) {
    const supplier = await db.supplier.findUnique({
      where: { id },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true,
            referencePrice: true,
            stockMin: true,
            stockMax: true
          }
        }
      }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return supplier;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, storeId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (search) {
      where.OR = [
        { corporateName: { contains: search, mode: "insensitive" } },
        { tradeName: { contains: search, mode: "insensitive" } },
        { cnpj: { contains: search } },
        { city: { contains: search, mode: "insensitive" } },
        { state: { contains: search, mode: "insensitive" } }
      ];
    }
    if (status !== void 0) {
      where.status = status;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    const [suppliers, total] = await Promise.all([
      db.supplier.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          responsibles: {
            where: { status: true }
          },
          products: {
            select: {
              id: true,
              name: true,
              status: true
            }
          }
        }
      }),
      db.supplier.count({ where })
    ]);
    return {
      items: suppliers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByCnpj(cnpj, storeId) {
    const supplier = await db.supplier.findUnique({
      where: { cnpj_storeId: { cnpj, storeId: storeId || null } },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return supplier;
  },
  async getByCity(city) {
    return await db.supplier.findMany({
      where: {
        city: { contains: city, mode: "insensitive" },
        status: true
      },
      orderBy: { corporateName: "asc" },
      include: {
        responsibles: {
          where: { status: true }
        }
      }
    });
  },
  async getByState(state) {
    return await db.supplier.findMany({
      where: {
        state: { contains: state, mode: "insensitive" },
        status: true
      },
      orderBy: { corporateName: "asc" },
      include: {
        responsibles: {
          where: { status: true }
        }
      }
    });
  },
  async getActive() {
    return await db.supplier.findMany({
      where: { status: true },
      orderBy: { corporateName: "asc" },
      select: {
        id: true,
        corporateName: true,
        tradeName: true,
        cnpj: true,
        city: true,
        state: true
      }
    });
  },
  async search(term, storeId, params = {}) {
    const { page = 1, limit = 10 } = params;
    const skip2 = (page - 1) * limit;
    const where = {
      status: true,
      storeId,
      OR: [
        { corporateName: { contains: term, mode: "insensitive" } },
        { tradeName: { contains: term, mode: "insensitive" } },
        { cnpj: { contains: term } }
      ]
    };
    const [items, total] = await Promise.all([
      db.supplier.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { corporateName: "asc" },
        select: {
          id: true,
          corporateName: true,
          tradeName: true,
          cnpj: true,
          city: true,
          state: true
        }
      }),
      db.supplier.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStats() {
    const [total, active, inactive, withProducts] = await Promise.all([
      db.supplier.count(),
      db.supplier.count({ where: { status: true } }),
      db.supplier.count({ where: { status: false } }),
      db.supplier.count({
        where: {
          products: {
            some: {}
          }
        }
      })
    ]);
    return {
      total,
      active,
      inactive,
      withProducts,
      withoutProducts: total - withProducts
    };
  },
  async getTopSuppliers(limit = 5) {
    return await db.supplier.findMany({
      where: { status: true },
      orderBy: {
        products: {
          _count: "desc"
        }
      },
      take: limit,
      select: {
        id: true,
        corporateName: true,
        tradeName: true,
        cnpj: true,
        _count: {
          select: { products: true }
        }
      }
    });
  }
};

// src/features/chat/queries/chat.query.ts
var ChatToolbox = {
  // === SERVIOS DE PRODUTOS ===
  async getProducts(params) {
    return await ProductQueries.list(params);
  },
  async getProductById(id, storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getById(id, storeId);
  },
  async searchProducts(term, params = {}) {
    return await ProductQueries.search(term, params);
  },
  async getActiveProducts(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getActive(storeId);
  },
  async getProductStats(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for product queries");
    }
    return await ProductQueries.getStats(storeId);
  },
  // === SERVIOS DE CATEGORIAS ===
  async getCategories(params) {
    return await CategoryQueries.list(params);
  },
  async getCategoryById(id) {
    return await CategoryQueries.getById(id);
  },
  async searchCategories(term, limit = 10, storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.search(term, storeId, { limit });
  },
  async getActiveCategories(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getActive(storeId);
  },
  async getCategoryStats(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getStats(storeId);
  },
  async getCategoryHierarchy(storeId) {
    if (!storeId) {
      throw new Error("Store ID is required for category queries");
    }
    return await CategoryQueries.getHierarchy(storeId);
  },
  // === SERVIOS DE FORNECEDORES ===
  async getSuppliers(params) {
    return await SupplierQueries.list(params);
  },
  async getSupplierById(id) {
    return await SupplierQueries.getById(id);
  },
  async searchSuppliers(term, limit = 10) {
    return await SupplierQueries.search(term, String(limit));
  },
  async getActiveSuppliers() {
    return await SupplierQueries.getActive();
  },
  async getSupplierStats() {
    return await SupplierQueries.getStats();
  },
  // === SERVIOS DE MOVIMENTAES ===
  async getMovements(params) {
    return await MovementQueries.list(params);
  },
  async getMovementById(id) {
    return await MovementQueries.getById(id);
  },
  async getMovementStats() {
    return await MovementQueries.getStats();
  },
  // === MTODO PARA EXECUTAR COMANDOS DINMICOS ===
  async executeCommand(command, params = {}) {
    const [service, method] = command.split(".");
    switch (service) {
      case "products":
        return await this.executeProductCommand(method, params);
      case "categories":
        return await this.executeCategoryCommand(method, params);
      case "suppliers":
        return await this.executeSupplierCommand(method, params);
      case "movements":
        return await this.executeMovementCommand(method, params);
      default:
        throw new Error(`Unknown service: ${service}`);
    }
  },
  async executeProductCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getProducts(params);
      case "getById":
        return await this.getProductById(params.id, params.storeId);
      case "search":
        return await this.searchProducts(params.term, params.limit);
      case "getActive":
        return await this.getActiveProducts();
      case "getStats":
        return await this.getProductStats();
      default:
        throw new Error(`Unknown product method: ${method}`);
    }
  },
  async executeCategoryCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getCategories(params);
      case "getById":
        return await this.getCategoryById(params.id);
      case "search":
        return await this.searchCategories(params.term, params.limit);
      case "getActive":
        return await this.getActiveCategories();
      case "getStats":
        return await this.getCategoryStats();
      case "getHierarchy":
        return await this.getCategoryHierarchy();
      default:
        throw new Error(`Unknown category method: ${method}`);
    }
  },
  async executeSupplierCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getSuppliers(params);
      case "getById":
        return await this.getSupplierById(params.id);
      case "search":
        return await this.searchSuppliers(params.term, params.limit);
      case "getActive":
        return await this.getActiveSuppliers();
      case "getStats":
        return await this.getSupplierStats();
      default:
        throw new Error(`Unknown supplier method: ${method}`);
    }
  },
  async executeMovementCommand(method, params) {
    switch (method) {
      case "list":
        return await this.getMovements(params);
      case "getById":
        return await this.getMovementById(params.id);
      case "getStats":
        return await this.getMovementStats();
      default:
        throw new Error(`Unknown movement method: ${method}`);
    }
  }
};
var ChatQueries = {
  async getById(id) {
    const chatMessage = await db.chatMessage.findUnique({
      where: { id },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    if (!chatMessage) {
      throw new Error("Chat message not found");
    }
    return chatMessage;
  },
  async list(params) {
    const { page = 1, limit = 10, sessionId, userId, storeId } = params;
    const skip2 = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (sessionId) {
      where.sessionId = sessionId;
    }
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    const [items, total] = await Promise.all([
      db.chatMessage.findMany({
        where,
        skip: skip2,
        take: takeLimit,
        orderBy: { createdAt: "desc" },
        include: {
          session: {
            select: {
              id: true,
              userId: true,
              storeId: true,
              title: true
            }
          }
        }
      }),
      db.chatMessage.count({ where })
    ]);
    const formattedItems = items.map((item) => ({
      id: item.id,
      interaction: {
        user: {
          message: item.content,
          timestamp: item.createdAt
        },
        ai: {
          response: item.content,
          timestamp: item.createdAt
        }
      },
      context: item.context,
      options: item.options,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
      session: item.session
    }));
    return {
      items: formattedItems,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  // === FORMATO TRADICIONAL (compatibilidade) ===
  async listTraditional(params) {
    const { page = 1, limit = 10, sessionId, userId, storeId } = params;
    const skip2 = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (sessionId) {
      where.sessionId = sessionId;
    }
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    const [items, total] = await Promise.all([
      db.chatMessage.findMany({
        where,
        skip: skip2,
        take: takeLimit,
        orderBy: { createdAt: "desc" },
        include: {
          session: {
            select: {
              id: true,
              userId: true,
              storeId: true,
              title: true
            }
          }
        }
      }),
      db.chatMessage.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getSessionById(sessionId, params) {
    const { page = 1, limit = 20 } = params || {};
    const skip2 = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const session = await db.chatSession.findUnique({
      where: { id: sessionId },
      include: {
        messages: {
          select: {
            id: true,
            content: true,
            role: true,
            createdAt: true,
            updatedAt: true
          },
          orderBy: { createdAt: "asc" },
          skip: skip2,
          take: takeLimit
        }
      }
    });
    if (!session) {
      throw new Error("Chat session not found");
    }
    const totalMessages = await db.chatMessage.count({
      where: { sessionId }
    });
    const formattedMessages = [];
    for (const message of session.messages) {
      formattedMessages.push({
        id: `${message.id}_user`,
        content: message.content,
        role: message.role,
        createdAt: message.createdAt,
        updatedAt: message.updatedAt
      });
      formattedMessages.push({
        id: `${message.id}_ai`,
        content: message.content,
        isUser: false,
        createdAt: message.createdAt,
        updatedAt: message.updatedAt
      });
    }
    return {
      id: session.id,
      userId: session.userId,
      storeId: session.storeId,
      title: session.title,
      createdAt: session.createdAt,
      updatedAt: session.updatedAt,
      messages: formattedMessages,
      pagination: {
        page,
        limit,
        total: totalMessages,
        totalPages: Math.ceil(totalMessages / limit)
      }
    };
  },
  async getSessions(params) {
    const { page = 1, limit = 10, userId, storeId } = params;
    const skip2 = (page - 1) * Number(limit);
    const takeLimit = Number(limit);
    const where = {};
    if (userId) {
      where.userId = userId;
    }
    if (storeId) {
      where.storeId = storeId;
    }
    const [items, total] = await Promise.all([
      db.chatSession.findMany({
        where,
        skip: skip2,
        take: takeLimit,
        orderBy: { updatedAt: "desc" },
        include: {
          _count: {
            select: {
              messages: true
            }
          }
        }
      }),
      db.chatSession.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getToolbox() {
    return {
      availableServices: {
        products: {
          description: "Servi\xE7os para gerenciar produtos, estoque e categorias",
          methods: [
            "products.list - Listar produtos com filtros",
            "products.getById - Buscar produto por ID",
            "products.search - Buscar produtos por termo",
            "products.getActive - Listar produtos ativos",
            "products.getStats - Estat\xEDsticas de produtos"
          ]
        },
        stores: {
          description: "Servi\xE7os para gerenciar lojas e usu\xE1rios",
          methods: [
            "stores.list - Listar lojas com filtros",
            "stores.getById - Buscar loja por ID",
            "stores.search - Buscar lojas por termo",
            "stores.getActive - Listar lojas ativas",
            "stores.getStats - Estat\xEDsticas de lojas"
          ]
        },
        categories: {
          description: "Servi\xE7os para gerenciar categorias de produtos",
          methods: [
            "categories.list - Listar categorias com filtros",
            "categories.getById - Buscar categoria por ID",
            "categories.search - Buscar categorias por termo",
            "categories.getActive - Listar categorias ativas",
            "categories.getStats - Estat\xEDsticas de categorias",
            "categories.getHierarchy - Hierarquia de categorias"
          ]
        },
        suppliers: {
          description: "Servi\xE7os para gerenciar fornecedores",
          methods: [
            "suppliers.list - Listar fornecedores com filtros",
            "suppliers.getById - Buscar fornecedor por ID",
            "suppliers.search - Buscar fornecedores por termo",
            "suppliers.getActive - Listar fornecedores ativos",
            "suppliers.getStats - Estat\xEDsticas de fornecedores"
          ]
        },
        movements: {
          description: "Servi\xE7os para gerenciar movimenta\xE7\xF5es de estoque",
          methods: [
            "movements.list - Listar movimenta\xE7\xF5es com filtros",
            "movements.getById - Buscar movimenta\xE7\xE3o por ID",
            "movements.getStats - Estat\xEDsticas de movimenta\xE7\xF5es",
            "movements.getRecent - Movimenta\xE7\xF5es recentes"
          ]
        },
        reports: {
          description: "Servi\xE7os para gerenciar relat\xF3rios",
          methods: [
            "reports.list - Listar relat\xF3rios com filtros",
            "reports.getById - Buscar relat\xF3rio por ID",
            "reports.getStats - Estat\xEDsticas de relat\xF3rios"
          ]
        }
      }
    };
  },
  async getAnalytics(params) {
    const { startDate, endDate, userId, storeId } = params;
    const where = {};
    if (userId) {
      where.session = {
        userId
      };
    }
    if (storeId) {
      where.session = {
        ...where.session,
        storeId
      };
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [totalMessages, totalSessions, messagesByDay] = await Promise.all([
      db.chatMessage.count({ where }),
      db.chatSession.count({
        where: userId ? { userId } : storeId ? { storeId } : {}
      }),
      db.chatMessage.groupBy({
        by: ["createdAt"],
        where,
        _count: { id: true },
        orderBy: { createdAt: "desc" },
        take: 30
      })
    ]);
    const averageMessagesPerSession = totalSessions > 0 ? totalMessages / totalSessions : 0;
    return {
      totalMessages,
      totalSessions,
      averageMessagesPerSession: Math.round(averageMessagesPerSession * 100) / 100,
      mostUsedServices: [],
      // Implementar anlise de servios mais usados
      messagesByDay: messagesByDay.map((item) => ({
        date: item.createdAt.toISOString().split("T")[0],
        count: item._count.id
      }))
    };
  },
  async search(term, limit = 10) {
    const messages = await db.chatMessage.findMany({
      where: {
        OR: [{ content: { contains: term, mode: "insensitive" } }]
      },
      take: Number(limit),
      orderBy: { createdAt: "desc" },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    return messages;
  }
};

// src/features/chat/commands/chat.commands.ts
var ChatCommands = {
  // === CRIAO DE SESSO ===
  async createSession(data) {
    const session = await db.chatSession.create({
      data: {
        userId: data.userId,
        storeId: data.storeId,
        title: data.title || "\u{1F4AC} Nova conversa"
      }
    });
    return session;
  },
  // === CRIAO DE MENSAGEM ===
  async createMessage(data) {
    const chatMessage = await db.chatMessage.create({
      data: {
        content: data.content,
        role: data.isFromUser ? "USER" : "ASSISTANT",
        sessionId: data.sessionId,
        context: data.context || {},
        options: data.options || {}
      },
      include: {
        session: {
          select: {
            id: true,
            userId: true,
            storeId: true,
            title: true
          }
        }
      }
    });
    return chatMessage;
  },
  // === PROCESSAMENTO COMPLETO DE MENSAGEM ===
  async processMessage(data) {
    let sessionId = data.context?.sessionId;
    if (!sessionId) {
      const session = await ChatCommands.createSession({
        userId: data.context?.userId || "anonymous",
        storeId: data.context?.storeId,
        title: data.message.substring(0, 50) + (data.message.length > 50 ? "..." : "")
      });
      sessionId = session.id;
    }
    const chatMessage = await ChatCommands.createMessage({
      content: data.message,
      isFromUser: true,
      sessionId,
      context: data.context || {},
      options: data.options || {}
    });
    await ChatCommands.updateSessionTimestamp(sessionId);
    await ChatCommands.updateSessionTitleIntelligent(sessionId);
    return chatMessage;
  },
  // === GERAR TTULO INTELIGENTE ===
  async generateSmartTitle(messages) {
    if (messages.length === 0) return "Nova conversa";
    const recentMessages = messages.slice(-3);
    const allText = recentMessages.map((m) => `${m.message} ${m.response}`).join(" ").toLowerCase();
    if (allText.includes("produto") || allText.includes("estoque") || allText.includes("invent\xE1rio")) {
      if (allText.includes("baixo") || allText.includes("cr\xEDtico")) {
        return "\u{1F4E6} An\xE1lise de Estoque Cr\xEDtico";
      }
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F4CA} Relat\xF3rio de Produtos";
      }
      if (allText.includes("categoria") || allText.includes("categorias")) {
        return "\u{1F4C2} Produtos por Categoria";
      }
      return "\u{1F4E6} Consulta de Produtos";
    }
    if (allText.includes("categoria") || allText.includes("categorias")) {
      if (allText.includes("hierarquia") || allText.includes("estrutura")) {
        return "\u{1F333} Hierarquia de Categorias";
      }
      if (allText.includes("criar") || allText.includes("nova")) {
        return "\u2795 Gest\xE3o de Categorias";
      }
      return "\u{1F4C2} Consulta de Categorias";
    }
    if (allText.includes("loja") || allText.includes("lojas") || allText.includes("store")) {
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F3EA} Relat\xF3rio de Lojas";
      }
      return "\u{1F3EA} Consulta de Lojas";
    }
    if (allText.includes("fornecedor") || allText.includes("fornecedores") || allText.includes("supplier")) {
      if (allText.includes("relat\xF3rio") || allText.includes("relatorio")) {
        return "\u{1F69A} Relat\xF3rio de Fornecedores";
      }
      return "\u{1F69A} Consulta de Fornecedores";
    }
    if (allText.includes("movimenta\xE7\xE3o") || allText.includes("movimenta\xE7\xF5es") || allText.includes("movimento")) {
      if (allText.includes("entrada") || allText.includes("sa\xEDda")) {
        return "\u{1F4C8} Movimenta\xE7\xF5es de Estoque";
      }
      return "\u{1F4C8} Consulta de Movimenta\xE7\xF5es";
    }
    if (allText.includes("relat\xF3rio") || allText.includes("relatorio") || allText.includes("relat\xF3rios")) {
      return "\u{1F4CA} Gera\xE7\xE3o de Relat\xF3rios";
    }
    if (allText.includes("usu\xE1rio") || allText.includes("usuarios") || allText.includes("user")) {
      return "\u{1F465} Gest\xE3o de Usu\xE1rios";
    }
    if (allText.includes("configura\xE7\xE3o") || allText.includes("configuracao") || allText.includes("config")) {
      return "\u2699\uFE0F Configura\xE7\xF5es do Sistema";
    }
    if (allText.includes("ajuda") || allText.includes("help") || allText.includes("como")) {
      return "\u2753 Suporte e Ajuda";
    }
    const firstMessage = messages[0]?.message || "";
    if (firstMessage.length > 0) {
      const truncated = firstMessage.substring(0, 30);
      return truncated.length < firstMessage.length ? `${truncated}...` : truncated;
    }
    return "\u{1F4AC} Conversa Geral";
  },
  // === ATUALIZAR TIMESTAMP DA SESSO ===
  async updateSessionTimestamp(sessionId) {
    await db.chatSession.update({
      where: { id: sessionId },
      data: { updatedAt: /* @__PURE__ */ new Date() }
    });
  },
  // === ATUALIZAR TTULO DA SESSO ===
  async updateSessionTitle(sessionId, title) {
    const session = await db.chatSession.update({
      where: { id: sessionId },
      data: { title }
    });
    return session;
  },
  // === ATUALIZAR TTULO INTELIGENTE ===
  async updateSessionTitleIntelligent(sessionId) {
    const messages = await db.chatMessage.findMany({
      where: { sessionId },
      select: { content: true, role: true },
      orderBy: { createdAt: "asc" }
    });
    const formattedMessages = [];
    for (let i = 0; i < messages.length; i++) {
      if (messages[i].role === "USER") {
        const nextMessage = messages[i + 1];
        const response = nextMessage?.role === "ASSISTANT" ? nextMessage.content : "";
        formattedMessages.push({
          message: messages[i].content,
          response
        });
      }
    }
    const smartTitle = await ChatCommands.generateSmartTitle(formattedMessages);
    await db.chatSession.update({
      where: { id: sessionId },
      data: { title: smartTitle }
    });
    return smartTitle;
  },
  // === EXECUO DE COMANDO DA TOOLBOX ===
  async executeToolboxCommand(command, params = {}) {
    return await ChatToolbox.executeCommand(command, params);
  },
  // === EXECUO DE COMANDO COM CONTEXTO ===
  async executeCommandWithContext(data) {
    const enrichedParams = {
      ...data.params,
      ...data.context?.storeId && { storeId: data.context.storeId },
      ...data.context?.userId && { userId: data.context.userId }
    };
    return await ChatToolbox.executeCommand(data.command, enrichedParams);
  },
  // === DELETAR SESSO ===
  async deleteSession(sessionId) {
    const session = await db.chatSession.findUnique({
      where: { id: sessionId }
    });
    if (!session) {
      throw new Error("Chat session not found");
    }
    await db.chatMessage.deleteMany({
      where: { sessionId }
    });
    await db.chatSession.delete({
      where: { id: sessionId }
    });
    return { success: true };
  },
  // === DELETAR MENSAGEM ===
  async deleteMessage(messageId) {
    const message = await db.chatMessage.findUnique({
      where: { id: messageId }
    });
    if (!message) {
      throw new Error("Chat message not found");
    }
    await db.chatMessage.delete({
      where: { id: messageId }
    });
    return { success: true };
  },
  // === LIMPEZA DE SESSES ANTIGAS ===
  async cleanupOldSessions(daysOld = 30) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    const deletedSessions = await db.chatSession.deleteMany({
      where: {
        updatedAt: {
          lt: cutoffDate
        }
      }
    });
    return {
      deletedSessions: deletedSessions.count,
      cutoffDate
    };
  },
  // === LIMPEZA DE MENSAGENS ANTIGAS ===
  async cleanupOldMessages(daysOld = 30) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    const deletedMessages = await db.chatMessage.deleteMany({
      where: {
        createdAt: {
          lt: cutoffDate
        }
      }
    });
    return {
      deletedMessages: deletedMessages.count,
      cutoffDate
    };
  },
  // === BATCH OPERATIONS ===
  async createMultipleMessages(messages) {
    const createdMessages = await db.chatMessage.createMany({
      data: messages.map((msg) => ({
        content: msg.content,
        isFromUser: msg.isFromUser,
        sessionId: msg.sessionId,
        context: msg.context || {},
        options: msg.options || {}
      }))
    });
    return createdMessages;
  },
  // === MIGRAO DE DADOS ===
  async migrateSessionData(oldSessionId, newSessionId) {
    const updatedMessages = await db.chatMessage.updateMany({
      where: { sessionId: oldSessionId },
      data: { sessionId: newSessionId }
    });
    const oldSession = await db.chatSession.findUnique({
      where: { id: oldSessionId },
      include: { messages: true }
    });
    if (oldSession && oldSession.messages.length === 0) {
      await db.chatSession.delete({
        where: { id: oldSessionId }
      });
    }
    return {
      migratedMessages: updatedMessages.count,
      oldSessionDeleted: oldSession?.messages.length === 0
    };
  }
};

// src/features/chat/chat.controller.ts
var ChatController = {
  // === ENVIO DE MENSAGENS ===
  async sendMessage(request, reply) {
    try {
      const { message, context, options } = request.body;
      const enrichedContext = {
        ...context,
        userId: request.user?.id || context?.userId,
        storeId: request.store?.id || context?.storeId
      };
      const result = await ChatCommands.processMessage({
        message,
        context: enrichedContext,
        options
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("LLM")) {
        return reply.status(503).send({
          error: "Servi\xE7o de IA temporariamente indispon\xEDvel"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === HISTRICO DE CHAT ===
  async getHistory(request, reply) {
    try {
      const { page = 1, limit = 10, sessionId } = request.query;
      const enrichedParams = {
        page,
        limit,
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.list(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === MENSAGENS DE UMA SESSO ESPECFICA ===
  async getSessionMessages(request, reply) {
    try {
      const { sessionId } = request.params;
      const { page = 1, limit = 20 } = request.query;
      const result = await ChatQueries.getSessionById(sessionId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENVIAR MENSAGEM PARA SESSO ESPECFICA ===
  async sendMessageToSession(request, reply) {
    try {
      const { sessionId } = request.params;
      const { message, options } = request.body;
      const enrichedContext = {
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatCommands.processMessage({
        message,
        context: enrichedContext,
        options
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("LLM")) {
        return reply.status(503).send({
          error: "Servi\xE7o de IA temporariamente indispon\xEDvel"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === HISTRICO TRADICIONAL (compatibilidade) ===
  async getHistoryTraditional(request, reply) {
    try {
      const { page = 1, limit = 10, sessionId } = request.query;
      const enrichedParams = {
        page,
        limit,
        sessionId,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.listTraditional(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SESSO DE CHAT ===
  async getSession(request, reply) {
    try {
      const { sessionId } = request.params;
      const result = await ChatQueries.getSessionById(sessionId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteSession(request, reply) {
    try {
      const { sessionId } = request.params;
      await ChatCommands.deleteSession(sessionId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === TOOLBOX ===
  async getToolbox(request, reply) {
    try {
      const result = await ChatQueries.getToolbox();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === EXECUO DE COMANDOS DA TOOLBOX ===
  async executeCommand(request, reply) {
    try {
      const { command, params = {} } = request.body;
      const result = await ChatCommands.executeToolboxCommand(command, params);
      return reply.send({
        command,
        params,
        result
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Unknown service") || error.message.includes("Unknown")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ANLISE E ESTATSTICAS ===
  async getAnalytics(request, reply) {
    try {
      const { startDate, endDate, userId, storeId } = request.query;
      const result = await ChatQueries.getAnalytics({
        startDate,
        endDate,
        userId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === BUSCA ===
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await ChatQueries.search(q, limit);
      return reply.send({ messages: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SESSES ===
  async getSessions(request, reply) {
    try {
      const { page = 1, limit = 10 } = request.query;
      const enrichedParams = {
        page,
        limit,
        userId: request.user?.id,
        storeId: request.store?.id
      };
      const result = await ChatQueries.getSessions(enrichedParams);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === MENSAGEM ESPECFICA ===
  async getMessage(request, reply) {
    try {
      const { id } = request.params;
      const result = await ChatQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat message not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === OPERAES ADICIONAIS DE SESSO ===
  async updateSessionTitle(request, reply) {
    try {
      const { sessionId } = request.params;
      const { title } = request.body;
      const result = await ChatCommands.updateSessionTitle(sessionId, title);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ATUALIZAR TTULO INTELIGENTE ===
  async updateSessionTitleIntelligent(request, reply) {
    try {
      const { sessionId } = request.params;
      const result = await ChatCommands.updateSessionTitleIntelligent(sessionId);
      return reply.send({
        sessionId,
        title: result,
        message: "T\xEDtulo atualizado com sucesso"
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Chat session not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === OPERAES DE LIMPEZA ===
  async cleanupOldSessions(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await ChatCommands.cleanupOldSessions(daysOld);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cleanupOldMessages(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await ChatCommands.cleanupOldMessages(daysOld);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/chat/chat.schema.ts
var sendMessageSchema = {
  body: {
    type: "object",
    required: ["message"],
    properties: {
      message: {
        type: "string",
        minLength: 1,
        maxLength: 2e3,
        description: "Mensagem do usu\xE1rio para o chat"
      },
      context: {
        type: "object",
        properties: {
          storeId: { type: "string" },
          userId: { type: "string" },
          sessionId: { type: "string" }
        },
        additionalProperties: true
      },
      options: {
        type: "object",
        properties: {
          temperature: {
            type: "number",
            minimum: 0,
            maximum: 2,
            default: 0.2
          },
          numPredict: {
            type: "number",
            minimum: 1,
            maximum: 4e3,
            default: 1e3
          },
          repeatPenalty: {
            type: "number",
            minimum: 0.1,
            maximum: 2,
            default: 1.1
          }
        }
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        message: { type: "string" },
        response: { type: "string" },
        context: {
          type: "object",
          properties: {
            storeId: { type: "string", nullable: true },
            userId: { type: "string", nullable: true },
            sessionId: { type: "string", nullable: true }
          }
        },
        options: {
          type: "object",
          properties: {
            temperature: { type: "number" },
            numPredict: { type: "number" },
            repeatPenalty: { type: "number" }
          }
        },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getChatHistorySchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      sessionId: { type: "string" },
      userId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              message: { type: "string" },
              response: { type: "string" },
              context: {
                type: "object",
                properties: {
                  storeId: { type: "string", nullable: true },
                  userId: { type: "string", nullable: true },
                  sessionId: { type: "string", nullable: true }
                }
              },
              options: {
                type: "object",
                properties: {
                  temperature: { type: "number" },
                  numPredict: { type: "number" },
                  repeatPenalty: { type: "number" }
                }
              },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getChatSessionSchema = {
  params: {
    type: "object",
    required: ["sessionId"],
    properties: {
      sessionId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        storeId: { type: "string", nullable: true },
        title: { type: "string", nullable: true },
        messages: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              message: { type: "string" },
              response: { type: "string" },
              context: {
                type: "object",
                properties: {
                  storeId: { type: "string", nullable: true },
                  userId: { type: "string", nullable: true },
                  sessionId: { type: "string", nullable: true }
                }
              },
              options: {
                type: "object",
                properties: {
                  temperature: { type: "number" },
                  numPredict: { type: "number" },
                  repeatPenalty: { type: "number" }
                }
              },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteChatSessionSchema = {
  params: {
    type: "object",
    required: ["sessionId"],
    properties: {
      sessionId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var getToolboxSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        availableServices: {
          type: "object",
          properties: {
            products: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            stores: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            categories: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            suppliers: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            movements: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            reports: {
              type: "object",
              properties: {
                description: { type: "string" },
                methods: {
                  type: "array",
                  items: { type: "string" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getAnalyticsSchema = {
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      userId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        totalMessages: { type: "number" },
        totalSessions: { type: "number" },
        averageMessagesPerSession: { type: "number" },
        mostUsedServices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              service: { type: "string" },
              usageCount: { type: "number" }
            }
          }
        },
        messagesByDay: {
          type: "array",
          items: {
            type: "object",
            properties: {
              date: { type: "string" },
              count: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var ChatSchemas = {
  sendMessage: sendMessageSchema,
  getHistory: getChatHistorySchema,
  getSession: getChatSessionSchema,
  deleteSession: deleteChatSessionSchema,
  getToolbox: getToolboxSchema,
  getAnalytics: getAnalyticsSchema
};

// src/features/chat/chat.routes.ts
async function ChatRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/messages", {
    schema: ChatSchemas.sendMessage,
    handler: ChatController.sendMessage
  });
  fastify2.post("/sessions/:sessionId/messages", {
    schema: ChatSchemas.sendMessage,
    handler: ChatController.sendMessageToSession
  });
  fastify2.get("/messages", {
    schema: ChatSchemas.getHistory,
    handler: ChatController.getHistory
  });
  fastify2.get("/messages/traditional", {
    schema: ChatSchemas.getHistory,
    handler: ChatController.getHistoryTraditional
  });
  fastify2.get("/messages/:id", {
    handler: ChatController.getMessage
  });
  fastify2.get("/sessions", {
    handler: ChatController.getSessions
  });
  fastify2.get("/sessions/:sessionId", {
    schema: ChatSchemas.getSession,
    handler: ChatController.getSession
  });
  fastify2.get("/sessions/:sessionId/messages", {
    handler: ChatController.getSessionMessages
  });
  fastify2.put("/sessions/:sessionId/title", {
    handler: ChatController.updateSessionTitle
  });
  fastify2.patch("/sessions/:sessionId/title/intelligent", {
    handler: ChatController.updateSessionTitleIntelligent
  });
  fastify2.delete("/sessions/:sessionId", {
    schema: ChatSchemas.deleteSession,
    handler: ChatController.deleteSession
  });
  fastify2.get("/toolbox", {
    schema: ChatSchemas.getToolbox,
    handler: ChatController.getToolbox
  });
  fastify2.post("/execute", {
    handler: ChatController.executeCommand
  });
  fastify2.get("/analytics", {
    schema: ChatSchemas.getAnalytics,
    handler: ChatController.getAnalytics
  });
  fastify2.get("/search", {
    handler: ChatController.search
  });
  fastify2.delete("/cleanup/sessions", {
    handler: ChatController.cleanupOldSessions
  });
  fastify2.delete("/cleanup/messages", {
    handler: ChatController.cleanupOldMessages
  });
}

// src/features/crm/commands/crm.commands.ts
var CrmCommands = {
  async create(data) {
    if (data.stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: data.stageId,
          storeId: data.storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.create({
      data: {
        storeId: data.storeId,
        name: data.name,
        email: data.email,
        phone: data.phone,
        cpfCnpj: data.cpfCnpj,
        company: data.company,
        notes: data.notes,
        stageId: data.stageId
      },
      include: {
        stage: true
      }
    });
  },
  async update(id, data, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    if (data.stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: data.stageId,
          storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.update({
      where: { id },
      data,
      include: {
        stage: true
      }
    });
  },
  async delete(id, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    return await db.crmClient.delete({
      where: { id }
    });
  },
  async transitionStage(clientId, stageId, storeId) {
    const client = await db.crmClient.findFirst({
      where: {
        id: clientId,
        storeId
      }
    });
    if (!client) {
      throw new Error("Client not found or does not belong to the store");
    }
    if (stageId) {
      const stage = await db.crmStage.findFirst({
        where: {
          id: stageId,
          storeId
        }
      });
      if (!stage) {
        throw new Error("Stage not found or does not belong to the same store");
      }
    }
    return await db.crmClient.update({
      where: { id: clientId },
      data: { stageId },
      include: {
        stage: true
      }
    });
  }
};

// src/features/crm/commands/crm.stage.commands.ts
var CrmStageCommands = {
  async create(data) {
    return await db.crmStage.create({
      data: {
        storeId: data.storeId,
        name: data.name,
        color: data.color,
        order: data.order
      }
    });
  },
  async update(id, data, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    return await db.crmStage.update({
      where: { id },
      data
    });
  },
  async delete(id, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    const clientsCount = await db.crmClient.count({
      where: {
        stageId: id,
        storeId
      }
    });
    if (clientsCount > 0) {
      throw new Error("Cannot delete stage with clients. Move clients to another stage first.");
    }
    return await db.crmStage.delete({
      where: { id }
    });
  },
  async reorder(id, newOrder, storeId) {
    const stage = await db.crmStage.findFirst({
      where: {
        id,
        storeId
      }
    });
    if (!stage) {
      throw new Error("Stage not found or does not belong to the store");
    }
    return await db.crmStage.update({
      where: { id },
      data: { order: newOrder }
    });
  }
};

// src/features/crm/queries/crm.queries.ts
var CrmQueries = {
  async getById(id, storeId) {
    return await db.crmClient.findFirst({
      where: {
        id,
        storeId
      },
      include: {
        stage: true
      }
    });
  },
  async list(params, storeId) {
    const { page = 1, limit = 10, search, stageId } = params;
    const skip2 = (Number(page) - 1) * Number(limit);
    const take = Number(limit);
    console.log("\u{1F50D} DEBUG list: params:", { page, limit, skip: skip2, take, search, stageId });
    const where = {
      storeId
    };
    if (stageId) {
      where.stageId = stageId;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
        { phone: { contains: search, mode: "insensitive" } },
        { cpfCnpj: { contains: search, mode: "insensitive" } },
        { company: { contains: search, mode: "insensitive" } },
        { notes: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.crmClient.findMany({
        where,
        skip: skip2,
        take,
        orderBy: { createdAt: "desc" },
        include: {
          stage: true
        }
      }),
      db.crmClient.count({ where })
    ]);
    return {
      items,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        totalPages: Math.ceil(total / Number(limit))
      }
    };
  },
  async listGroupedByStage(storeId) {
    console.log("\u{1F50D} DEBUG listGroupedByStage: Starting with storeId:", storeId);
    try {
      console.log("\u{1F4CA} Searching for stages...");
      const stages = await db.crmStage.findMany({
        where: { storeId },
        orderBy: { order: "asc" },
        include: {
          clients: {
            orderBy: { createdAt: "desc" }
          }
        }
      });
      console.log("\u2705 Found stages:", stages.length);
      console.log("\u{1F4CB} Stages data:", JSON.stringify(stages, null, 2));
      console.log("\u{1F4CA} Searching for clients without stage...");
      const clientsWithoutStage = await db.crmClient.findMany({
        where: {
          storeId,
          stageId: null
        },
        orderBy: { createdAt: "desc" }
      });
      console.log("\u2705 Found clients without stage:", clientsWithoutStage.length);
      const stagesWithClients = [...stages];
      if (clientsWithoutStage.length > 0) {
        console.log("\u{1F4DD} Adding virtual stage for clients without stage");
        stagesWithClients.push({
          id: null,
          name: "Sem Stage",
          color: "#6B7280",
          order: -1,
          createdAt: /* @__PURE__ */ new Date(),
          storeId,
          clients: clientsWithoutStage
        });
      }
      console.log("\u{1F4CA} Counting total clients...");
      const totalClients = await db.crmClient.count({
        where: { storeId }
      });
      console.log("\u2705 Total clients in store:", totalClients);
      const result = {
        stages: stagesWithClients,
        totalClients
      };
      console.log("\u{1F3AF} Final result:", JSON.stringify(result, null, 2));
      return result;
    } catch (error) {
      console.error("\u274C Error in listGroupedByStage:", error);
      throw error;
    }
  },
  async search(term, storeId, limit = 10) {
    return await db.crmClient.findMany({
      where: {
        storeId,
        OR: [
          { name: { contains: term, mode: "insensitive" } },
          { email: { contains: term, mode: "insensitive" } },
          { phone: { contains: term, mode: "insensitive" } },
          { cpfCnpj: { contains: term, mode: "insensitive" } },
          { company: { contains: term, mode: "insensitive" } },
          { notes: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        stage: true
      }
    });
  },
  async getStats(storeId) {
    const [totalClients, clientsByStage] = await Promise.all([
      db.crmClient.count({
        where: { storeId }
      }),
      db.crmStage.findMany({
        where: { storeId },
        include: {
          _count: {
            select: { clients: true }
          }
        },
        orderBy: { order: "asc" }
      })
    ]);
    const clientsWithoutStage = await db.crmClient.count({
      where: {
        storeId,
        stageId: null
      }
    });
    return {
      totalClients,
      clientsByStage: clientsByStage.map((stage) => ({
        stageId: stage.id,
        stageName: stage.name,
        clientsCount: stage._count.clients
      })),
      clientsWithoutStage
    };
  }
};

// src/features/crm/queries/crm.stage.queries.ts
var CrmStageQueries = {
  async getById(id, storeId) {
    return await db.crmStage.findFirst({
      where: {
        id,
        storeId
      },
      include: {
        _count: {
          select: { clients: true }
        }
      }
    });
  },
  async list(storeId, params = {}) {
    const { page = 1, limit = 10 } = params;
    const skip2 = (page - 1) * limit;
    const [items, total] = await Promise.all([
      db.crmStage.findMany({
        where: { storeId },
        skip: skip2,
        take: limit,
        orderBy: { order: "asc" },
        include: {
          _count: {
            select: { clients: true }
          }
        }
      }),
      db.crmStage.count({
        where: { storeId }
      })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getNextOrder(storeId) {
    const lastStage = await db.crmStage.findFirst({
      where: { storeId },
      orderBy: { order: "desc" }
    });
    return lastStage ? lastStage.order + 1 : 1;
  },
  async getStats(storeId) {
    const [totalStages, stagesWithClients] = await Promise.all([
      db.crmStage.count({
        where: { storeId }
      }),
      db.crmStage.findMany({
        where: { storeId },
        include: {
          _count: {
            select: { clients: true }
          }
        },
        orderBy: { order: "asc" }
      })
    ]);
    const totalClients = stagesWithClients.reduce((sum, stage) => sum + stage._count.clients, 0);
    return {
      totalStages,
      totalClients,
      stagesWithClients: stagesWithClients.map((stage) => ({
        id: stage.id,
        name: stage.name,
        color: stage.color,
        order: stage.order,
        clientsCount: stage._count.clients
      }))
    };
  }
};

// src/features/crm/crm.controller.ts
var CrmController = {
  // === ENDPOINT DE TESTE TEMPORRIO ===
  async testGrouped(request, reply) {
    try {
      const storeId = request.store?.id;
      console.log("\u{1F9EA} TEST: storeId:", storeId);
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.listGroupedByStage(storeId);
      return reply.send({
        success: true,
        storeId,
        result
      });
    } catch (error) {
      console.error("\u274C TEST Error:", error);
      return reply.status(500).send({
        error: "Test failed",
        details: error.message
      });
    }
  },
  // === CRUD BSICO DE CLIENTES ===
  async createClient(request, reply) {
    try {
      const { name, email, phone, cpfCnpj, company, notes, stageId } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.create({
        storeId,
        name,
        email,
        phone,
        cpfCnpj,
        company,
        notes,
        stageId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getClient(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Client not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateClient(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.update(id, updateData, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteClient(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      await CrmCommands.delete(id, storeId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listClients(request, reply) {
    try {
      const { page = 1, limit = 10, search, stageId, grouped } = request.query;
      const storeId = request.store?.id;
      console.log("\u{1F50D} DEBUG listClients:");
      console.log("- Query params:", { page, limit, search, stageId, grouped });
      console.log("- StoreId:", storeId);
      console.log("- Request user:", request.user);
      console.log("- Request store:", request.store);
      if (!storeId) {
        console.log("\u274C No storeId found");
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      if (grouped) {
        console.log("\u{1F4CA} Calling listGroupedByStage...");
        const result2 = await CrmQueries.listGroupedByStage(storeId);
        console.log("\u2705 listGroupedByStage result:", JSON.stringify(result2, null, 2));
        return reply.send(result2);
      }
      const result = await CrmQueries.list(
        {
          page: Number(page),
          limit: Number(limit),
          search,
          stageId
        },
        storeId
      );
      return reply.send(result);
    } catch (error) {
      console.error("\u274C Error in listClients:", error);
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async searchClients(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.search(q, storeId, limit);
      return reply.send({ clients: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async transitionStage(request, reply) {
    try {
      const { id } = request.params;
      const { stageId } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmCommands.transitionStage(id, stageId, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Client not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Stage not found or does not belong to the same store") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === CRUD BSICO DE STAGES ===
  async createStage(request, reply) {
    try {
      const { name, color, order } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const finalOrder = order || await CrmStageQueries.getNextOrder(storeId);
      const result = await CrmStageCommands.create({
        storeId,
        name,
        color,
        order: finalOrder
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStage(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Stage not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStage(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageCommands.update(id, updateData, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteStage(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      await CrmStageCommands.delete(id, storeId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete stage with clients. Move clients to another stage first.") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listStages(request, reply) {
    try {
      const { page = 1, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.list(storeId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async reorderStage(request, reply) {
    try {
      const { id } = request.params;
      const { order } = request.body;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageCommands.reorder(id, order, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Stage not found or does not belong to the store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStageStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await CrmStageQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/crm/crm.schema.ts
var createCrmClientSchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpfCnpj: { type: "string" },
      company: { type: "string" },
      notes: { type: "string" },
      stageId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpfCnpj: { type: "string" },
      company: { type: "string" },
      notes: { type: "string" },
      stageId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        email: { type: "string" },
        phone: { type: "string" },
        cpfCnpj: { type: "string" },
        company: { type: "string" },
        notes: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listCrmClientsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      stageId: { type: "string" },
      grouped: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      oneOf: [
        {
          // Schema para grouped=true
          properties: {
            stages: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: ["string", "null"] },
                  name: { type: "string" },
                  color: { type: "string" },
                  order: { type: "number" },
                  clients: {
                    type: "array",
                    items: {
                      type: "object",
                      properties: {
                        id: { type: "string" },
                        name: { type: "string" },
                        email: { type: "string" },
                        phone: { type: "string" },
                        company: { type: "string" },
                        createdAt: { type: "string", format: "date-time" }
                      }
                    }
                  }
                }
              }
            },
            totalClients: { type: "number" }
          }
        },
        {
          // Schema para grouped=false (padro)
          properties: {
            items: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  storeId: { type: "string" },
                  stageId: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  phone: { type: "string" },
                  cpfCnpj: { type: "string" },
                  company: { type: "string" },
                  notes: { type: "string" },
                  createdAt: { type: "string", format: "date-time" },
                  updatedAt: { type: "string", format: "date-time" },
                  stage: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      color: { type: "string" },
                      order: { type: "number" }
                    }
                  }
                }
              }
            },
            pagination: {
              type: "object",
              properties: {
                page: { type: "number" },
                limit: { type: "number" },
                total: { type: "number" },
                totalPages: { type: "number" }
              }
            }
          }
        }
      ]
    }
  }
};
var listCrmClientsGroupedSchema = {
  querystring: {
    type: "object",
    properties: {
      grouped: { type: "boolean", default: true }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stages: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: ["string", "null"] },
              name: { type: "string" },
              color: { type: "string" },
              order: { type: "number" },
              clients: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    email: { type: "string" },
                    phone: { type: "string" },
                    company: { type: "string" },
                    createdAt: { type: "string", format: "date-time" }
                  }
                }
              }
            }
          }
        },
        totalClients: { type: "number" }
      }
    }
  }
};
var deleteCrmClientSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var transitionStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["stageId"],
    properties: {
      stageId: { type: ["string", "null"] }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        stageId: { type: "string" },
        name: { type: "string" },
        stage: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            color: { type: "string" },
            order: { type: "number" }
          }
        }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var createCrmStageSchema = {
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      color: { type: "string" },
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      color: { type: "string" },
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" },
        createdAt: { type: "string", format: "date-time" },
        _count: {
          type: "object",
          properties: {
            clients: { type: "number" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listCrmStagesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              name: { type: "string" },
              color: { type: "string" },
              order: { type: "number" },
              createdAt: { type: "string", format: "date-time" },
              _count: {
                type: "object",
                properties: {
                  clients: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var reorderCrmStageSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["order"],
    properties: {
      order: { type: "number", minimum: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        name: { type: "string" },
        color: { type: "string" },
        order: { type: "number" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var CrmSchemas = {
  // Client schemas
  createClient: createCrmClientSchema,
  updateClient: updateCrmClientSchema,
  getClient: getCrmClientSchema,
  deleteClient: deleteCrmClientSchema,
  listClients: listCrmClientsSchema,
  listClientsGrouped: listCrmClientsGroupedSchema,
  transitionStage: transitionStageSchema,
  // Stage schemas
  createStage: createCrmStageSchema,
  updateStage: updateCrmStageSchema,
  getStage: getCrmStageSchema,
  deleteStage: deleteCrmStageSchema,
  listStages: listCrmStagesSchema,
  reorderStage: reorderCrmStageSchema
};

// src/features/crm/crm.routes.ts
async function CrmRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.get("/test-grouped", {
    handler: CrmController.testGrouped
  });
  fastify2.post("/clients", {
    schema: CrmSchemas.createClient,
    handler: CrmController.createClient
  });
  fastify2.get("/clients", {
    // schema: CrmSchemas.listClients, // Temporariamente desabilitado para debug
    handler: CrmController.listClients
  });
  fastify2.get("/clients/grouped", {
    schema: CrmSchemas.listClientsGrouped,
    handler: CrmController.listClients
  });
  fastify2.get("/clients/:id", {
    schema: CrmSchemas.getClient,
    handler: CrmController.getClient
  });
  fastify2.put("/clients/:id", {
    schema: CrmSchemas.updateClient,
    handler: CrmController.updateClient
  });
  fastify2.delete("/clients/:id", {
    schema: CrmSchemas.deleteClient,
    handler: CrmController.deleteClient
  });
  fastify2.patch("/clients/:id/stage", {
    schema: CrmSchemas.transitionStage,
    handler: CrmController.transitionStage
  });
  fastify2.get("/clients/search", {
    handler: CrmController.searchClients
  });
  fastify2.get("/clients/stats", {
    handler: CrmController.getStats
  });
  fastify2.post("/stages", {
    schema: CrmSchemas.createStage,
    handler: CrmController.createStage
  });
  fastify2.get("/stages", {
    schema: CrmSchemas.listStages,
    handler: CrmController.listStages
  });
  fastify2.get("/stages/:id", {
    schema: CrmSchemas.getStage,
    handler: CrmController.getStage
  });
  fastify2.put("/stages/:id", {
    schema: CrmSchemas.updateStage,
    handler: CrmController.updateStage
  });
  fastify2.delete("/stages/:id", {
    schema: CrmSchemas.deleteStage,
    handler: CrmController.deleteStage
  });
  fastify2.patch("/stages/:id/reorder", {
    schema: CrmSchemas.reorderStage,
    handler: CrmController.reorderStage
  });
  fastify2.get("/stages/stats", {
    handler: CrmController.getStageStats
  });
}

// src/features/flow-execution/commands/flow-execution.commands.ts
var FlowExecutionCommands = {
  async create(data) {
    try {
      const execution = await db.flowExecution.create({
        data: {
          flowId: data.flowId,
          status: data.status,
          triggerType: data.triggerType,
          triggerData: data.triggerData,
          executionLog: data.executionLog
        }
      });
      return execution;
    } catch (error) {
      console.error("Error creating flow execution:", error);
      throw error;
    }
  },
  async update(executionId, data) {
    try {
      const execution = await db.flowExecution.update({
        where: { id: executionId },
        data: {
          ...data,
          executionLog: data.executionLog
        }
      });
      return execution;
    } catch (error) {
      console.error("Error updating flow execution:", error);
      throw error;
    }
  },
  async cancel(executionId) {
    try {
      const execution = await db.flowExecution.update({
        where: { id: executionId },
        data: {
          status: "CANCELLED",
          completedAt: /* @__PURE__ */ new Date()
        }
      });
      return execution;
    } catch (error) {
      console.error("Error cancelling flow execution:", error);
      throw error;
    }
  },
  async finalize(executionId, success, error) {
    try {
      const startTime = await db.flowExecution.findUnique({
        where: { id: executionId },
        select: { startedAt: true }
      });
      const durationMs = startTime ? Date.now() - startTime.startedAt.getTime() : void 0;
      const execution = await db.flowExecution.update({
        where: { id: executionId },
        data: {
          status: success ? "SUCCESS" : "FAILED",
          error,
          completedAt: /* @__PURE__ */ new Date(),
          durationMs
        }
      });
      return execution;
    } catch (error2) {
      console.error("Error finalizing flow execution:", error2);
      throw error2;
    }
  }
};

// src/features/flow-execution/queries/flow-execution.queries.ts
var FlowExecutionQueries = {
  async getById(id) {
    try {
      const execution = await db.flowExecution.findUnique({
        where: { id },
        include: {
          flow: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      if (!execution) {
        return null;
      }
      return execution;
    } catch (error) {
      console.error("Error getting flow execution by id:", error);
      throw error;
    }
  },
  async list(params) {
    try {
      const { page = 1, limit = 10, flowId, status, triggerType, startDate, endDate } = params;
      const skip2 = (page - 1) * limit;
      const where = {};
      if (flowId) {
        where.flowId = flowId;
      }
      if (status) {
        where.status = status;
      }
      if (triggerType) {
        where.triggerType = triggerType;
      }
      if (startDate || endDate) {
        where.startedAt = {};
        if (startDate) {
          where.startedAt.gte = new Date(startDate);
        }
        if (endDate) {
          where.startedAt.lte = new Date(endDate);
        }
      }
      const [executions, total] = await Promise.all([
        db.flowExecution.findMany({
          where,
          skip: skip2,
          take: limit,
          orderBy: { startedAt: "desc" },
          include: {
            flow: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }),
        db.flowExecution.count({ where })
      ]);
      return {
        executions,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      console.error("Error listing flow executions:", error);
      throw error;
    }
  },
  async getByFlow(flowId, params) {
    try {
      const { page = 1, limit = 10, status } = params;
      const skip2 = (page - 1) * limit;
      const where = {
        flowId
      };
      if (status) {
        where.status = status;
      }
      const [executions, total] = await Promise.all([
        db.flowExecution.findMany({
          where,
          skip: skip2,
          take: limit,
          orderBy: { startedAt: "desc" },
          include: {
            flow: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }),
        db.flowExecution.count({ where })
      ]);
      return {
        executions,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      console.error("Error getting flow executions by flow:", error);
      throw error;
    }
  },
  async getStats(flowId) {
    try {
      const [total, byStatus, byTrigger, durations] = await Promise.all([
        db.flowExecution.count({
          where: { flowId }
        }),
        db.flowExecution.groupBy({
          by: ["status"],
          where: { flowId },
          _count: true
        }),
        db.flowExecution.groupBy({
          by: ["triggerType"],
          where: { flowId },
          _count: true
        }),
        db.flowExecution.findMany({
          where: {
            flowId,
            durationMs: { not: null }
          },
          select: { durationMs: true }
        })
      ]);
      const statusMap = {
        success: 0,
        failed: 0,
        running: 0,
        cancelled: 0
      };
      for (const item of byStatus) {
        statusMap[item.status.toLowerCase()] = item._count;
      }
      const triggerMap = {};
      for (const item of byTrigger) {
        triggerMap[item.triggerType] = item._count;
      }
      const completedDurations = durations.filter((d) => d.duration !== null).map((d) => d.duration);
      const averageDuration = completedDurations.length > 0 ? completedDurations.reduce((a, b) => a + b, 0) / completedDurations.length : 0;
      const lastExecution = await db.flowExecution.findFirst({
        where: { flowId },
        orderBy: { startedAt: "desc" },
        include: {
          flow: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      return {
        total,
        byStatus: statusMap,
        byTrigger: triggerMap,
        averageDuration,
        lastExecution
      };
    } catch (error) {
      console.error("Error getting flow execution stats:", error);
      throw error;
    }
  }
};

// src/features/flow-execution/flow-execution.controller.ts
var FlowExecutionController = {
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await FlowExecutionQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Flow execution not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Flow execution not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const {
        page = 1,
        limit = 10,
        flowId,
        status,
        triggerType,
        startDate,
        endDate
      } = request.query;
      const result = await FlowExecutionQueries.list({
        page,
        limit,
        flowId,
        status,
        triggerType,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByFlow(request, reply) {
    try {
      const { flowId } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await FlowExecutionQueries.getByFlow(flowId, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { flowId } = request.params;
      const result = await FlowExecutionQueries.getStats(flowId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cancel(request, reply) {
    try {
      const { id } = request.params;
      const result = await FlowExecutionCommands.cancel(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Flow execution not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/flow-execution/flow-execution.schema.ts
var getFlowExecutionSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        flowId: { type: "string" },
        status: {
          type: "string",
          enum: ["SUCCESS", "FAILED", "RUNNING", "CANCELLED"]
        },
        triggerType: { type: "string" },
        triggerData: {},
        executionLog: { type: "array" },
        error: { type: "string", nullable: true },
        startedAt: { type: "string" },
        completedAt: { type: "string", nullable: true },
        duration: { type: "number", nullable: true }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listFlowExecutionsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1 },
      limit: { type: "number", minimum: 1, maximum: 100 },
      flowId: { type: "string" },
      status: {
        type: "string",
        enum: ["SUCCESS", "FAILED", "RUNNING", "CANCELLED"]
      },
      triggerType: { type: "string" },
      startDate: { type: "string" },
      endDate: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        executions: { type: "array" },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByFlowSchema = {
  params: {
    type: "object",
    required: ["flowId"],
    properties: {
      flowId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1 },
      limit: { type: "number", minimum: 1, maximum: 100 },
      status: {
        type: "string",
        enum: ["SUCCESS", "FAILED", "RUNNING", "CANCELLED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        executions: { type: "array" },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getStatsSchema = {
  params: {
    type: "object",
    required: ["flowId"],
    properties: {
      flowId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        byStatus: {
          type: "object",
          properties: {
            success: { type: "number" },
            failed: { type: "number" },
            running: { type: "number" },
            cancelled: { type: "number" }
          }
        },
        byTrigger: { type: "object" },
        averageDuration: { type: "number" },
        lastExecution: {}
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var cancelExecutionSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: {
          type: "string",
          enum: ["SUCCESS", "FAILED", "RUNNING", "CANCELLED"]
        },
        cancelledAt: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var FlowExecutionSchemas = {
  get: getFlowExecutionSchema,
  list: listFlowExecutionsSchema,
  getByFlow: getByFlowSchema,
  getStats: getStatsSchema,
  cancel: cancelExecutionSchema
};

// src/features/flow-execution/flow-execution.routes.ts
async function FlowExecutionRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.get("/flow-executions", {
    schema: FlowExecutionSchemas.list,
    handler: FlowExecutionController.list
  });
  fastify2.get("/flow-executions/:id", {
    schema: FlowExecutionSchemas.get,
    handler: FlowExecutionController.get
  });
  fastify2.get("/flow-executions/flow/:flowId", {
    schema: FlowExecutionSchemas.getByFlow,
    handler: FlowExecutionController.getByFlow
  });
  fastify2.get("/flow-executions/flow/:flowId/stats", {
    schema: FlowExecutionSchemas.getStats,
    handler: FlowExecutionController.getStats
  });
  fastify2.post("/flow-executions/:id/cancel", {
    schema: FlowExecutionSchemas.cancel,
    handler: FlowExecutionController.cancel
  });
}

// src/features/flow/commands/flow.commands.ts
var FlowCommands = {
  async create(data) {
    try {
      const store = await db.store.findUnique({
        where: { id: data.storeId }
      });
      if (!store) {
        throw new Error("Store not found");
      }
      const user = await db.user.findUnique({
        where: { id: data.createdBy }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const flow = await db.flow.create({
        data: {
          name: data.name,
          description: data.description,
          nodes: data.nodes,
          edges: data.edges,
          status: data.status,
          storeId: data.storeId,
          createdBy: data.createdBy
        },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      return flow;
    } catch (error) {
      console.error("Error creating flow:", error);
      throw error;
    }
  },
  async update(id, data) {
    try {
      const existingFlow = await db.flow.findUnique({
        where: { id }
      });
      if (!existingFlow) {
        throw new Error("Flow not found");
      }
      const flow = await db.flow.update({
        where: { id },
        data: {
          ...data,
          nodes: data.nodes,
          edges: data.edges
        },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      return flow;
    } catch (error) {
      console.error("Error updating flow:", error);
      throw error;
    }
  },
  async delete(id) {
    try {
      const existingFlow = await db.flow.findUnique({
        where: { id }
      });
      if (!existingFlow) {
        throw new Error("Flow not found");
      }
      await db.flow.delete({
        where: { id }
      });
      return { id };
    } catch (error) {
      console.error("Error deleting flow:", error);
      throw error;
    }
  },
  async updateStatus(id, status) {
    try {
      const existingFlow = await db.flow.findUnique({
        where: { id }
      });
      if (!existingFlow) {
        throw new Error("Flow not found");
      }
      const flow = await db.flow.update({
        where: { id },
        data: { status },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      return flow;
    } catch (error) {
      console.error("Error updating flow status:", error);
      throw error;
    }
  },
  async duplicate(id, newName) {
    try {
      const originalFlow = await db.flow.findUnique({
        where: { id }
      });
      if (!originalFlow) {
        throw new Error("Flow not found");
      }
      const duplicatedFlow = await db.flow.create({
        data: {
          name: newName || `${originalFlow.name} (Copy)`,
          description: originalFlow.description,
          nodes: originalFlow.nodes,
          edges: originalFlow.edges,
          status: "DRAFT",
          // Sempre DRAFT ao duplicar
          storeId: originalFlow.storeId,
          createdBy: originalFlow.createdBy
        },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      return duplicatedFlow;
    } catch (error) {
      console.error("Error duplicating flow:", error);
      throw error;
    }
  }
};

// src/features/flow/queries/flow.queries.ts
var FlowQueries = {
  async getById(id) {
    try {
      const flow = await db.flow.findUnique({
        where: { id },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          creator: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!flow) {
        return null;
      }
      return flow;
    } catch (error) {
      console.error("Error getting flow by id:", error);
      throw error;
    }
  },
  async list(params) {
    try {
      const { page = 1, limit = 10, search, status, storeId } = params;
      const skip2 = (page - 1) * limit;
      const where = {};
      if (status) {
        where.status = status;
      }
      if (storeId) {
        where.storeId = storeId;
      }
      if (search) {
        where.OR = [
          { name: { contains: search, mode: "insensitive" } },
          { description: { contains: search, mode: "insensitive" } }
        ];
      }
      const [flows, total] = await Promise.all([
        db.flow.findMany({
          where,
          skip: skip2,
          take: limit,
          orderBy: { createdAt: "desc" },
          include: {
            store: {
              select: {
                id: true,
                name: true
              }
            },
            creator: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        }),
        db.flow.count({ where })
      ]);
      return {
        items: flows,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      console.error("Error listing flows:", error);
      throw error;
    }
  },
  async getByStore(storeId) {
    try {
      const flows = await db.flow.findMany({
        where: { storeId },
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          creator: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return flows;
    } catch (error) {
      console.error("Error getting flows by store:", error);
      throw error;
    }
  },
  async getActiveFlowsByTrigger(storeId, triggerType) {
    try {
      const flows = await db.flow.findMany({
        where: {
          storeId,
          status: "ACTIVE"
        }
      });
      const matchingFlows = flows.filter((flow) => {
        const nodes = flow.nodes;
        return nodes.some((node) => {
          if (node.type === "trigger" && node.data?.config) {
            const config = node.data.config;
            return config.eventType === triggerType;
          }
          return false;
        });
      });
      return matchingFlows;
    } catch (error) {
      console.error("Error getting active flows by trigger:", error);
      throw error;
    }
  },
  async getActiveFlowsByStore(storeId) {
    try {
      const flows = await db.flow.findMany({
        where: {
          storeId,
          status: "ACTIVE"
        },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          },
          creator: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return flows;
    } catch (error) {
      console.error("Error getting active flows by store:", error);
      throw error;
    }
  },
  async search(params) {
    const { searchTerm, storeId, limit = 10, page = 1 } = params;
    try {
      const where = {
        OR: [
          { name: { contains: searchTerm, mode: "insensitive" } },
          { description: { contains: searchTerm, mode: "insensitive" } }
        ]
      };
      if (storeId) {
        where.storeId = storeId;
      }
      const flows = await db.flow.findMany({
        where,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          store: {
            select: {
              id: true,
              name: true
            }
          }
        }
      });
      const total = await db.flow.count({ where });
      return {
        items: flows,
        pagination: {
          page,
          limit,
          total: flows.length,
          totalPages: Math.ceil(total / Number(limit))
        }
      };
    } catch (error) {
      console.error("Error searching flows:", error);
      throw error;
    }
  },
  async getStats(storeId) {
    try {
      const where = {};
      if (storeId) {
        where.storeId = storeId;
      }
      const [total, active, inactive, draft] = await Promise.all([
        db.flow.count({ where }),
        db.flow.count({ where: { ...where, status: "ACTIVE" } }),
        db.flow.count({ where: { ...where, status: "INACTIVE" } }),
        db.flow.count({ where: { ...where, status: "DRAFT" } })
      ]);
      return {
        total,
        active,
        inactive,
        draft
      };
    } catch (error) {
      console.error("Error getting flow stats:", error);
      throw error;
    }
  }
};

// src/features/flow/flow.controller.ts
var FlowController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { name, description, nodes, edges, status } = request.body;
      const storeId = request.store?.id;
      const userId = request.user?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await FlowCommands.create({
        name,
        description,
        nodes,
        edges,
        status: status || "DRAFT",
        storeId,
        createdBy: userId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found" || error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await FlowQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Flow not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Flow not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await FlowCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Flow not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await FlowCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Flow not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await FlowQueries.list({
        page,
        limit,
        search,
        status,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await FlowCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Flow not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async duplicate(request, reply) {
    try {
      const { id } = request.params;
      const { name } = request.body || {};
      const result = await FlowCommands.duplicate(id, name);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Flow not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async test(request, reply) {
    try {
      const { id } = request.params;
      const flow = await FlowQueries.getById(id);
      if (!flow) {
        return reply.status(404).send({
          error: "Flow not found"
        });
      }
      return reply.send({
        executionId: `test-${Date.now()}`,
        status: "success",
        executionLog: [
          {
            nodeId: "trigger-1",
            nodeType: "trigger",
            status: "success",
            timestamp: /* @__PURE__ */ new Date(),
            message: "Test execution completed"
          }
        ]
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByStore(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await FlowQueries.getByStore(storeId);
      return reply.send({ flows: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const storeId = request.store?.id;
      const result = await FlowQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { searchTerm, limit = 10, page = 1 } = request.query;
      const storeId = request.store?.id;
      const result = await FlowQueries.search({ searchTerm, storeId, limit, page });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/flow/flow.schema.ts
var createFlowSchema = {
  body: {
    type: "object",
    required: ["name", "nodes", "edges"],
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      nodes: {
        type: "array",
        items: {
          type: "object",
          required: ["id", "type", "position", "data"],
          properties: {
            id: { type: "string" },
            type: { type: "string" },
            position: {
              type: "object",
              required: ["x", "y"],
              properties: {
                x: { type: "number" },
                y: { type: "number" }
              },
              additionalProperties: true
            },
            data: {
              type: "object",
              required: ["label"],
              properties: {
                label: { type: "string" },
                description: { type: "string" },
                color: { type: "string" },
                config: {}
              },
              additionalProperties: true
            },
            width: { type: "number" },
            height: { type: "number" },
            selected: { type: "boolean" },
            positionAbsolute: {
              type: "object",
              properties: {
                x: { type: "number" },
                y: { type: "number" }
              },
              additionalProperties: true
            },
            dragging: { type: "boolean" }
          },
          additionalProperties: true
        }
      },
      edges: {
        type: "array",
        items: {
          type: "object",
          required: ["id", "source", "target"],
          properties: {
            id: { type: "string" },
            source: { type: "string" },
            target: { type: "string" },
            type: { type: "string" },
            animated: { type: "boolean" },
            style: {
              type: "object",
              additionalProperties: true
            },
            markerEnd: {
              oneOf: [{ type: "string" }, { type: "object", additionalProperties: true }]
            },
            label: { type: "string" }
          },
          additionalProperties: true
        }
      },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "DRAFT"],
        default: "DRAFT"
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        nodes: { type: "array" },
        edges: { type: "array" },
        status: { type: "string" },
        storeId: { type: "string" },
        createdBy: { type: "string" },
        createdAt: { type: "string" },
        updatedAt: { type: "string" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateFlowSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      nodes: {
        type: "array",
        items: {
          type: "object",
          required: ["id", "type", "position", "data"],
          properties: {
            id: { type: "string" },
            type: { type: "string" },
            position: {
              type: "object",
              required: ["x", "y"],
              properties: {
                x: { type: "number" },
                y: { type: "number" }
              },
              additionalProperties: true
            },
            data: {
              type: "object",
              required: ["label"],
              properties: {
                label: { type: "string" },
                description: { type: "string" },
                color: { type: "string" },
                config: {}
              },
              additionalProperties: true
            },
            width: { type: "number" },
            height: { type: "number" },
            selected: { type: "boolean" },
            positionAbsolute: {
              type: "object",
              properties: {
                x: { type: "number" },
                y: { type: "number" }
              },
              additionalProperties: true
            },
            dragging: { type: "boolean" }
          },
          additionalProperties: true
        }
      },
      edges: {
        type: "array",
        items: {
          type: "object",
          required: ["id", "source", "target"],
          properties: {
            id: { type: "string" },
            source: { type: "string" },
            target: { type: "string" },
            type: { type: "string" },
            animated: { type: "boolean" },
            style: {
              type: "object",
              additionalProperties: true
            },
            markerEnd: {
              oneOf: [{ type: "string" }, { type: "object", additionalProperties: true }]
            },
            label: { type: "string" }
          },
          additionalProperties: true
        }
      },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "DRAFT"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        nodes: { type: "array" },
        edges: { type: "array" },
        status: { type: "string" },
        storeId: { type: "string" },
        createdBy: { type: "string" },
        createdAt: { type: "string" },
        updatedAt: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getFlowSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        nodes: { type: "array" },
        edges: { type: "array" },
        status: { type: "string" },
        storeId: { type: "string" },
        createdBy: { type: "string" },
        createdAt: { type: "string" },
        updatedAt: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var deleteFlowSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listFlowsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1 },
      limit: { type: "number", minimum: 1, maximum: 100 },
      search: { type: "string" },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "DRAFT"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: { type: "array" },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateFlowStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "DRAFT"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        nodes: { type: "array" },
        edges: { type: "array" },
        status: { type: "string" },
        storeId: { type: "string" },
        createdBy: { type: "string" },
        createdAt: { type: "string" },
        updatedAt: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var duplicateFlowSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        nodes: { type: "array" },
        edges: { type: "array" },
        status: { type: "string" },
        storeId: { type: "string" },
        createdBy: { type: "string" },
        createdAt: { type: "string" },
        updatedAt: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var testFlowSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      triggerData: {}
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        executionId: { type: "string" },
        status: { type: "string" },
        executionLog: { type: "array" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var FlowSchemas = {
  create: createFlowSchema,
  update: updateFlowSchema,
  get: getFlowSchema,
  delete: deleteFlowSchema,
  list: listFlowsSchema,
  updateStatus: updateFlowStatusSchema,
  duplicate: duplicateFlowSchema,
  test: testFlowSchema
};

// src/features/flow/flow.routes.ts
async function FlowRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/flows", {
    schema: FlowSchemas.create,
    handler: FlowController.create
  });
  fastify2.get("/flows", {
    schema: FlowSchemas.list,
    handler: FlowController.list
  });
  fastify2.get("/flows/stats", {
    handler: FlowController.getStats
  });
  fastify2.get("/flows/search", {
    handler: FlowController.search
  });
  fastify2.get("/flows/store", {
    handler: FlowController.getByStore
  });
  fastify2.get("/flows/:id", {
    schema: FlowSchemas.get,
    handler: FlowController.get
  });
  fastify2.put("/flows/:id", {
    schema: FlowSchemas.update,
    handler: FlowController.update
  });
  fastify2.delete("/flows/:id", {
    schema: FlowSchemas.delete,
    handler: FlowController.delete
  });
  fastify2.patch("/flows/:id/status", {
    schema: FlowSchemas.updateStatus,
    handler: FlowController.updateStatus
  });
  fastify2.post("/flows/:id/duplicate", {
    schema: FlowSchemas.duplicate,
    handler: FlowController.duplicate
  });
  fastify2.post("/flows/:id/test", {
    schema: FlowSchemas.test,
    handler: FlowController.test
  });
}

// src/features/invoice/commands/invoice.commands.ts
var InvoiceCommands = {
  async create(data) {
    const { subscriptionId, ...createData } = data;
    const subscription2 = await db.subscription.findUnique({
      where: { id: subscriptionId },
      include: {
        user: true
      }
    });
    if (!subscription2) {
      throw new Error("Subscription not found");
    }
    return await db.invoice.create({
      data: {
        ...createData,
        status: data.status || "PENDING" /* PENDING */,
        subscription: { connect: { id: subscriptionId } }
      },
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingInvoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!existingInvoice) {
      throw new Error("Invoice not found");
    }
    return await db.invoice.update({
      where: { id },
      data: {
        ...data
      },
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
  },
  async delete(id) {
    const invoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    return await db.invoice.delete({
      where: { id }
    });
  },
  async updateStatus(id, status, paymentDate, gatewayPaymentId) {
    const invoice = await db.invoice.findUnique({
      where: { id }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const updateData = { status };
    if (status === "PAID" /* PAID */) {
      updateData.paymentDate = paymentDate || /* @__PURE__ */ new Date();
      if (gatewayPaymentId) {
        updateData.gatewayPaymentId = gatewayPaymentId;
      }
    }
    return await db.invoice.update({
      where: { id },
      data: updateData,
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
  }
};

// src/features/invoice/queries/invoice.queries.ts
var InvoiceQueries = {
  async getById(id) {
    const invoice = await db.invoice.findUnique({
      where: { id },
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
    if (!invoice) {
      return null;
    }
    return invoice;
  },
  async list(params) {
    const { page = 1, limit = 10, subscriptionId, status, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (subscriptionId) {
      where.subscriptionId = subscriptionId;
    }
    if (status) {
      where.status = status;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    const [invoices, total] = await Promise.all([
      db.invoice.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          subscription: {
            include: {
              user: true
            }
          }
        }
      }),
      db.invoice.count({ where })
    ]);
    return {
      items: invoices,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByCustomer(subscriptionId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip2 = (page - 1) * limit;
    const subscription2 = await db.subscription.findUnique({
      where: { id: subscriptionId }
    });
    if (!subscription2) {
      throw new Error("Subscription not found");
    }
    const where = {
      subscriptionId
    };
    if (status) {
      where.status = status;
    }
    const [invoices, total] = await Promise.all([
      db.invoice.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" }
      }),
      db.invoice.count({ where })
    ]);
    return {
      subscription: {
        id: subscription2.id,
        userId: subscription2.userId,
        status: subscription2.status
      },
      invoices,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getPending() {
    const invoices = await db.invoice.findMany({
      where: { status: "PENDING" },
      orderBy: { createdAt: "asc" },
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
    return invoices;
  },
  async getFailed() {
    const invoices = await db.invoice.findMany({
      where: { status: "FAILED" },
      orderBy: { createdAt: "desc" },
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
    return invoices;
  },
  async getStats() {
    const [total, pending, paid, failed, amountData] = await Promise.all([
      db.invoice.count(),
      db.invoice.count({ where: { status: "PENDING" } }),
      db.invoice.count({ where: { status: "PAID" } }),
      db.invoice.count({ where: { status: "FAILED" } }),
      db.invoice.aggregate({
        _sum: { amount: true },
        _avg: { amount: true }
      })
    ]);
    const [totalPaid, totalPending, totalFailed] = await Promise.all([
      db.invoice.aggregate({
        where: { status: "PAID" },
        _sum: { amount: true }
      }),
      db.invoice.aggregate({
        where: { status: "PENDING" },
        _sum: { amount: true }
      }),
      db.invoice.aggregate({
        where: { status: "FAILED" },
        _sum: { amount: true }
      })
    ]);
    const totalAmount = amountData._sum.amount ? Number(amountData._sum.amount) : 0;
    const totalPaidAmount = totalPaid._sum.amount ? Number(totalPaid._sum.amount) : 0;
    const totalPendingAmount = totalPending._sum.amount ? Number(totalPending._sum.amount) : 0;
    const totalFailedAmount = totalFailed._sum.amount ? Number(totalFailed._sum.amount) : 0;
    const averageAmount = amountData._avg.amount ? Number(amountData._avg.amount) : 0;
    const conversionRate = total > 0 ? paid / total * 100 : 0;
    return {
      total,
      pending,
      paid,
      failed,
      totalAmount,
      totalPaid: totalPaidAmount,
      totalPending: totalPendingAmount,
      totalFailed: totalFailedAmount,
      averageAmount,
      conversionRate
    };
  },
  async generatePdf(invoiceId) {
    const invoice = await db.invoice.findUnique({
      where: { id: invoiceId },
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
    if (!invoice) {
      throw new Error("Invoice not found");
    }
    const pdfData = {
      invoice: {
        id: invoice.id,
        amount: Number(invoice.amount),
        status: invoice.status,
        createdAt: invoice.createdAt,
        paymentDate: invoice.paymentDate
      },
      user: {
        name: invoice.subscription.user.name,
        email: invoice.subscription.user.email,
        phone: invoice.subscription.user.phone
      }
    };
    return {
      success: true,
      pdfData,
      message: "PDF data prepared for generation"
    };
  },
  async getOverdueInvoices() {
    const thirtyDaysAgo = /* @__PURE__ */ new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const overdueInvoices = await db.invoice.findMany({
      where: {
        status: "PENDING",
        createdAt: {
          lt: thirtyDaysAgo
        }
      },
      orderBy: { createdAt: "asc" },
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
    return overdueInvoices;
  },
  async getRevenueByPeriod(startDate, endDate) {
    const invoices = await db.invoice.findMany({
      where: {
        status: "PAID",
        paymentDate: {
          gte: startDate,
          lte: endDate
        }
      },
      include: {
        subscription: {
          include: {
            user: true
          }
        }
      }
    });
    const totalRevenue = invoices.reduce((sum, invoice) => sum + Number(invoice.amount), 0);
    const revenueByPlan = invoices.reduce(
      (acc, invoice) => {
        if (invoice.subscription.polarProductId) {
          const planId = invoice.subscription.polarProductId;
          if (!acc[planId]) {
            acc[planId] = {
              plan: invoice.subscription.polarProductId,
              revenue: 0,
              count: 0
            };
          }
          acc[planId].revenue += Number(invoice.amount);
          acc[planId].count += 1;
        }
        return acc;
      },
      {}
    );
    return {
      totalRevenue,
      invoiceCount: invoices.length,
      revenueByPlan: Object.values(revenueByPlan)
    };
  }
};

// src/features/invoice/invoice.controller.ts
var InvoiceController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { subscriptionId, amount, status, gatewayPaymentId, paymentDate } = request.body;
      const result = await InvoiceCommands.create({
        subscriptionId,
        amount,
        status,
        gatewayPaymentId,
        paymentDate: paymentDate ? new Date(paymentDate) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Invoice not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateInvoiceStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status, paymentDate, gatewayPaymentId } = request.body;
      const result = await InvoiceCommands.updateStatus(
        id,
        status,
        paymentDate ? new Date(paymentDate) : void 0,
        gatewayPaymentId
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await InvoiceCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, subscriptionId, status, startDate, endDate } = request.query;
      const result = await InvoiceQueries.list({
        page,
        limit,
        subscriptionId,
        status,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getByCustomer(request, reply) {
    try {
      const { customerId } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await InvoiceQueries.getByCustomer(customerId, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Customer not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPending(request, reply) {
    try {
      const result = await InvoiceQueries.getPending();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getFailed(request, reply) {
    try {
      const result = await InvoiceQueries.getFailed();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await InvoiceQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPdf(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceQueries.generatePdf(id);
      if (!result.success) {
        return reply.status(400).send({
          error: "Failed to generate PDF"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getOverdue(request, reply) {
    try {
      const result = await InvoiceQueries.getOverdueInvoices();
      return reply.send({ invoices: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRevenue(request, reply) {
    try {
      const { startDate, endDate } = request.query;
      const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const end = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
      const result = await InvoiceQueries.getRevenueByPeriod(start, end);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status, paymentDate, gatewayPaymentId } = request.body;
      const result = await InvoiceCommands.updateStatus(
        id,
        status,
        paymentDate ? new Date(paymentDate) : void 0,
        gatewayPaymentId
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStatusRetry(request, reply) {
    try {
      const { id } = request.params;
      const { gatewayPaymentId } = request.body;
      const result = await InvoiceCommands.updateStatus(
        id,
        "PENDING",
        void 0,
        gatewayPaymentId
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Invoice is already paid") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async sendEmail(request, reply) {
    try {
      const { id } = request.params;
      const invoice = await InvoiceQueries.getById(id);
      if (!invoice) {
        return reply.status(404).send({
          error: "Invoice not found"
        });
      }
      const emailResult = {
        success: true,
        messageId: `email_${Date.now()}`
      };
      return reply.send({
        invoice,
        emailResult
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsPaid(request, reply) {
    try {
      const { id } = request.params;
      const { gatewayPaymentId } = request.body;
      const result = await InvoiceCommands.updateStatus(
        id,
        "PAID",
        void 0,
        gatewayPaymentId
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsFailed(request, reply) {
    try {
      const { id } = request.params;
      const result = await InvoiceCommands.updateStatus(
        id,
        "FAILED",
        void 0,
        void 0
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invoice not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/invoice/invoice.schema.ts
var createInvoiceSchema = {
  body: {
    type: "object",
    required: ["customerId", "amount"],
    properties: {
      customerId: { type: "string", minLength: 1 },
      amount: { type: "number", minimum: 0.01 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"],
        default: "PENDING"
      },
      gatewayPaymentId: { type: "string" },
      paymentDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var updateInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      amount: { type: "number", minimum: 0.01 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      gatewayPaymentId: { type: "string" },
      paymentDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var getInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" },
            user: {
              type: "object",
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                email: { type: "string" },
                phone: { type: "string", nullable: true }
              }
            },
            plan: {
              type: "object",
              nullable: true,
              properties: {
                id: { type: "string" },
                name: { type: "string" },
                description: { type: "string", nullable: true },
                price: { type: "number" },
                interval: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};
var listInvoicesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      customerId: { type: "string" },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              gatewayPaymentId: { type: "string", nullable: true },
              paymentDate: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              customer: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  userId: { type: "string" },
                  status: { type: "string" },
                  user: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      email: { type: "string" },
                      phone: { type: "string", nullable: true }
                    }
                  },
                  plan: {
                    type: "object",
                    nullable: true,
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      description: { type: "string", nullable: true },
                      price: { type: "number" },
                      interval: { type: "string" }
                    }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteInvoiceSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateInvoiceStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      },
      paymentDate: { type: "string", format: "date-time" },
      gatewayPaymentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" }
          }
        }
      }
    }
  }
};
var retryPaymentSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      gateway: { type: "string" },
      paymentMethod: { type: "object" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        invoice: {
          type: "object",
          properties: {
            id: { type: "string" },
            customerId: { type: "string" },
            amount: { type: "number" },
            status: { type: "string" },
            gatewayPaymentId: { type: "string", nullable: true },
            paymentDate: { type: "string", format: "date-time", nullable: true },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        retryResult: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            gatewayResponse: { type: "object", nullable: true },
            error: { type: "string", nullable: true }
          }
        }
      }
    }
  }
};
var getInvoicePdfSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        pdfData: { type: "object" },
        message: { type: "string" }
      }
    }
  }
};
var sendInvoiceEmailSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      email: { type: "string", format: "email" },
      includePdf: { type: "boolean", default: false }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        invoice: {
          type: "object",
          properties: {
            id: { type: "string" },
            customerId: { type: "string" },
            amount: { type: "number" },
            status: { type: "string" }
          }
        },
        emailResult: {
          type: "object",
          properties: {
            success: { type: "boolean" },
            messageId: { type: "string", nullable: true },
            error: { type: "string", nullable: true }
          }
        }
      }
    }
  }
};
var getCustomerInvoicesSchema = {
  params: {
    type: "object",
    required: ["customerId"],
    properties: {
      customerId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      status: {
        type: "string",
        enum: ["PENDING", "PAID", "FAILED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        customer: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            status: { type: "string" }
          }
        },
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              gatewayPaymentId: { type: "string", nullable: true },
              paymentDate: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getInvoiceStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        pending: { type: "number" },
        paid: { type: "number" },
        failed: { type: "number" },
        totalAmount: { type: "number" },
        totalPaid: { type: "number" },
        totalPending: { type: "number" },
        totalFailed: { type: "number" },
        averageAmount: { type: "number" },
        conversionRate: { type: "number" }
      }
    }
  }
};
var getOverdueInvoicesSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        invoices: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              customerId: { type: "string" },
              amount: { type: "number" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              customer: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  userId: { type: "string" },
                  user: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      email: { type: "string" },
                      phone: { type: "string", nullable: true }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getRevenueSchema = {
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        totalRevenue: { type: "number" },
        invoiceCount: { type: "number" },
        revenueByPlan: {
          type: "array",
          items: {
            type: "object",
            properties: {
              plan: { type: "object" },
              revenue: { type: "number" },
              count: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var markAsPaidSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      gatewayPaymentId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var markAsFailedSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        customerId: { type: "string" },
        amount: { type: "number" },
        status: { type: "string" },
        gatewayPaymentId: { type: "string", nullable: true },
        paymentDate: { type: "string", format: "date-time", nullable: true },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var InvoiceSchemas = {
  create: createInvoiceSchema,
  update: updateInvoiceSchema,
  get: getInvoiceSchema,
  delete: deleteInvoiceSchema,
  list: listInvoicesSchema,
  updateStatus: updateInvoiceStatusSchema,
  retryPayment: retryPaymentSchema,
  getPdf: getInvoicePdfSchema,
  sendEmail: sendInvoiceEmailSchema,
  getByCustomer: getCustomerInvoicesSchema,
  getStats: getInvoiceStatsSchema,
  getOverdue: getOverdueInvoicesSchema,
  getRevenue: getRevenueSchema,
  markAsPaid: markAsPaidSchema,
  markAsFailed: markAsFailedSchema
};

// src/features/invoice/invoice.routes.ts
async function InvoiceRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: InvoiceSchemas.create,
    handler: InvoiceController.create
  });
  fastify2.get("/", {
    schema: InvoiceSchemas.list,
    handler: InvoiceController.list
  });
  fastify2.get("/:id", {
    schema: InvoiceSchemas.get,
    handler: InvoiceController.get
  });
  fastify2.patch("/:id/status", {
    schema: InvoiceSchemas.update,
    handler: InvoiceController.updateInvoiceStatus
  });
  fastify2.delete("/:id", {
    schema: InvoiceSchemas.delete,
    handler: InvoiceController.delete
  });
  fastify2.get("/customer/:customerId", {
    schema: InvoiceSchemas.getByCustomer,
    handler: InvoiceController.getByCustomer
  });
  fastify2.get("/pending", {
    handler: InvoiceController.getPending
  });
  fastify2.get("/failed", {
    handler: InvoiceController.getFailed
  });
  fastify2.get("/overdue", {
    handler: InvoiceController.getOverdue
  });
  fastify2.get("/stats", {
    handler: InvoiceController.getStats
  });
  fastify2.get("/revenue", {
    schema: InvoiceSchemas.getRevenue,
    handler: InvoiceController.getRevenue
  });
  fastify2.get("/:id/pdf", {
    schema: InvoiceSchemas.getPdf,
    handler: InvoiceController.getPdf
  });
  fastify2.patch("/:id/status", {
    schema: InvoiceSchemas.updateStatus,
    handler: InvoiceController.updateStatus
  });
  fastify2.post("/:id/retry", {
    schema: InvoiceSchemas.updateStatus,
    handler: InvoiceController.updateStatusRetry
  });
  fastify2.post("/:id/send-email", {
    schema: InvoiceSchemas.sendEmail,
    handler: InvoiceController.sendEmail
  });
  fastify2.patch("/:id/mark-paid", {
    schema: InvoiceSchemas.markAsPaid,
    handler: InvoiceController.markAsPaid
  });
  fastify2.patch("/:id/mark-failed", {
    schema: InvoiceSchemas.markAsFailed,
    handler: InvoiceController.markAsFailed
  });
}

// src/services/workflow-engine/action-executor.service.ts
var ActionExecutor = {
  async executeAction(actionConfig, context) {
    try {
      switch (actionConfig.type) {
        case "email":
          return await this.sendEmail(actionConfig.config, context);
        case "webhook":
          return await this.callWebhook(actionConfig.config, context);
        case "internal_notification":
          return await this.sendInternalNotification(actionConfig.config, context);
        case "sms":
          return await this.sendSMS(actionConfig.config, context);
        case "push_notification":
          return await this.sendPushNotification(actionConfig.config, context);
        default:
          throw new Error(`Unknown action type: ${actionConfig.type}`);
      }
    } catch (error) {
      console.error(`Error executing ${actionConfig.type} action:`, error);
      throw error;
    }
  },
  async sendEmail(config, context) {
    const to = this.replaceVariables(config.to, context);
    const subject = this.replaceVariables(config.subject || "", context);
    const body = this.replaceVariables(config.body || "", context);
    console.log("\u{1F4E7} Sending email:", {
      to,
      subject,
      body
    });
    return {
      success: true,
      type: "email",
      to,
      subject,
      message: "Email sent successfully (simulated)"
    };
  },
  async callWebhook(config, context) {
    if (!config.url) {
      throw new Error("Webhook URL is required");
    }
    const url = this.replaceVariables(config.url, context);
    const method = config.method || "POST";
    const headers = config.headers || {};
    let body = config.body;
    if (body && typeof body === "string") {
      body = this.replaceVariables(body, context);
    }
    console.log("\u{1F517} Calling webhook:", {
      url,
      method,
      headers,
      body
    });
    return {
      success: true,
      type: "webhook",
      url,
      message: "Webhook called successfully (simulated)"
    };
  },
  async sendInternalNotification(config, context) {
    if (!config.userIds || !Array.isArray(config.userIds) || config.userIds.length === 0) {
      throw new Error("User IDs are required for internal notification");
    }
    const title = this.replaceVariables(config.title || "", context);
    const message = this.replaceVariables(config.message || "", context);
    const priority = config.priority || "MEDIUM";
    const notifications = await Promise.all(
      config.userIds.map(async (userId) => {
        const notification = await db.notification.create({
          data: {
            userId,
            title,
            message,
            type: "SYSTEM",
            priority,
            data: {
              workflowContext: context,
              createdAt: /* @__PURE__ */ new Date()
            }
          }
        });
        return notification;
      })
    );
    return {
      success: true,
      type: "internal_notification",
      notificationsCreated: notifications.length,
      message: `Internal notifications sent to ${notifications.length} user(s)`
    };
  },
  async sendSMS(config, context) {
    if (!config.message) {
      throw new Error("SMS message is required");
    }
    const to = this.replaceVariables(config.to, context);
    const message = this.replaceVariables(config.message, context);
    console.log("\u{1F4F1} Sending SMS:", {
      to,
      message
    });
    return {
      success: true,
      type: "sms",
      to,
      message: "SMS sent successfully (simulated)"
    };
  },
  async sendPushNotification(config, context) {
    if (!config.userIds || !Array.isArray(config.userIds) || config.userIds.length === 0) {
      throw new Error("User IDs are required for push notification");
    }
    const title = this.replaceVariables(config.title || "Notification", context);
    const message = this.replaceVariables(config.message || "", context);
    const icon = config.icon;
    const badge = config.badge;
    const actions = config.actions || [];
    const subscriptionsResults = await Promise.all(
      config.userIds.map(async (userId) => {
        const subscriptions = await db.subscription.findMany({
          where: { userId }
        });
        return subscriptions;
      })
    );
    const allSubscriptions = subscriptionsResults.flat();
    if (allSubscriptions.length === 0) {
      console.log("No push subscriptions found for users");
      return {
        success: true,
        type: "push_notification",
        subscriptionsSent: 0,
        message: "No push subscriptions found for users"
      };
    }
    const payload = {
      title,
      body: message,
      icon,
      badge,
      data: {
        workflowContext: context,
        actions,
        createdAt: /* @__PURE__ */ new Date()
      },
      actions
    };
    let success = 0;
    let failed = 0;
    const sendPromises = allSubscriptions.map(async (subscription2) => {
      try {
        await sendPushNotification(
          {
            endpoint: subscription2.endpoint,
            keys: {
              p256dh: subscription2.p256dh,
              auth: subscription2.auth
            }
          },
          payload
        );
        success++;
      } catch (error) {
        failed++;
        console.error("Failed to send push notification:", error.message);
        if (error.message.includes("expired") || error.message.includes("invalid")) {
          await db.subscription.delete({
            where: { id: subscription2.id }
          });
        }
      }
    });
    await Promise.allSettled(sendPromises);
    console.log(`\u{1F514} Push notifications sent: ${success} success, ${failed} failed`);
    return {
      success: true,
      type: "push_notification",
      subscriptionsSent: success,
      subscriptionsFailed: failed,
      message: `Push notification sent to ${success} device(s)`
    };
  },
  replaceVariables(template, context) {
    if (!template || typeof template !== "string") {
      return template;
    }
    let result = template;
    const variables = {
      "product.name": context.product?.name || "",
      "product.stock": context.product?.stock || 0,
      "product.id": context.product?.id || "",
      "store.name": context.store?.name || "",
      "store.id": context.store?.id || "",
      "movement.type": context.movement?.type || "",
      "movement.quantity": context.movement?.quantity || 0,
      "movement.id": context.movement?.id || "",
      "user.name": context.user?.name || "",
      "user.email": context.user?.email || ""
    };
    result = result.replace(/\{\{(\w+(?:\.\w+)*)\}\}/g, (match, varName) => {
      const value = this.getNestedValue(context, varName);
      if (value !== void 0 && value !== null) {
        return String(value);
      }
      if (variables[varName] !== void 0) {
        return String(variables[varName]);
      }
      return match;
    });
    return result;
  },
  getNestedValue(obj, path4) {
    return path4.split(".").reduce((current, key) => {
      return current && current[key] !== void 0 ? current[key] : void 0;
    }, obj);
  }
};

// src/services/workflow-engine/condition-evaluator.service.ts
var ConditionEvaluator = {
  evaluate(condition, context) {
    if (!condition.conditions || condition.conditions.length === 0) {
      return true;
    }
    const results = condition.conditions.map(
      (c) => this.evaluateExpression(c.field, c.operator, c.value, context)
    );
    return this.combineConditions(results, condition.logicalOperator);
  },
  evaluateExpression(field, operator, value, context) {
    const fieldValue = this.getFieldValue(field, context);
    switch (operator) {
      case "<":
        return fieldValue < value;
      case ">":
        return fieldValue > value;
      case "==":
        return this.deepEqual(fieldValue, value);
      case "<=":
        return fieldValue <= value;
      case ">=":
        return fieldValue >= value;
      case "!=":
        return !this.deepEqual(fieldValue, value);
      default:
        return false;
    }
  },
  combineConditions(results, logicalOperator) {
    if (results.length === 0) {
      return true;
    }
    if (logicalOperator === "AND") {
      return results.every((r) => r === true);
    }
    if (logicalOperator === "OR") {
      return results.some((r) => r === true);
    }
    return false;
  },
  getFieldValue(field, context) {
    const fieldMap = {
      stock_quantity: context.product?.stock || 0,
      movement_value: context.movement?.quantity || 0,
      movement_type: context.movement?.type || "",
      stock_percentage: this.calculateStockPercentage(context)
    };
    if (fieldMap[field] !== void 0) {
      return fieldMap[field];
    }
    const parts = field.split(".");
    let current = context;
    for (const part of parts) {
      if (current && typeof current === "object" && part in current) {
        current = current[part];
      } else {
        return null;
      }
    }
    return current;
  },
  calculateStockPercentage(context) {
    if (!context.product) {
      return 0;
    }
    const stock = context.product.stock || 0;
    const stockMin = context.product.stockMin || 0;
    const stockMax = context.product.stockMax || 1;
    if (stockMax === 0) {
      return 0;
    }
    return (stock - stockMin) / (stockMax - stockMin) * 100;
  },
  deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (typeof a === "object") {
      if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (!this.deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      if (keysA.length !== keysB.length) {
        return false;
      }
      for (const key of keysA) {
        if (!(key in b)) {
          return false;
        }
        if (!this.deepEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
};

// src/services/workflow-engine/loop-controller.service.ts
var MAX_LOOP_ITERATIONS = 100;
var loopStates = {};
var LoopController = {
  checkLoop(nodeId, executionPath) {
    const visitCount = executionPath.filter((id) => id === nodeId).length;
    return visitCount >= MAX_LOOP_ITERATIONS;
  },
  async incrementLoopCounter(nodeId, executionId) {
    if (!loopStates[executionId]) {
      loopStates[executionId] = {};
    }
    const loopState = loopStates[executionId];
    if (!loopState[nodeId]) {
      loopState[nodeId] = {
        nodeId,
        iterationCount: 0,
        lastVisit: /* @__PURE__ */ new Date()
      };
    }
    const state = loopState[nodeId];
    state.iterationCount++;
    state.lastVisit = /* @__PURE__ */ new Date();
    return state.iterationCount;
  },
  getIterationCount(nodeId, executionId) {
    if (!loopStates[executionId]) {
      return 0;
    }
    const loopState = loopStates[executionId];
    if (!loopState[nodeId]) {
      return 0;
    }
    return loopState[nodeId].iterationCount;
  },
  isLoopLimitReached(nodeId, executionId) {
    const count = this.getIterationCount(nodeId, executionId);
    return count >= MAX_LOOP_ITERATIONS;
  },
  resetLoopCounters(executionId) {
    delete loopStates[executionId];
  },
  async detectAndHandleLoop(nodeId, executionId, executionPath) {
    const hasLoop = this.checkLoop(nodeId, executionId, executionPath);
    if (hasLoop) {
      const iteration2 = await this.incrementLoopCounter(nodeId, executionId);
      const limitReached = this.isLoopLimitReached(nodeId, executionId);
      if (limitReached) {
        await FlowExecutionCommands.update(executionId, {
          status: "FAILED",
          error: `Loop limit exceeded at node "${nodeId}" after ${iteration2} iterations`
        });
        return { allowed: false, iteration: iteration2 };
      }
      return { allowed: true, iteration: iteration2 };
    }
    const iteration = await this.incrementLoopCounter(nodeId, executionId);
    return { allowed: true, iteration };
  }
};

// src/services/workflow-engine/workflow-engine.service.ts
var WorkflowEngine = {
  async executeWorkflow(flow, triggerData, isTest = false) {
    const executionId = `exec-${Date.now()}`;
    const state = {
      executionId,
      executionPath: [],
      log: []
    };
    if (!isTest) {
      await FlowExecutionCommands.create({
        flowId: flow.id,
        status: "RUNNING",
        triggerType: triggerData.trigger?.type || "manual",
        triggerData,
        executionLog: []
      });
    }
    try {
      const context = this.buildExecutionContext(triggerData);
      const result = await this.executeNodes(flow.nodes, flow.edges, context, state);
      if (!isTest) {
        await FlowExecutionCommands.finalize(executionId, result.success, result.error);
      }
      return {
        success: result.success,
        executionId,
        log: state.log
      };
    } catch (error) {
      if (!isTest) {
        await FlowExecutionCommands.finalize(executionId, false, error.message);
      }
      throw error;
    }
  },
  async executeNodes(nodes, edges, context, state) {
    const triggerNodes = nodes.filter((n) => n.type === "trigger");
    if (triggerNodes.length === 0) {
      throw new Error("No trigger node found");
    }
    const triggerNode = triggerNodes[0];
    state.executionPath.push(triggerNode.id);
    state.log.push({
      nodeId: triggerNode.id,
      nodeType: "trigger",
      status: "success",
      result: { triggered: true },
      timestamp: /* @__PURE__ */ new Date()
    });
    await this.executeFlowFromNode(triggerNode, nodes, edges, context, state);
    return { success: true };
  },
  async executeFlowFromNode(node, allNodes, edges, context, state) {
    const loopCheck = await LoopController.detectAndHandleLoop(
      node.id,
      state.executionId,
      state.executionPath
    );
    if (!loopCheck.allowed) {
      throw new Error(`Loop detected at node ${node.id} after ${loopCheck.iteration} iterations`);
    }
    state.executionPath.push(node.id);
    try {
      switch (node.type) {
        case "trigger":
          break;
        case "condition": {
          const conditionResult = await ConditionEvaluator.evaluate(
            node.data.config,
            context
          );
          state.log.push({
            nodeId: node.id,
            nodeType: "condition",
            status: conditionResult ? "success" : "skipped",
            result: { evaluated: conditionResult },
            timestamp: /* @__PURE__ */ new Date()
          });
          if (!conditionResult) {
            return;
          }
          break;
        }
        case "action":
        case "notification": {
          const actionResult = await ActionExecutor.executeAction(
            node.data.config,
            context
          );
          state.log.push({
            nodeId: node.id,
            nodeType: node.type,
            status: "success",
            result: actionResult,
            timestamp: /* @__PURE__ */ new Date()
          });
          break;
        }
      }
      const nextEdges = edges.filter((edge) => edge.source === node.id);
      for (const edge of nextEdges) {
        const nextNode = allNodes.find((n) => n.id === edge.target);
        if (nextNode) {
          await this.executeFlowFromNode(nextNode, allNodes, edges, context, state);
        }
      }
    } catch (error) {
      state.log.push({
        nodeId: node.id,
        nodeType: node.type,
        status: "failed",
        error: error.message,
        timestamp: /* @__PURE__ */ new Date()
      });
      throw error;
    }
  },
  async evaluateCondition(conditionConfig, context) {
    return ConditionEvaluator.evaluate(conditionConfig, context);
  },
  async executeAction(actionConfig, context) {
    return ActionExecutor.executeAction(actionConfig, context);
  },
  buildExecutionContext(triggerData) {
    return {
      trigger: {
        type: triggerData.trigger?.type || "manual",
        data: triggerData,
        timestamp: /* @__PURE__ */ new Date()
      },
      product: triggerData.product,
      store: triggerData.store,
      movement: triggerData.movement,
      user: triggerData.user,
      variables: triggerData.variables || {}
    };
  }
};

// src/services/workflow-engine/trigger-handler.service.ts
var TriggerHandler = {
  async handleMovementCreated(movement) {
    try {
      console.log("\u{1F514} Trigger: Movement created", { movementId: movement.id });
      const flows = await FlowQueries.getActiveFlowsByTrigger(movement.storeId, "movement_created");
      console.log(`Found ${flows.length} flows to execute`);
      for (const flow of flows) {
        try {
          if (this.shouldExecuteFlow(flow, { movement })) {
            await this.executeFlow(flow, {
              trigger: { type: "movement_created" },
              movement,
              store: { id: movement.storeId },
              variables: {}
            });
          }
        } catch (error) {
          console.error(`Error executing flow ${flow.id}:`, error);
        }
      }
    } catch (error) {
      console.error("Error handling movement created:", error);
      throw error;
    }
  },
  async handleStockChange(productId, storeId, change) {
    try {
      console.log("\u{1F514} Trigger: Stock change", { productId, storeId });
      const flows = await FlowQueries.getActiveFlowsByTrigger(storeId, "stock_change");
      console.log(`Found ${flows.length} flows to execute`);
      for (const flow of flows) {
        try {
          if (this.shouldExecuteFlow(flow, { productId, change })) {
            await this.executeFlow(flow, {
              trigger: { type: "stock_change" },
              product: change.product,
              store: { id: storeId },
              variables: { change: change.quantity }
            });
          }
        } catch (error) {
          console.error(`Error executing flow ${flow.id}:`, error);
        }
      }
    } catch (error) {
      console.error("Error handling stock change:", error);
      throw error;
    }
  },
  async handleStockBelowMin(product) {
    try {
      console.log("\u{1F514} Trigger: Stock below minimum", { productId: product.id });
      const flows = await FlowQueries.getActiveFlowsByTrigger(product.storeId, "stock_below_min");
      console.log(`Found ${flows.length} flows to execute`);
      for (const flow of flows) {
        try {
          if (this.shouldExecuteFlow(flow, { product })) {
            await this.executeFlow(flow, {
              trigger: { type: "stock_below_min" },
              product,
              store: { id: product.storeId },
              variables: {}
            });
          }
        } catch (error) {
          console.error(`Error executing flow ${flow.id}:`, error);
        }
      }
    } catch (error) {
      console.error("Error handling stock below min:", error);
      throw error;
    }
  },
  async handleStockAboveMax(product) {
    try {
      console.log("\u{1F514} Trigger: Stock above maximum", { productId: product.id });
      const flows = await FlowQueries.getActiveFlowsByTrigger(product.storeId, "stock_above_max");
      console.log(`Found ${flows.length} flows to execute`);
      for (const flow of flows) {
        try {
          if (this.shouldExecuteFlow(flow, { product })) {
            await this.executeFlow(flow, {
              trigger: { type: "stock_above_max" },
              product,
              store: { id: product.storeId },
              variables: {}
            });
          }
        } catch (error) {
          console.error(`Error executing flow ${flow.id}:`, error);
        }
      }
    } catch (error) {
      console.error("Error handling stock above max:", error);
      throw error;
    }
  },
  shouldExecuteFlow(flow, eventData) {
    const nodes = flow.nodes;
    const triggerNode = nodes.find((n) => n.type === "trigger");
    if (!triggerNode || !triggerNode.data?.config) {
      return false;
    }
    const config = triggerNode.data.config;
    const filters = config.filters || {};
    if (filters.productIds && filters.productIds.length > 0) {
      if (eventData.productId && !filters.productIds.includes(eventData.productId)) {
        return false;
      }
      if (eventData.product && !filters.productIds.includes(eventData.product.id)) {
        return false;
      }
    }
    if (filters.storeIds && filters.storeIds.length > 0) {
      if (eventData.store && !filters.storeIds.includes(eventData.store.id)) {
        return false;
      }
    }
    if (filters.movementTypes && filters.movementTypes.length > 0) {
      if (eventData.movement && !filters.movementTypes.includes(eventData.movement.type)) {
        return false;
      }
    }
    return true;
  },
  async executeFlow(flow, triggerData) {
    try {
      console.log(`Executing flow ${flow.id}: ${flow.name}`);
      const result = await WorkflowEngine.executeWorkflow(flow, triggerData, false);
      console.log(`Flow ${flow.id} executed:`, result);
      return result;
    } catch (error) {
      console.error(`Error executing flow ${flow.id}:`, error);
      throw error;
    }
  },
  async findMatchingFlows(eventType, eventData) {
    const flows = await FlowQueries.getActiveFlowsByTrigger(eventData.storeId, eventType);
    return flows.filter((flow) => this.shouldExecuteFlow(flow, eventData));
  }
};

// src/features/movement/commands/movement.commands.ts
var MovementCommands = {
  async create(data) {
    console.log("MovementCommands.create called with:", data);
    const storeId = data.storeId;
    console.log("Using storeId:", storeId);
    const product = await db.product.findFirst({
      where: {
        id: data.productId,
        storeId,
        status: true
      }
    });
    console.log("Product found:", product);
    if (!product) {
      throw new Error("Product not found in this store");
    }
    if (data.supplierId) {
      const supplier = await db.supplier.findUnique({
        where: {
          id: data.supplierId,
          status: true
        }
      });
      if (!supplier) {
        throw new Error("Supplier not found or inactive");
      }
    }
    console.log("Calculating current stock for product:", data.productId, "store:", storeId);
    const currentStock = await MovementCommands.getCurrentStock(data.productId, storeId);
    console.log("Current stock:", currentStock);
    const balanceBefore = currentStock;
    let balanceAfter = currentStock;
    if (data.type === "INBOUND") {
      balanceAfter = currentStock + data.quantity;
    } else if (data.type === "OUTBOUND" || data.type === "LOSS") {
      if (currentStock < data.quantity) {
        throw new Error("Insufficient stock for this movement");
      }
      balanceAfter = currentStock - data.quantity;
    }
    console.log("Balance before:", balanceBefore, "Balance after movement:", balanceAfter);
    let expirationDate = void 0;
    if (data.expiration) {
      expirationDate = /* @__PURE__ */ new Date(`${data.expiration}T00:00:00.000Z`);
    }
    const totalValue = data.price ? data.quantity * data.price : void 0;
    console.log("Creating movement in database...");
    const movement = await db.movement.create({
      data: {
        type: data.type,
        origin: data.origin,
        referenceCode: data.referenceCode,
        quantity: data.quantity,
        storeId,
        productId: data.productId,
        supplierId: data.supplierId,
        batch: data.batch,
        expiration: expirationDate,
        price: data.price,
        totalValue,
        note: data.note,
        userId: data.userId,
        balanceBefore,
        balanceAfter,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    console.log("Movement created successfully:", movement);
    try {
      await TriggerHandler.handleMovementCreated(movement);
    } catch (error) {
      console.error("Error triggering workflows for movement:", error);
    }
    return movement;
  },
  async update(id, data) {
    const existingMovement = await db.movement.findUnique({
      where: { id },
      include: {
        product: true
      }
    });
    if (!existingMovement) {
      throw new Error("Movement not found");
    }
    if (data.quantity !== void 0 || data.type !== void 0) {
      const currentStock = await MovementCommands.getCurrentStock(
        existingMovement.productId,
        existingMovement.storeId
      );
      let revertedStock = currentStock;
      if (existingMovement.type === "INBOUND") {
        revertedStock = currentStock - existingMovement.quantity;
      } else if (existingMovement.type === "OUTBOUND" || existingMovement.type === "LOSS") {
        revertedStock = currentStock + existingMovement.quantity;
      }
      const newQuantity = data.quantity ?? existingMovement.quantity;
      const newType = data.type ?? existingMovement.type;
      const newBalanceBefore = revertedStock;
      let newBalanceAfter = revertedStock;
      if (newType === "INBOUND") {
        newBalanceAfter = revertedStock + newQuantity;
      } else if (newType === "OUTBOUND" || newType === "LOSS") {
        if (revertedStock < newQuantity) {
          throw new Error("Insufficient stock for this movement");
        }
        newBalanceAfter = revertedStock - newQuantity;
      }
      ;
      data.balanceBefore = newBalanceBefore;
      data.balanceAfter = newBalanceAfter;
    }
    if (data.price !== void 0 || data.quantity !== void 0) {
      const newPrice = data.price ?? existingMovement.price;
      const newQuantity = data.quantity ?? existingMovement.quantity;
      data.totalValue = newPrice ? Number(newPrice) * newQuantity : null;
    }
    let expirationDate = void 0;
    if (data.expiration) {
      expirationDate = /* @__PURE__ */ new Date(`${data.expiration}T00:00:00.000Z`);
    }
    const updateData = {
      ...data,
      expiration: expirationDate,
      updatedAt: /* @__PURE__ */ new Date()
    };
    return await db.movement.update({
      where: { id },
      data: updateData,
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    const currentStock = await MovementCommands.getCurrentStock(
      movement.productId,
      movement.storeId
    );
    if (movement.type === "OUTBOUND" || movement.type === "LOSS") {
      if (currentStock < movement.quantity) {
        throw new Error("Cannot delete movement: insufficient stock to revert");
      }
    }
    await db.movement.delete({
      where: { id }
    });
    return { success: true };
  },
  async getCurrentStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    let stock = 0;
    for (const movement of movements) {
      if (movement.type === "INBOUND") {
        stock += movement.quantity;
      } else if (movement.type === "OUTBOUND" || movement.type === "LOSS") {
        stock -= movement.quantity;
      }
    }
    return Math.max(0, stock);
  },
  async recalculateStock(productId, storeId) {
    const movements = await db.movement.findMany({
      where: {
        productId,
        storeId
      },
      orderBy: {
        createdAt: "asc"
      }
    });
    let currentStock = 0;
    const updatedMovements = [];
    for (const movement of movements) {
      const balanceBefore = currentStock;
      if (movement.type === "INBOUND") {
        currentStock += movement.quantity;
      } else if (movement.type === "OUTBOUND" || movement.type === "LOSS") {
        currentStock -= movement.quantity;
      }
      if (movement.balanceBefore !== balanceBefore || movement.balanceAfter !== currentStock) {
        updatedMovements.push({
          id: movement.id,
          balanceBefore,
          balanceAfter: currentStock
        });
      }
    }
    if (updatedMovements.length > 0) {
      await db.$transaction(
        updatedMovements.map(
          (movement) => db.movement.update({
            where: { id: movement.id },
            data: {
              balanceBefore: movement.balanceBefore,
              balanceAfter: movement.balanceAfter
            }
          })
        )
      );
    }
    return currentStock;
  },
  // === FUNES ADICIONAIS DE MOVIMENTAO ===
  async createBulk(movements, userId) {
    const results = [];
    let successCount = 0;
    let failedCount = 0;
    for (let i = 0; i < movements.length; i++) {
      try {
        const movement = await MovementCommands.create({
          ...movements[i],
          userId
        });
        results.push({
          index: i,
          success: true,
          movement
        });
        successCount++;
      } catch (error) {
        results.push({
          index: i,
          success: false,
          error: error.message
        });
        failedCount++;
      }
    }
    return {
      success: successCount,
      failed: failedCount,
      results
    };
  },
  async verify(id, verified, note, userId) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    return await db.movement.update({
      where: { id },
      data: {
        verified,
        verifiedAt: verified ? /* @__PURE__ */ new Date() : null,
        verifiedBy: verified ? userId : null,
        verificationNote: note,
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async cancel(id, reason, userId) {
    const movement = await db.movement.findUnique({
      where: { id }
    });
    if (!movement) {
      throw new Error("Movement not found");
    }
    if (movement.cancelled) {
      throw new Error("Movement already cancelled");
    }
    const currentStock = await MovementCommands.getCurrentStock(
      movement.productId,
      movement.storeId
    );
    if (movement.type === "OUTBOUND" || movement.type === "LOSS") {
      if (currentStock < movement.quantity) {
        throw new Error("Cannot cancel movement: insufficient stock to revert");
      }
    }
    return await db.movement.update({
      where: { id },
      data: {
        cancelled: true,
        cancelledAt: /* @__PURE__ */ new Date(),
        cancelledBy: userId,
        cancellationReason: reason,
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getMovementReport(params) {
    const {
      storeId,
      productId,
      supplierId,
      type,
      origin,
      startDate,
      endDate,
      groupBy = "day"
    } = params;
    const where = {};
    if (storeId) where.storeId = storeId;
    if (productId) where.productId = productId;
    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;
    if (origin) where.origin = origin;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const movements = await db.movement.findMany({
      where,
      include: {
        store: {
          select: {
            id: true,
            name: true
          }
        },
        product: {
          select: {
            id: true,
            name: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true
          }
        }
      },
      orderBy: { createdAt: "asc" }
    });
    const groupedData = /* @__PURE__ */ new Map();
    for (const movement of movements) {
      let dateKey;
      const date = new Date(movement.createdAt);
      switch (groupBy) {
        case "day":
          dateKey = date.toISOString().split("T")[0];
          break;
        case "week": {
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          dateKey = weekStart.toISOString().split("T")[0];
          break;
        }
        case "month":
          dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
          break;
        case "year":
          dateKey = String(date.getFullYear());
          break;
        default:
          dateKey = date.toISOString().split("T")[0];
      }
      if (!groupedData.has(dateKey)) {
        groupedData.set(dateKey, {
          movements: 0,
          value: 0,
          inbound: 0,
          outbound: 0,
          loss: 0
        });
      }
      const groupData = groupedData.get(dateKey);
      if (groupData) {
        groupData.movements++;
        groupData.value += Number(movement.totalValue) || Number(movement.price) || 0;
        if (movement.type === "INBOUND") {
          groupData.inbound += movement.quantity;
        } else if (movement.type === "OUTBOUND") {
          groupData.outbound += movement.quantity;
        } else if (movement.type === "LOSS") {
          groupData.loss += movement.quantity;
        }
      }
    }
    const data = Array.from(groupedData.entries()).map(([date, stats]) => ({
      date,
      ...stats
    }));
    const byType = {
      INBOUND: { count: 0, value: 0, quantity: 0 },
      OUTBOUND: { count: 0, value: 0, quantity: 0 },
      LOSS: { count: 0, value: 0, quantity: 0 }
    };
    for (const movement of movements) {
      const typeData = byType[movement.type];
      typeData.count++;
      typeData.value += Number(movement.totalValue) || Number(movement.price) || 0;
      typeData.quantity += movement.quantity;
    }
    const storeMap = /* @__PURE__ */ new Map();
    for (const movement of movements) {
      const storeId2 = movement.storeId;
      if (!storeMap.has(storeId2)) {
        storeMap.set(storeId2, { movements: 0, value: 0 });
      }
      const storeData = storeMap.get(storeId2);
      if (storeData) {
        storeData.movements++;
        storeData.value += Number(movement.totalValue) || Number(movement.price) || 0;
      }
    }
    const byStore = Array.from(storeMap.entries()).map(([storeId2, stats]) => {
      const store = movements.find((m) => m.storeId === storeId2)?.store;
      return {
        storeId: storeId2,
        storeName: store?.name || "Unknown",
        ...stats
      };
    });
    const productMap = /* @__PURE__ */ new Map();
    for (const movement of movements) {
      const productId2 = movement.productId;
      if (!productMap.has(productId2)) {
        productMap.set(productId2, { movements: 0, quantity: 0 });
      }
      const productData = productMap.get(productId2);
      if (productData) {
        productData.movements++;
        productData.quantity += movement.quantity;
      }
    }
    const byProduct = Array.from(productMap.entries()).map(([productId2, stats]) => {
      const product = movements.find((m) => m.productId === productId2)?.product;
      return {
        productId: productId2,
        productName: product?.name || "Unknown",
        ...stats
      };
    });
    const supplierMap = /* @__PURE__ */ new Map();
    for (const movement of movements) {
      if (movement.supplierId) {
        const supplierId2 = movement.supplierId;
        if (!supplierMap.has(supplierId2)) {
          supplierMap.set(supplierId2, { movements: 0, value: 0 });
        }
        const supplierData = supplierMap.get(supplierId2);
        if (supplierData) {
          supplierData.movements++;
          supplierData.value += Number(movement.totalValue) || Number(movement.price) || 0;
        }
      }
    }
    const bySupplier = Array.from(supplierMap.entries()).map(([supplierId2, stats]) => {
      const supplier = movements.find((m) => m.supplierId === supplierId2)?.supplier;
      return {
        supplierId: supplierId2,
        supplierName: supplier?.corporateName || "Unknown",
        ...stats
      };
    });
    return {
      summary: {
        totalMovements: movements.length,
        totalValue: movements.reduce(
          (sum, m) => sum + (Number(m.totalValue) || Number(m.price) || 0),
          0
        ),
        period: {
          startDate: startDate || new Date(Math.min(...movements.map((m) => m.createdAt.getTime()))).toISOString().split("T")[0],
          endDate: endDate || new Date(Math.max(...movements.map((m) => m.createdAt.getTime()))).toISOString().split("T")[0]
        }
      },
      data,
      byType,
      byStore,
      byProduct,
      bySupplier
    };
  }
};

// src/features/movement/movement.controller.ts
var MovementController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { type, quantity, storeId, productId, supplierId, batch, expiration, price, note } = request.body;
      const userId = request.user?.id;
      console.log("Creating movement with data:", {
        type,
        quantity,
        storeId,
        productId,
        supplierId,
        batch,
        price,
        note,
        userId
      });
      const result = await MovementCommands.create({
        type,
        quantity,
        storeId,
        // Agora vem do middleware
        productId,
        supplierId,
        batch,
        expiration,
        price,
        note,
        userId
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found in this store") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Insufficient stock for this movement") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Supplier not found or inactive") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Store ID is required")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      console.log("MovementController.get: Getting movement with id:", id);
      const result = await MovementQueries.getById(id);
      if (!result) {
        console.log("MovementController.get: Movement not found");
        return reply.status(404).send({
          error: "Movement not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await MovementCommands.update(
        id,
        updateData
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Insufficient stock for this movement") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await MovementCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete movement: insufficient stock to revert") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const {
        page = 1,
        limit = 10,
        search,
        type,
        productId,
        supplierId,
        startDate,
        endDate
      } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.list({
        page,
        limit,
        search,
        type,
        storeId,
        productId,
        supplierId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === NOVOS ENDPOINTS ESPECFICOS ===
  async listByStore(request, reply) {
    try {
      const {
        page = 1,
        limit = 10,
        search,
        type,
        productId,
        supplierId,
        startDate,
        endDate
      } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Listing movements for store:", storeId);
      const result = await MovementQueries.getByStore(storeId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      if (search || productId || supplierId) {
        const filteredResult = await MovementQueries.list({
          page,
          limit,
          search,
          type,
          storeId,
          productId,
          supplierId,
          startDate,
          endDate
        });
        return reply.send(filteredResult);
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listByProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Listing movements for product:", productId, "in store:", storeId);
      const product = await db.product.findFirst({
        where: {
          id: productId,
          storeId,
          status: true
        }
      });
      if (!product) {
        return reply.status(404).send({
          error: "Product not found in this store"
        });
      }
      const result = await MovementQueries.getByProduct(productId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getByStore(request, reply) {
    try {
      const { storeId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const result = await MovementQueries.getByStore(storeId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store ID is required. User must be associated with a store."
        });
      }
      console.log("Getting movements for product:", productId, "in store:", storeId);
      const product = await ProductQueries.getById(productId, storeId);
      console.log("Product:", product);
      if (!product) {
        return reply.status(404).send({
          error: "Product not found in this store"
        });
      }
      const result = await MovementQueries.getByProduct(productId, {
        page,
        limit,
        type,
        startDate,
        endDate,
        storeId
      });
      console.log("Result:", result);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getBySupplier(request, reply) {
    try {
      const { supplierId } = request.params;
      const { page = 1, limit = 10, type, startDate, endDate } = request.query;
      const result = await MovementQueries.getBySupplier(supplierId, {
        page,
        limit,
        type,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStockHistory(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const { startDate, endDate } = request.query;
      const result = await MovementQueries.getStockHistory(productId, storeId, {
        startDate,
        endDate
      });
      return reply.send({ movements: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCurrentStock(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const result = await MovementQueries.getCurrentStock(productId, storeId);
      return reply.send({ currentStock: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await MovementQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, page = 1, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.search(q, storeId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getLowStockProducts(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getLowStockProducts(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async recalculateStock(request, reply) {
    try {
      const { productId, storeId } = request.params;
      const result = await MovementCommands.recalculateStock(productId, storeId);
      return reply.send({ currentStock: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS DE MOVIMENTAO ===
  async getReport(request, reply) {
    try {
      const { productId, supplierId, type, startDate, endDate, groupBy, format } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getMovementReport({
        storeId,
        productId,
        supplierId,
        type,
        startDate,
        endDate,
        groupBy
      });
      if (format === "csv") {
        return reply.type("text/csv").send("CSV generation not implemented yet");
      }
      if (format === "pdf") {
        return reply.type("application/pdf").send("PDF generation not implemented yet");
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async createBulk(request, reply) {
    try {
      const { movements } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.createBulk(
        movements,
        userId
      );
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verify(request, reply) {
    try {
      const { id } = request.params;
      const { verified, note } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.verify(id, verified, note, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async cancel(request, reply) {
    try {
      const { id } = request.params;
      const { reason } = request.body;
      const userId = request.user?.id;
      const result = await MovementCommands.cancel(id, reason, userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Movement not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Movement already cancelled") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Cannot cancel movement: insufficient stock to revert") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getVerifiedMovements(request, reply) {
    try {
      const { page = 1, limit = 10, verified, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getVerifiedMovements({
        page,
        limit,
        storeId,
        verified,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCancelledMovements(request, reply) {
    try {
      const { page = 1, limit = 10, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getCancelledMovements({
        page,
        limit,
        storeId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getAnalytics(request, reply) {
    try {
      const { productId, supplierId, startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getMovementAnalytics({
        storeId,
        productId,
        supplierId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async summarize(request, reply) {
    try {
      const result = await MovementQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async summarizeProduct(request, reply) {
    try {
      const { productId } = request.params;
      const { startDate, endDate } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await MovementQueries.getProductSummary(productId, {
        startDate,
        endDate,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENDPOINTS PARA ALERTAS DE ESTOQUE ===
  async checkStockAlerts(request, reply) {
    try {
      const finalStoreId = request.store?.id;
      if (!finalStoreId) {
        return reply.status(400).send({
          error: "Store ID is required"
        });
      }
      return reply.send({
        storeId: finalStoreId
        //lowStockCount: lowStockProducts.length,
        //products: lowStockProducts,
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async createLowStockSummaryNotification(request, reply) {
    try {
      const finalStoreId = request.store?.id;
      if (!finalStoreId) {
        return reply.status(400).send({
          error: "Store ID is required"
        });
      }
      return reply.status(201).send({
        message: "Low stock summary notification created"
        //notification,
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/movement/movement.schema.ts
var createMovementSchema = {
  body: {
    type: "object",
    required: ["type", "quantity", "productId"],
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 1 },
      storeId: { type: "string", minLength: 1 },
      // Obrigatrio, vem do middleware
      productId: { type: "string", minLength: 1 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date" },
      // Formato de data simples YYYY-MM-DD
      price: { type: "number", minimum: 0.01 },
      note: { type: "string", maxLength: 500 },
      userId: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var updateMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 1 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date" },
      // Formato de data simples YYYY-MM-DD
      price: { type: "number", minimum: 0.01 },
      note: { type: "string", maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var getMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        storeId: { type: "string" },
        productId: { type: "string" },
        supplierId: { type: "string", nullable: true },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        userId: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var listMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var getByStoreSchema = {
  params: {
    type: "object",
    required: ["storeId"],
    properties: {
      storeId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getByProductSchema = {
  params: {
    type: "object",
    required: ["productId"],
    properties: {
      productId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getBySupplierSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              storeId: { type: "string" },
              productId: { type: "string" },
              supplierId: { type: "string", nullable: true },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              userId: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStockHistorySchema = {
  params: {
    type: "object",
    required: ["productId", "storeId"],
    properties: {
      productId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: { type: "object" },
        store: { type: "object" },
        currentStock: { type: "number" },
        history: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        summary: {
          type: "object",
          properties: {
            totalEntries: { type: "number" },
            totalExits: { type: "number" },
            totalLosses: { type: "number" },
            netMovement: { type: "number" }
          }
        }
      }
    }
  }
};
var getMovementReportSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" },
      groupBy: {
        type: "string",
        enum: ["day", "week", "month", "year"],
        default: "day"
      },
      format: {
        type: "string",
        enum: ["json", "csv", "pdf"],
        default: "json"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        summary: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalValue: { type: "number" },
            period: {
              type: "object",
              properties: {
                startDate: { type: "string" },
                endDate: { type: "string" }
              }
            }
          }
        },
        data: {
          type: "array",
          items: {
            type: "object",
            properties: {
              date: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" },
              entrada: { type: "number" },
              saida: { type: "number" },
              perda: { type: "number" }
            }
          }
        },
        byType: {
          type: "object",
          properties: {
            ENTRADA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            },
            SAIDA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            },
            PERDA: {
              type: "object",
              properties: {
                count: { type: "number" },
                value: { type: "number" },
                quantity: { type: "number" }
              }
            }
          }
        },
        byStore: {
          type: "array",
          items: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              storeName: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byProduct: {
          type: "array",
          items: {
            type: "object",
            properties: {
              productId: { type: "string" },
              productName: { type: "string" },
              movements: { type: "number" },
              quantity: { type: "number" }
            }
          }
        },
        bySupplier: {
          type: "array",
          items: {
            type: "object",
            properties: {
              supplierId: { type: "string" },
              supplierName: { type: "string" },
              movements: { type: "number" },
              value: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var createBulkMovementSchema = {
  body: {
    type: "object",
    required: ["movements"],
    properties: {
      movements: {
        type: "array",
        minItems: 1,
        maxItems: 100,
        items: {
          type: "object",
          required: ["type", "quantity", "storeId", "productId"],
          properties: {
            type: {
              type: "string",
              enum: ["ENTRADA", "SAIDA", "PERDA"]
            },
            quantity: { type: "number", minimum: 1 },
            storeId: { type: "string", minLength: 1 },
            productId: { type: "string", minLength: 1 },
            supplierId: { type: "string" },
            batch: { type: "string" },
            expiration: { type: "string", format: "date" },
            price: { type: "number", minimum: 0 },
            note: { type: "string", maxLength: 500 }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        success: { type: "number" },
        failed: { type: "number" },
        results: {
          type: "array",
          items: {
            type: "object",
            properties: {
              index: { type: "number" },
              success: { type: "boolean" },
              movement: { type: "object", nullable: true },
              error: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var verifyMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["verified"],
    properties: {
      verified: { type: "boolean" },
      note: { type: "string", maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        verified: { type: "boolean" },
        verifiedAt: { type: "string", format: "date-time", nullable: true },
        verifiedBy: { type: "string", nullable: true },
        verificationNote: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var cancelMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["reason"],
    properties: {
      reason: { type: "string", minLength: 1, maxLength: 500 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        cancelled: { type: "boolean" },
        cancelledAt: { type: "string", format: "date-time" },
        cancelledBy: { type: "string", nullable: true },
        cancellationReason: { type: "string" },
        updatedAt: { type: "string", format: "date-time" },
        store: { type: "object" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true }
      }
    }
  }
};
var getVerifiedMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      storeId: { type: "string" },
      verified: { type: "boolean" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              verified: { type: "boolean" },
              verifiedAt: { type: "string", format: "date-time", nullable: true },
              verifiedBy: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getCancelledMovementsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      storeId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              cancelled: { type: "boolean" },
              cancelledAt: { type: "string", format: "date-time" },
              cancelledBy: { type: "string", nullable: true },
              cancellationReason: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              store: { type: "object" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getMovementAnalyticsSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      productId: { type: "string" },
      supplierId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        summary: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalValue: { type: "number" },
            averageValue: { type: "number" },
            verifiedCount: { type: "number" },
            cancelledCount: { type: "number" },
            verificationRate: { type: "number" },
            cancellationRate: { type: "number" }
          }
        },
        byType: {
          type: "array",
          items: {
            type: "object",
            properties: {
              type: { type: "string" },
              count: { type: "number" },
              quantity: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byMonth: {
          type: "array",
          items: {
            type: "object",
            properties: {
              month: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byStore: {
          type: "array",
          items: {
            type: "object",
            properties: {
              storeId: { type: "string" },
              storeName: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        byProduct: {
          type: "array",
          items: {
            type: "object",
            properties: {
              productId: { type: "string" },
              productName: { type: "string" },
              count: { type: "number" },
              quantity: { type: "number" },
              value: { type: "number" }
            }
          }
        },
        bySupplier: {
          type: "array",
          items: {
            type: "object",
            properties: {
              supplierId: { type: "string" },
              supplierName: { type: "string" },
              count: { type: "number" },
              value: { type: "number" }
            }
          }
        }
      }
    }
  }
};
var MovementSchemas = {
  create: createMovementSchema,
  update: updateMovementSchema,
  get: getMovementSchema,
  delete: deleteMovementSchema,
  list: listMovementsSchema,
  getByStore: getByStoreSchema,
  getByProduct: getByProductSchema,
  getBySupplier: getBySupplierSchema,
  getStockHistory: getStockHistorySchema,
  // Funes adicionais
  getReport: getMovementReportSchema,
  createBulk: createBulkMovementSchema,
  verify: verifyMovementSchema,
  cancel: cancelMovementSchema,
  getVerifiedMovements: getVerifiedMovementsSchema,
  getCancelledMovements: getCancelledMovementsSchema,
  getAnalytics: getMovementAnalyticsSchema
};

// src/features/movement/movement.routes.ts
async function MovementRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: MovementSchemas.create,
    handler: MovementController.create
  });
  fastify2.get("/", {
    schema: MovementSchemas.list,
    handler: MovementController.list
  });
  fastify2.get("/my-store", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1 },
          limit: { type: "number", minimum: 1, maximum: 100 },
          search: { type: "string" },
          type: { type: "string", enum: ["ENTRADA", "SAIDA", "PERDA"] },
          productId: { type: "string" },
          supplierId: { type: "string" },
          startDate: { type: "string", format: "date-time" },
          endDate: { type: "string", format: "date-time" }
        }
      }
    },
    handler: MovementController.listByStore
  });
  fastify2.get("/my-store/product/:productId", {
    schema: {
      params: {
        type: "object",
        required: ["productId"],
        properties: {
          productId: { type: "string", minLength: 1 }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1 },
          limit: { type: "number", minimum: 1, maximum: 100 },
          type: { type: "string", enum: ["ENTRADA", "SAIDA", "PERDA"] },
          startDate: { type: "string", format: "date-time" },
          endDate: { type: "string", format: "date-time" }
        }
      }
    },
    handler: MovementController.listByProduct
  });
  fastify2.get("/:id", {
    schema: MovementSchemas.get,
    handler: MovementController.get
  });
  fastify2.put("/:id", {
    schema: MovementSchemas.update,
    handler: MovementController.update
  });
  fastify2.delete("/:id", {
    schema: MovementSchemas.delete,
    handler: MovementController.delete
  });
  fastify2.get("/store/:storeId", {
    schema: MovementSchemas.getByStore,
    handler: MovementController.getByStore
  });
  fastify2.get("/product/:productId", {
    schema: MovementSchemas.getByProduct,
    handler: MovementController.getByProduct
  });
  fastify2.get("/product/:productId/summary", {
    handler: MovementController.summarizeProduct
  });
  fastify2.get("/supplier/:supplierId", {
    schema: MovementSchemas.getBySupplier,
    handler: MovementController.getBySupplier
  });
  fastify2.get("/stock-history/:productId/:storeId", {
    schema: MovementSchemas.getStockHistory,
    handler: MovementController.getStockHistory
  });
  fastify2.get("/current-stock/:productId/:storeId", {
    handler: MovementController.getCurrentStock
  });
  fastify2.get("/stats", {
    handler: MovementController.getStats
  });
  fastify2.get("/search", {
    handler: MovementController.search
  });
  fastify2.get("/low-stock", {
    handler: MovementController.getLowStockProducts
  });
  fastify2.post("/recalculate-stock/:productId/:storeId", {
    handler: MovementController.recalculateStock
  });
  fastify2.get("/summarize", {
    handler: MovementController.summarize
  });
  fastify2.get("/stock-alerts", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          storeId: { type: "string" }
        }
      }
    },
    handler: MovementController.checkStockAlerts
  });
  fastify2.post("/stock-alerts/summary", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          storeId: { type: "string" }
        }
      }
    },
    handler: MovementController.createLowStockSummaryNotification
  });
}

// src/features/notification/commands/notification.commands.ts
var NotificationCommands = {
  async create(data) {
    return await db.notification.create({
      data: {
        userId: data.userId,
        title: data.title,
        message: data.message,
        type: data.type || "INFO",
        priority: data.priority || "MEDIUM",
        data: data.data,
        actionUrl: data.actionUrl,
        expiresAt: data.expiresAt
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async update(id, data) {
    return await db.notification.update({
      where: { id },
      data,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    return await db.notification.delete({
      where: { id }
    });
  },
  async markAsRead(id) {
    return await db.notification.update({
      where: { id },
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async markAsUnread(id) {
    return await db.notification.update({
      where: { id },
      data: {
        isRead: false,
        readAt: null
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async markAllAsRead(userId) {
    return await db.notification.updateMany({
      where: {
        userId,
        isRead: false
      },
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      }
    });
  },
  async deleteExpired() {
    return await db.notification.deleteMany({
      where: {
        expiresAt: {
          lt: /* @__PURE__ */ new Date()
        }
      }
    });
  },
  async deleteByUser(userId) {
    return await db.notification.deleteMany({
      where: { userId }
    });
  },
  async markStockAlertsAsRead(userId, storeId) {
    const whereCondition = {
      userId,
      isRead: false,
      type: "STOCK_ALERT"
    };
    if (storeId) {
      whereCondition.data = {
        path: ["storeId"],
        equals: storeId
      };
    }
    return await db.notification.updateMany({
      where: whereCondition,
      data: {
        isRead: true,
        readAt: /* @__PURE__ */ new Date()
      }
    });
  }
};

// src/features/notification/queries/notification.queries.ts
var NotificationQueries = {
  async getById(id) {
    return await db.notification.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, type, priority, isRead, userId } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (userId) {
      where.userId = userId;
    }
    if (type) {
      where.type = type;
    }
    if (priority) {
      where.priority = priority;
    }
    if (isRead !== void 0) {
      where.isRead = isRead;
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { message: { contains: search, mode: "insensitive" } }
      ];
    }
    where.OR = [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }];
    const [items, total] = await Promise.all([
      db.notification.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.notification.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByUser(userId, params) {
    return await NotificationQueries.list({
      userId,
      ...params
    });
  },
  async getUnread(userId, limit) {
    return await db.notification.findMany({
      where: {
        userId,
        isRead: false,
        OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
      },
      take: limit || 10,
      orderBy: [{ priority: "desc" }, { createdAt: "desc" }],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getByType(type, limit) {
    return await db.notification.findMany({
      where: {
        type,
        OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
      },
      take: limit || 10,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getByPriority(priority, limit) {
    return await db.notification.findMany({
      where: {
        priority,
        OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
      },
      take: limit || 10,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async search(term, limit = 10) {
    return await db.notification.findMany({
      where: {
        AND: [
          {
            OR: [
              { title: { contains: term, mode: "insensitive" } },
              { message: { contains: term, mode: "insensitive" } }
            ]
          },
          {
            OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
          }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getStats(userId) {
    const where = userId ? { userId } : {};
    const [total, unread, byType, byPriority] = await Promise.all([
      db.notification.count({ where }),
      db.notification.count({
        where: {
          ...where,
          isRead: false,
          OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
        }
      }),
      db.notification.groupBy({
        by: ["type"],
        where,
        _count: true
      }),
      db.notification.groupBy({
        by: ["priority"],
        where,
        _count: true
      })
    ]);
    return {
      total,
      unread,
      read: total - unread,
      byType: byType.reduce(
        (acc, item) => {
          acc[item.type] = item._count;
          return acc;
        },
        {}
      ),
      byPriority: byPriority.reduce(
        (acc, item) => {
          acc[item.priority] = item._count;
          return acc;
        },
        {}
      )
    };
  },
  async getRecent(userId, days = 7, limit = 20) {
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - days);
    return await db.notification.findMany({
      where: {
        userId,
        createdAt: {
          gte: startDate
        },
        OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
      },
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  // === QUERIES ESPECFICAS PARA ALERTAS DE ESTOQUE ===
  async getStockAlerts(params) {
    const { userId, storeId, isRead, limit = 20 } = params;
    const where = {
      type: "STOCK_ALERT",
      OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
    };
    if (userId) {
      where.userId = userId;
    }
    if (isRead !== void 0) {
      where.isRead = isRead;
    }
    if (storeId) {
      where.data = {
        path: ["storeId"],
        equals: storeId
      };
    }
    return await db.notification.findMany({
      where,
      take: limit,
      orderBy: [{ priority: "desc" }, { createdAt: "desc" }],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async getUnreadStockAlerts(userId, limit = 10) {
    return await db.notification.findMany({
      where: {
        userId,
        type: "STOCK_ALERT",
        isRead: false,
        OR: [{ expiresAt: null }, { expiresAt: { gt: /* @__PURE__ */ new Date() } }]
      },
      take: limit,
      orderBy: [{ priority: "desc" }, { createdAt: "desc" }],
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
};

// src/features/notification/notification.controller.ts
var NotificationController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { userId, title, message, type, priority, data, actionUrl, expiresAt } = request.body;
      const result = await NotificationCommands.create({
        userId,
        title,
        message,
        type,
        priority,
        data,
        actionUrl,
        expiresAt: expiresAt ? new Date(expiresAt) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Notification not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.expiresAt) {
        updateData.expiresAt = new Date(updateData.expiresAt);
      }
      const result = await NotificationCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await NotificationCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, priority, isRead, userId } = request.query;
      const result = await NotificationQueries.list({
        page,
        limit,
        search,
        type,
        priority,
        isRead,
        userId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getByUser(request, reply) {
    try {
      const { userId } = request.params;
      const { page = 1, limit = 10, isRead, type } = request.query;
      const result = await NotificationQueries.getByUser(userId, {
        page,
        limit,
        isRead,
        type
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnread(request, reply) {
    try {
      const { userId } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getUnread(userId, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByType(request, reply) {
    try {
      const { type } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getByType(type, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByPriority(request, reply) {
    try {
      const { priority } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getByPriority(priority, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { userId } = request.params;
      const { days = 7, limit = 20 } = request.query;
      const result = await NotificationQueries.getRecent(userId, days, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { userId } = request.query;
      const result = await NotificationQueries.getStats(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await NotificationQueries.search(q, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async markAsRead(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationCommands.markAsRead(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAsUnread(request, reply) {
    try {
      const { id } = request.params;
      const result = await NotificationCommands.markAsUnread(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Notification not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markAllAsRead(request, reply) {
    try {
      const { userId } = request.body;
      const result = await NotificationCommands.markAllAsRead(userId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteExpired(request, reply) {
    try {
      const result = await NotificationCommands.deleteExpired();
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteByUser(request, reply) {
    try {
      const { userId } = request.params;
      const result = await NotificationCommands.deleteByUser(userId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === ENDPOINTS ESPECFICOS PARA ALERTAS DE ESTOQUE ===
  async getStockAlerts(request, reply) {
    try {
      const { userId, storeId, isRead, limit = 20 } = request.query;
      const result = await NotificationQueries.getStockAlerts({
        userId,
        storeId,
        isRead,
        limit
      });
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnreadStockAlerts(request, reply) {
    try {
      const { userId } = request.params;
      const { limit = 10 } = request.query;
      const result = await NotificationQueries.getUnreadStockAlerts(userId, limit);
      return reply.send({ notifications: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markStockAlertsAsRead(request, reply) {
    try {
      const { userId, storeId } = request.body;
      const result = await NotificationCommands.markStockAlertsAsRead(userId, storeId);
      return reply.send({
        success: true,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/notification/notification.schema.ts
var notificationTypeEnum = [
  "INFO",
  "SUCCESS",
  "WARNING",
  "ERROR",
  "STOCK_ALERT",
  "MOVEMENT",
  "PERMISSION",
  "SYSTEM"
];
var notificationPriorityEnum = ["LOW", "MEDIUM", "HIGH", "URGENT"];
var notificationResponseSchema = {
  type: "object",
  properties: {
    id: { type: "string" },
    userId: { type: "string" },
    title: { type: "string" },
    message: { type: "string" },
    type: { type: "string", enum: notificationTypeEnum },
    priority: { type: "string", enum: notificationPriorityEnum },
    isRead: { type: "boolean" },
    readAt: { type: ["string", "null"], format: "date-time" },
    data: { type: "object" },
    actionUrl: { type: ["string", "null"] },
    expiresAt: { type: ["string", "null"], format: "date-time" },
    createdAt: { type: "string", format: "date-time" },
    updatedAt: { type: "string", format: "date-time" },
    user: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: ["string", "null"] },
        email: { type: "string" }
      }
    }
  }
};
var createNotificationSchema = {
  body: {
    type: "object",
    required: ["userId", "title", "message"],
    properties: {
      userId: { type: "string" },
      title: { type: "string", minLength: 1, maxLength: 255 },
      message: { type: "string", minLength: 1, maxLength: 1e3 },
      type: { type: "string", enum: notificationTypeEnum, default: "INFO" },
      priority: { type: "string", enum: notificationPriorityEnum, default: "MEDIUM" },
      data: { type: "object" },
      actionUrl: { type: "string", format: "uri" },
      expiresAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: notificationResponseSchema,
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1, maxLength: 255 },
      message: { type: "string", minLength: 1, maxLength: 1e3 },
      type: { type: "string", enum: notificationTypeEnum },
      priority: { type: "string", enum: notificationPriorityEnum },
      data: { type: "object" },
      actionUrl: { type: "string", format: "uri" },
      expiresAt: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: notificationResponseSchema,
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: notificationResponseSchema,
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listNotificationsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: { type: "string", enum: notificationTypeEnum },
      priority: { type: "string", enum: notificationPriorityEnum },
      isRead: { type: "boolean" },
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: notificationResponseSchema
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var deleteNotificationSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var markAsReadSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: notificationResponseSchema,
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var markAllAsReadSchema = {
  body: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        success: { type: "boolean" },
        count: { type: "number" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByUserSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      isRead: { type: "boolean" },
      type: { type: "string", enum: notificationTypeEnum }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: notificationResponseSchema
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUnreadSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByTypeSchema = {
  params: {
    type: "object",
    required: ["type"],
    properties: {
      type: { type: "string", enum: notificationTypeEnum }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getByPrioritySchema = {
  params: {
    type: "object",
    required: ["priority"],
    properties: {
      priority: { type: "string", enum: notificationPriorityEnum }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getRecentSchema = {
  params: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      days: { type: "number", minimum: 1, maximum: 365, default: 7 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 20 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getStatsSchema2 = {
  querystring: {
    type: "object",
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        unread: { type: "number" },
        read: { type: "number" },
        byType: { type: "object" },
        byPriority: { type: "object" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var searchSchema = {
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        notifications: {
          type: "array",
          items: notificationResponseSchema
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var NotificationSchemas = {
  create: createNotificationSchema,
  update: updateNotificationSchema,
  get: getNotificationSchema,
  delete: deleteNotificationSchema,
  list: listNotificationsSchema,
  markAsRead: markAsReadSchema,
  markAllAsRead: markAllAsReadSchema,
  getByUser: getByUserSchema,
  getUnread: getUnreadSchema,
  getByType: getByTypeSchema,
  getByPriority: getByPrioritySchema,
  getRecent: getRecentSchema,
  getStats: getStatsSchema2,
  search: searchSchema
};

// src/features/notification/notification.routes.ts
async function NotificationRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: NotificationSchemas.create,
    handler: NotificationController.create
  });
  fastify2.get("/", {
    schema: NotificationSchemas.list,
    handler: NotificationController.list
  });
  fastify2.get("/:id", {
    schema: NotificationSchemas.get,
    handler: NotificationController.get
  });
  fastify2.put("/:id", {
    schema: NotificationSchemas.update,
    handler: NotificationController.update
  });
  fastify2.delete("/:id", {
    schema: NotificationSchemas.delete,
    handler: NotificationController.delete
  });
  fastify2.get("/user/:userId", {
    schema: NotificationSchemas.getByUser,
    handler: NotificationController.getByUser
  });
  fastify2.get("/user/:userId/unread", {
    schema: NotificationSchemas.getUnread,
    handler: NotificationController.getUnread
  });
  fastify2.get("/user/:userId/recent", {
    schema: NotificationSchemas.getRecent,
    handler: NotificationController.getRecent
  });
  fastify2.get("/type/:type", {
    schema: NotificationSchemas.getByType,
    handler: NotificationController.getByType
  });
  fastify2.get("/priority/:priority", {
    schema: NotificationSchemas.getByPriority,
    handler: NotificationController.getByPriority
  });
  fastify2.get("/stats", {
    schema: NotificationSchemas.getStats,
    handler: NotificationController.getStats
  });
  fastify2.get("/search", {
    schema: NotificationSchemas.search,
    handler: NotificationController.search
  });
  fastify2.patch("/:id/read", {
    schema: NotificationSchemas.markAsRead,
    handler: NotificationController.markAsRead
  });
  fastify2.patch("/:id/unread", {
    schema: NotificationSchemas.markAsRead,
    handler: NotificationController.markAsUnread
  });
  fastify2.patch("/mark-all-read", {
    schema: NotificationSchemas.markAllAsRead,
    handler: NotificationController.markAllAsRead
  });
  fastify2.delete("/expired", {
    handler: NotificationController.deleteExpired
  });
  fastify2.delete("/user/:userId", {
    handler: NotificationController.deleteByUser
  });
  fastify2.get("/stock-alerts", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          userId: { type: "string" },
          storeId: { type: "string" },
          isRead: { type: "boolean" },
          limit: { type: "number", minimum: 1, maximum: 100 }
        }
      }
    },
    handler: NotificationController.getStockAlerts
  });
  fastify2.get("/user/:userId/stock-alerts/unread", {
    schema: {
      params: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" }
        }
      },
      querystring: {
        type: "object",
        properties: {
          limit: { type: "number", minimum: 1, maximum: 100 }
        }
      }
    },
    handler: NotificationController.getUnreadStockAlerts
  });
  fastify2.patch("/stock-alerts/mark-read", {
    schema: {
      body: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" },
          storeId: { type: "string" }
        }
      }
    },
    handler: NotificationController.markStockAlertsAsRead
  });
}

// src/features/polar/polar.controller.ts
var import_node_crypto2 = require("crypto");
var PolarController = {
  async list(request, reply) {
    try {
      const { page = 1, limit = 10 } = request.query;
      const result = await PolarQueries.list({ page, limit });
      return reply.status(200).send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async checkout(request, reply) {
    try {
      const { productId } = request.body;
      const customer = request.user;
      const result = await PolarCommands.checkout({ productId, customer });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async webhook(request, reply) {
    try {
      const secret = process.env.POLAR_WEBHOOK_SECRET;
      const signatureHeader = request.headers["polar-signature"] || request.headers["x-polar-signature"];
      const rawBody = request.rawBody;
      if (!secret) {
        return reply.status(500).send({ error: "Webhook secret not configured" });
      }
      if (!signatureHeader || !rawBody) {
        return reply.status(400).send({ error: "Missing signature or raw body" });
      }
      const parseSignature = (header) => {
        const trimmed = header.trim();
        if (trimmed.startsWith("sha256=")) {
          return { hash: trimmed.slice(7), timestamp: void 0 };
        }
        const parts = trimmed.split(",").map((p) => p.trim());
        const kv = new Map(
          parts.map((p) => {
            const idx = p.indexOf("=");
            if (idx === -1) return [p, ""];
            return [p.slice(0, idx), p.slice(idx + 1)];
          })
        );
        return {
          hash: kv.get("v1") || kv.get("sha256"),
          timestamp: kv.get("t")
        };
      };
      const { hash: receivedHash, timestamp } = parseSignature(signatureHeader);
      if (!receivedHash) {
        return reply.status(400).send({ error: "Invalid signature format" });
      }
      if (timestamp) {
        const tsNum = Number(timestamp);
        const delta = Math.abs(Date.now() / 1e3 - tsNum);
        if (!Number.isFinite(tsNum) || delta > 300) {
          return reply.status(400).send({ error: "Signature timestamp too old" });
        }
      }
      const computed = (0, import_node_crypto2.createHmac)("sha256", secret).update(rawBody, "utf8").digest("hex");
      const valid = (() => {
        try {
          const a = Buffer.from(computed, "hex");
          const b = Buffer.from(receivedHash, "hex");
          if (a.length !== b.length) return false;
          return (0, import_node_crypto2.timingSafeEqual)(a, b);
        } catch {
          return false;
        }
      })();
      if (!valid) {
        return reply.status(400).send({ error: "Invalid signature" });
      }
      const payload = request.body;
      const result = await PolarCommands.webhook(payload);
      if (!result || result.success !== true) {
        return reply.status(400).send({
          error: result?.error || "Webhook processing failed"
        });
      }
      return reply.status(200).send({ success: true });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getFreePlan(request, reply) {
    try {
      const result = await PolarQueries.getFreePlan();
      return reply.status(200).send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({ error: "Internal server error" });
    }
  }
};

// src/features/polar/polar.schema.ts
var CreateCheckoutSchema = {
  body: {
    type: "object",
    required: ["productId"],
    properties: {
      productId: {
        type: "string",
        description: "ID do produto Polar"
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        url: { type: "string" },
        product_id: { type: "string" },
        customer_id: { type: "string", nullable: true }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var ListPolarSchema = {
  querystring: {
    type: "object",
    properties: {
      page: {
        type: "number",
        minimum: 1,
        default: 1
      },
      limit: {
        type: "number",
        minimum: 1,
        maximum: 100,
        default: 10
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: { type: "array" },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var PolarSchemas = {
  createCheckout: CreateCheckoutSchema,
  list: ListPolarSchema
};

// src/features/polar/polar.routes.ts
async function PolarRoutes(fastify2) {
  fastify2.get("/plans", {
    schema: PolarSchemas.list,
    handler: PolarController.list
  });
  fastify2.get("/plans/free", {
    handler: PolarController.getFreePlan
  });
  fastify2.post("/checkout", {
    schema: PolarSchemas.createCheckout,
    preHandler: [Middlewares.auth, Middlewares.store],
    handler: PolarController.checkout
  });
  fastify2.post("/webhook", {
    // Garante que fastify-raw-body anexe o rawBody neste endpoint
    config: { rawBody: true },
    handler: PolarController.webhook
  });
}

// src/features/product/commands/product.commands.ts
var ProductCommands = {
  async create(data) {
    const { categoryIds, supplierId, storeId, ...createData } = data;
    if (categoryIds && categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    const product = await db.product.create({
      data: {
        ...createData,
        unitOfMeasure: createData.unitOfMeasure,
        status: data.status ?? true,
        ...supplierId && { supplier: { connect: { id: supplierId } } },
        store: { connect: { id: storeId } }
      }
    });
    if (categoryIds && categoryIds.length > 0) {
      await db.productCategory.createMany({
        data: categoryIds.map((categoryId) => ({
          productId: product.id,
          categoryId
        }))
      });
    }
    return await db.product.findUnique({
      where: { id: product.id },
      include: {
        categories: {
          include: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const { categoryIds, supplierId, storeId, ...updateData } = data;
    if (categoryIds && categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id2) => !foundIds.includes(id2));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    let categoryUpdate = {};
    if (categoryIds !== void 0) {
      if (categoryIds.length === 0) {
        categoryUpdate = {
          categories: {
            deleteMany: {}
          }
        };
      } else {
        categoryUpdate = {
          categories: {
            deleteMany: {},
            create: categoryIds.map((categoryId) => ({
              category: { connect: { id: categoryId } }
            }))
          }
        };
      }
    }
    return await db.product.update({
      where: { id },
      data: {
        ...updateData,
        ...updateData.unitOfMeasure && {
          unitOfMeasure: updateData.unitOfMeasure
        },
        ...supplierId !== void 0 && supplierId ? { supplier: { connect: { id: supplierId } } } : supplierId === null ? { supplier: { disconnect: true } } : {},
        ...storeId && { store: { connect: { id: storeId } } },
        ...categoryUpdate
      },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  async delete(id) {
    const product = await db.product.findUnique({
      where: { id },
      include: {
        movements: {
          select: { id: true }
        }
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (product.movements.length > 0) {
      throw new Error(
        `Cannot delete product. It has ${product.movements.length} associated movements. Please delete the movements first or use force delete.`
      );
    }
    return await db.product.delete({
      where: { id }
    });
  },
  async forceDelete(id) {
    const product = await db.product.findUnique({
      where: { id }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    await db.movement.deleteMany({
      where: { productId: id }
    });
    return await db.product.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.product.update({
      where: { id },
      data: { status },
      include: {
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
                description: true,
                code: true,
                color: true,
                icon: true
              }
            }
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true,
            tradeName: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
  },
  // === FUNES ADICIONAIS DE PRODUTO ===
  async verifySku(productId, sku) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const existingProduct = await db.product.findFirst({
      where: {
        id: { not: productId },
        name: sku
        // Assumindo que SKU  o nome do produto
      }
    });
    return {
      available: !existingProduct,
      message: existingProduct ? "SKU already exists" : "SKU available"
    };
  },
  async updateStock(productId, quantity, type, note, userId) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    let newStock = 0;
    if (type === "INBOUND") {
      newStock = quantity;
    } else {
      newStock = -quantity;
    }
    const movement = await db.movement.create({
      data: {
        type,
        quantity,
        storeId: product.storeId,
        productId,
        note,
        userId,
        balanceAfter: newStock
      },
      include: {
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return {
      product: {
        id: product.id,
        name: product.name,
        currentStock: newStock
      },
      movement
    };
  },
  async createMovement(productId, data) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (data.supplierId) {
      const supplier = await db.supplier.findUnique({
        where: { id: data.supplierId }
      });
      if (!supplier) {
        throw new Error("Supplier not found");
      }
    }
    const movement = await db.movement.create({
      data: {
        type: data.type,
        quantity: data.quantity,
        storeId: product.storeId,
        productId,
        supplierId: data.supplierId,
        batch: data.batch,
        expiration: data.expiration ? new Date(data.expiration) : null,
        price: data.price,
        note: data.note,
        userId: data.userId,
        balanceAfter: data.quantity
        // Assumindo que  o estoque aps a movimentao
      },
      include: {
        product: {
          select: {
            id: true,
            name: true,
            unitOfMeasure: true
          }
        },
        supplier: {
          select: {
            id: true,
            corporateName: true,
            cnpj: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        store: {
          select: {
            id: true,
            name: true,
            cnpj: true
          }
        }
      }
    });
    return movement;
  },
  async getProductStock(productId) {
    const product = await db.product.findUnique({
      where: { id: productId },
      include: {
        movements: {
          orderBy: { createdAt: "desc" },
          take: 1
        }
      }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const movements = await db.movement.findMany({
      where: { productId },
      select: {
        type: true,
        quantity: true
      }
    });
    let currentStock = 0;
    for (const movement of movements) {
      if (movement.type === "INBOUND") {
        currentStock += movement.quantity;
      } else {
        currentStock -= movement.quantity;
      }
    }
    let status = "OK";
    if (currentStock <= 0) {
      status = "CRITICAL";
    } else if (currentStock <= product.stockMin) {
      status = "LOW";
    } else if (currentStock > product.stockMax) {
      status = "OVERSTOCK";
    }
    return {
      id: product.id,
      name: product.name,
      currentStock,
      stockMin: product.stockMin,
      stockMax: product.stockMax,
      alertPercentage: product.alertPercentage,
      status,
      lastMovement: product.movements[0] ? {
        type: product.movements[0].type,
        quantity: product.movements[0].quantity,
        date: product.movements[0].createdAt
      } : null
    };
  },
  // === MTODOS PARA GERENCIAR CATEGORIAS DO PRODUTO ===
  async addCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const existingCategories = await db.category.findMany({
      where: { id: { in: categoryIds } },
      select: { id: true }
    });
    if (existingCategories.length !== categoryIds.length) {
      const foundIds = existingCategories.map((c) => c.id);
      const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
      throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
    }
    const existingProductCategories = await db.productCategory.findMany({
      where: {
        productId,
        categoryId: { in: categoryIds }
      },
      select: { categoryId: true }
    });
    const existingCategoryIds = existingProductCategories.map((pc) => pc.categoryId);
    const newCategoryIds = categoryIds.filter((id) => !existingCategoryIds.includes(id));
    if (newCategoryIds.length === 0) {
      throw new Error("All provided categories are already associated with this product");
    }
    await db.productCategory.createMany({
      data: newCategoryIds.map((categoryId) => ({
        productId,
        categoryId
      }))
    });
    const updatedCategories = await db.productCategory.findMany({
      where: { productId },
      select: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            color: true,
            icon: true
          }
        }
      }
    });
    return {
      message: `${newCategoryIds.length} categories added successfully`,
      addedCount: newCategoryIds.length,
      categories: updatedCategories.map((pc) => pc.category)
    };
  },
  async removeCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    const result = await db.productCategory.deleteMany({
      where: {
        productId,
        categoryId: { in: categoryIds }
      }
    });
    return {
      message: `${result.count} categories removed successfully`,
      removedCount: result.count
    };
  },
  async setCategories(productId, categoryIds) {
    const product = await db.product.findUnique({
      where: { id: productId }
    });
    if (!product) {
      throw new Error("Product not found");
    }
    if (categoryIds.length > 0) {
      const existingCategories = await db.category.findMany({
        where: { id: { in: categoryIds } },
        select: { id: true }
      });
      if (existingCategories.length !== categoryIds.length) {
        const foundIds = existingCategories.map((c) => c.id);
        const notFoundIds = categoryIds.filter((id) => !foundIds.includes(id));
        throw new Error(`Categories not found: ${notFoundIds.join(", ")}`);
      }
    }
    await db.productCategory.deleteMany({
      where: { productId }
    });
    if (categoryIds.length > 0) {
      await db.productCategory.createMany({
        data: categoryIds.map((categoryId) => ({
          productId,
          categoryId
        }))
      });
    }
    const updatedCategories = await db.productCategory.findMany({
      where: { productId },
      select: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            code: true,
            color: true,
            icon: true
          }
        }
      }
    });
    return {
      message: "Categories updated successfully",
      categories: updatedCategories.map((pc) => pc.category)
    };
  },
  async bulkDelete(ids) {
    if (!ids || ids.length === 0) {
      throw new Error("No product IDs provided");
    }
    const errors = [];
    let deletedCount = 0;
    for (const id of ids) {
      try {
        const product = await db.product.findUnique({
          where: { id },
          include: {
            movements: {
              select: { id: true }
            }
          }
        });
        if (!product) {
          errors.push(`Product ${id} not found`);
          continue;
        }
        if (product.movements.length > 0) {
          await db.movement.deleteMany({
            where: { productId: id }
          });
        }
        await db.product.delete({
          where: { id }
        });
        deletedCount++;
      } catch (error) {
        errors.push(`Failed to delete product ${id}: ${error.message}`);
      }
    }
    return {
      deleted: deletedCount,
      errors
    };
  }
};

// src/features/product/product.controller.ts
var ProductController = {
  async create(request, reply) {
    try {
      const {
        name,
        description,
        unitOfMeasure,
        referencePrice,
        categoryIds,
        supplierId,
        storeId,
        stockMin,
        stockMax,
        alertPercentage,
        status
      } = request.body;
      let finalStoreId = storeId;
      if (!finalStoreId) {
        if (!request.user?.id) {
          return reply.status(401).send({
            error: "Authentication required to determine store"
          });
        }
        finalStoreId = request.store?.id;
      }
      const result = await ProductCommands.create({
        name,
        description,
        unitOfMeasure,
        referencePrice,
        categoryIds,
        supplierId,
        storeId: finalStoreId,
        stockMin,
        stockMax,
        alertPercentage,
        status
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Categories not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "User has no associated store") {
        return reply.status(400).send({
          error: "User has no associated store. Please provide a storeId or ensure user has access to a store."
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid supplier or store reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getById(id, storeId);
      if (!result) {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await ProductCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      if (error.code === "P2002") {
        return reply.status(400).send({
          error: "Product with this name already exists"
        });
      }
      if (error.message.includes("Categories not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Invalid supplier or store reference"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await ProductCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Cannot delete product") && error.message.includes("associated movements")) {
        return reply.status(400).send({
          error: error.message,
          suggestion: "Use DELETE /products/:id/force to delete the product and all its movements"
        });
      }
      if (error.code === "P2003") {
        return reply.status(400).send({
          error: "Cannot delete product due to foreign key constraints"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forceDelete(request, reply) {
    try {
      const { id } = request.params;
      await ProductCommands.forceDelete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, categoryIds, supplierId } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.list({
        page,
        limit,
        search,
        status,
        categoryIds: categoryIds ? Array.isArray(categoryIds) ? categoryIds : [categoryIds] : void 0,
        supplierId,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getActive(storeId);
      return reply.send({ products: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await ProductQueries.getStats(storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10, page = 1 } = request.query;
      const storeId = request.store?.id;
      const result = await ProductQueries.search(q, {
        page,
        limit,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await ProductCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.code === "P2025") {
        return reply.status(404).send({
          error: "Product not found"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async verifySku(request, reply) {
    try {
      const { id: productId } = request.params;
      const { sku } = request.body;
      const result = await ProductCommands.verifySku(productId, sku);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Product not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkDelete(request, reply) {
    try {
      const { ids } = request.body;
      if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return reply.status(400).send({
          error: "Product IDs are required and must be a non-empty array"
        });
      }
      const result = await ProductCommands.bulkDelete(ids);
      return reply.send({
        deleted: result.deleted,
        errors: result.errors,
        message: `Successfully deleted ${result.deleted} products${result.errors.length > 0 ? ` with ${result.errors.length} errors` : ""}`
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: error.message || "Internal server error"
      });
    }
  }
};

// src/features/product/product.schema.ts
var createProductSchema = {
  body: {
    type: "object",
    required: [
      "name",
      "unitOfMeasure",
      "referencePrice",
      "stockMin",
      "stockMax",
      "alertPercentage"
    ],
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      unitOfMeasure: {
        type: "string",
        enum: [
          "UNIDADE",
          "KG",
          "L",
          "ML",
          "M",
          "CM",
          "MM",
          "UN",
          "DZ",
          "CX",
          "PCT",
          "KIT",
          "PAR",
          "H",
          "D"
        ]
      },
      referencePrice: { type: "number", minimum: 0.01 },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      },
      supplierId: { type: ["string", "null"], minLength: 1 },
      storeId: { type: "string", minLength: 1 },
      stockMin: { type: "number", minimum: 0 },
      stockMax: { type: "number", minimum: 0 },
      alertPercentage: { type: "number", minimum: 0, maximum: 100 },
      status: { type: "boolean", default: true }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var updateProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      unitOfMeasure: {
        type: "string",
        enum: [
          "UNIDADE",
          "KG",
          "L",
          "ML",
          "M",
          "CM",
          "MM",
          "UN",
          "DZ",
          "CX",
          "PCT",
          "KIT",
          "PAR",
          "H",
          "D"
        ]
      },
      referencePrice: { type: "number", minimum: 0.01 },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      },
      supplierId: { type: ["string", "null"], minLength: 1 },
      storeId: { type: "string", minLength: 1 },
      stockMin: { type: "number", minimum: 0 },
      stockMax: { type: "number", minimum: 0 },
      alertPercentage: { type: "number", minimum: 0, maximum: 100 },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var getProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        unitOfMeasure: { type: "string" },
        referencePrice: { type: "number" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        },
        supplierId: { type: "string" },
        storeId: { type: "string" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        category: { type: "object" },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var listProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" },
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        uniqueItems: true
      },
      supplierId: { type: "string" },
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              unitOfMeasure: { type: "string" },
              referencePrice: { type: "number" },
              categories: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    description: { type: "string", nullable: true },
                    code: { type: "string", nullable: true },
                    color: { type: "string", nullable: true },
                    icon: { type: "string", nullable: true }
                  }
                }
              },
              supplierId: { type: "string" },
              storeId: { type: "string" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              alertPercentage: { type: "number" },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              category: { type: "object" },
              supplier: { type: "object" },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteProductSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateStatusSchema2 = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        category: { type: "object" },
        supplier: { type: "object" },
        store: { type: "object" }
      }
    }
  }
};
var verifySkuSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["sku"],
    properties: {
      sku: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        available: { type: "boolean" },
        message: { type: "string" }
      }
    }
  }
};
var updateStockSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["quantity", "type"],
    properties: {
      quantity: { type: "number", minimum: 0.01 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      note: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            currentStock: { type: "number" }
          }
        },
        movement: {
          type: "object",
          properties: {
            id: { type: "string" },
            type: { type: "string" },
            quantity: { type: "number" },
            note: { type: "string", nullable: true },
            balanceAfter: { type: "number" },
            createdAt: { type: "string", format: "date-time" },
            supplier: { type: "object", nullable: true },
            user: { type: "object", nullable: true }
          }
        }
      }
    }
  }
};
var getProductMovementsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              balanceAfter: { type: "number", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              product: { type: "object" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var createProductMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["type", "quantity"],
    properties: {
      type: {
        type: "string",
        enum: ["ENTRADA", "SAIDA", "PERDA"]
      },
      quantity: { type: "number", minimum: 0.01 },
      supplierId: { type: "string" },
      batch: { type: "string" },
      expiration: { type: "string", format: "date" },
      price: { type: "number", minimum: 0 },
      note: { type: "string" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        type: { type: "string" },
        quantity: { type: "number" },
        batch: { type: "string", nullable: true },
        expiration: { type: "string", format: "date-time", nullable: true },
        price: { type: "number", nullable: true },
        note: { type: "string", nullable: true },
        balanceAfter: { type: "number" },
        createdAt: { type: "string", format: "date-time" },
        product: { type: "object" },
        supplier: { type: "object", nullable: true },
        user: { type: "object", nullable: true },
        store: { type: "object" }
      }
    }
  }
};
var getProductStockSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        currentStock: { type: "number" },
        stockMin: { type: "number" },
        stockMax: { type: "number" },
        alertPercentage: { type: "number" },
        status: {
          type: "string",
          enum: ["OK", "LOW", "CRITICAL", "OVERSTOCK"]
        },
        lastMovement: {
          type: "object",
          nullable: true,
          properties: {
            type: { type: "string" },
            quantity: { type: "number" },
            date: { type: "string", format: "date-time" }
          }
        }
      }
    }
  }
};
var getProductStockHistorySchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      limit: { type: "number", minimum: 1, maximum: 100, default: 30 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            stockMin: { type: "number" },
            stockMax: { type: "number" },
            alertPercentage: { type: "number" }
          }
        },
        currentStock: { type: "number" },
        history: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              batch: { type: "string", nullable: true },
              expiration: { type: "string", format: "date-time", nullable: true },
              price: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              balanceAfter: { type: "number" },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              user: { type: "object", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getLowStockProductsSchema = {
  querystring: {
    type: "object",
    properties: {
      storeId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        products: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              currentStock: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              stockStatus: {
                type: "string",
                enum: ["LOW", "CRITICAL"]
              },
              category: { type: "object", nullable: true },
              supplier: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        }
      }
    }
  }
};
var getProductAnalyticsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        product: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            stockMin: { type: "number" },
            stockMax: { type: "number" },
            alertPercentage: { type: "number" }
          }
        },
        currentStock: { type: "number" },
        statistics: {
          type: "object",
          properties: {
            totalMovements: { type: "number" },
            totalEntrada: { type: "number" },
            totalSaida: { type: "number" },
            totalPerda: { type: "number" },
            monthlyMovements: { type: "object" },
            supplierStats: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  supplier: { type: "object" },
                  totalMovements: { type: "number" },
                  totalQuantity: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var addProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        addedCount: { type: "number" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var removeProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        removedCount: { type: "number" }
      }
    }
  }
};
var setProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["categoryIds"],
    properties: {
      categoryIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        message: { type: "string" },
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getProductCategoriesSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        categories: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              code: { type: "string", nullable: true },
              color: { type: "string", nullable: true },
              icon: { type: "string", nullable: true }
            }
          }
        }
      }
    }
  }
};
var getProductsByCategorySchema = {
  params: {
    type: "object",
    required: ["categoryId"],
    properties: {
      categoryId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        products: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              unitOfMeasure: { type: "string" },
              referencePrice: { type: "number" },
              stockMin: { type: "number" },
              stockMax: { type: "number" },
              alertPercentage: { type: "number" },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              supplier: { type: "object", nullable: true },
              store: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var bulkDeleteProductsSchema = {
  body: {
    type: "object",
    required: ["ids"],
    properties: {
      ids: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        deleted: { type: "number" },
        errors: {
          type: "array",
          items: { type: "string" }
        }
      }
    }
  }
};
var ProductSchemas = {
  create: createProductSchema,
  update: updateProductSchema,
  get: getProductSchema,
  delete: deleteProductSchema,
  list: listProductsSchema,
  updateStatus: updateStatusSchema2,
  bulkDelete: bulkDeleteProductsSchema,
  // Funes adicionais
  verifySku: verifySkuSchema,
  updateStock: updateStockSchema,
  getMovements: getProductMovementsSchema,
  createMovement: createProductMovementSchema,
  getStock: getProductStockSchema,
  getStockHistory: getProductStockHistorySchema,
  getLowStock: getLowStockProductsSchema,
  getAnalytics: getProductAnalyticsSchema,
  // Gerenciar categorias
  addCategories: addProductCategoriesSchema,
  removeCategories: removeProductCategoriesSchema,
  setCategories: setProductCategoriesSchema,
  getCategories: getProductCategoriesSchema,
  getByCategory: getProductsByCategorySchema
};

// src/features/product/product.routes.ts
async function ProductRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: ProductSchemas.create,
    handler: ProductController.create
  });
  fastify2.get("/", {
    schema: ProductSchemas.list,
    handler: ProductController.list
  });
  fastify2.get("/:id", {
    schema: ProductSchemas.get,
    handler: ProductController.get
  });
  fastify2.put("/:id", {
    schema: ProductSchemas.update,
    handler: ProductController.update
  });
  fastify2.delete("/:id", {
    schema: ProductSchemas.delete,
    handler: ProductController.delete
  });
  fastify2.delete("/:id/force", {
    schema: ProductSchemas.delete,
    handler: ProductController.forceDelete
  });
  fastify2.get("/active", {
    handler: ProductController.getActive
  });
  fastify2.get("/stats", {
    handler: ProductController.getStats
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          q: { type: "string" },
          limit: { type: "number" }
        },
        required: ["q"]
      }
    },
    handler: ProductController.search
  });
  fastify2.post("/bulk-delete", {
    schema: ProductSchemas.bulkDelete,
    handler: ProductController.bulkDelete
  });
  fastify2.patch("/:id/status", {
    schema: ProductSchemas.updateStatus,
    handler: ProductController.updateStatus
  });
}

// src/features/profile/commands/profile.commands.ts
var ProfileCommands = {
  async update(userId, data) {
    const user = await db.user.update({
      where: { id: userId },
      data: {
        name: data.name,
        email: data.email,
        phone: data.phone
      }
    });
    return user;
  },
  async exclude(userId) {
    const user = await db.user.delete({
      where: { id: userId }
    });
    return user;
  }
};

// src/features/profile/queires/profile.queries.ts
var ProfileQueries = {
  async single(userId) {
    const user = await db.user.findUnique({
      where: { id: userId, status: true },
      select: {
        id: true,
        name: true,
        email: true,
        phone: true
      }
    });
    return user;
  },
  async subscription(userId) {
    const subscription2 = await db.subscription.findFirst({
      where: {
        userId
      },
      select: {
        id: true,
        polarProductId: true,
        polarPlanName: true,
        status: true,
        currentPeriodEnd: true,
        trialEndsAt: true,
        cancelledAt: true,
        renewalCount: true,
        priceAmount: true,
        priceInterval: true,
        currency: true
      }
    });
    console.log(subscription2);
    return subscription2 || null;
  },
  async preferences(userId) {
    const userPreferences = await db.userPreferences.findUnique({
      where: { userId }
    });
    return userPreferences || null;
  }
};

// src/features/profile/profile.controller.ts
var ProfileController = {
  async single(request, reply) {
    try {
      const userId = request.user?.id;
      const user = await ProfileQueries.single(userId);
      return reply.status(200).send({ user });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({ error: "Internal server error" });
    }
  },
  async update(request, reply) {
    try {
      const userId = request.user?.id;
      const user = await ProfileCommands.update(userId, request.body);
      return reply.status(200).send({ user, message: "Profile updated successfully" });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({ error: "Internal server error" });
    }
  },
  async exclude(request, reply) {
    try {
      const userId = request.user?.id;
      const user = await ProfileCommands.exclude(userId);
      return reply.status(200).send({ user, message: "Profile excluded successfully" });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({ error: "Internal server error" });
    }
  },
  async subscription(request, reply) {
    try {
      const userId = request.user?.id;
      const subscription2 = await ProfileQueries.subscription(userId);
      return reply.status(200).send(subscription2);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({ error: "Internal server error" });
    }
  }
};

// src/features/profile/profile.schema.ts
var update = {
  body: {
    type: "object",
    required: ["name", "email"],
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string" }
          },
          additionalProperties: false
        },
        message: { type: "string" }
      },
      additionalProperties: false
    }
  }
};
var single = {
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string" }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    }
  }
};
var exclude = {
  response: {
    200: {
      type: "object",
      properties: {
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            phone: { type: "string" }
          },
          additionalProperties: false
        },
        message: { type: "string" }
      },
      additionalProperties: false
    }
  }
};
var subscription = {
  response: {
    200: {
      type: "object",
      properties: {
        subscription: {
          type: ["object", "null"],
          properties: {
            id: { type: "string" },
            polarProductId: { type: "string" },
            polarPlanName: { type: "string" },
            status: { type: "string" },
            currentPeriodEnd: { type: ["string", "null"] },
            trialEndsAt: { type: ["string", "null"] },
            cancelledAt: { type: ["string", "null"] },
            renewalCount: { type: "number" },
            priceAmount: { type: "number" },
            priceInterval: { type: "string" },
            currency: { type: "string" }
          }
        }
      }
    }
  }
};
var ProfileSchemas = {
  update,
  single,
  exclude,
  subscription
};

// src/features/profile/profile.routes.ts
async function ProfileRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.get("/", {
    schema: ProfileSchemas.single,
    handler: ProfileController.single
  });
  fastify2.put("/", {
    schema: ProfileSchemas.update,
    handler: ProfileController.update
  });
  fastify2.delete("/", {
    schema: ProfileSchemas.exclude,
    handler: ProfileController.exclude
  });
  fastify2.get("/subscription", {
    handler: ProfileController.subscription
  });
}

// src/features/push-subscription/commands/push-subscription.commands.ts
var PushSubscriptionCommands = class {
  constructor(prisma2) {
    this.prisma = prisma2;
  }
  async create(data, userId) {
    const existing = await this.prisma.pushSubscription.findFirst({
      where: {
        userId,
        endpoint: data.endpoint
      }
    });
    if (existing) {
      return await this.prisma.pushSubscription.update({
        where: { id: existing.id },
        data: {
          endpoint: data.endpoint,
          p256dh: data.keys.p256dh,
          auth: data.keys.auth,
          userAgent: data.userAgent,
          deviceInfo: data.deviceInfo,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    return await this.prisma.pushSubscription.create({
      data: {
        userId,
        endpoint: data.endpoint,
        p256dh: data.keys.p256dh,
        auth: data.keys.auth,
        userAgent: data.userAgent,
        deviceInfo: data.deviceInfo
      }
    });
  }
  async delete(id, userId) {
    const subscription2 = await this.prisma.pushSubscription.findFirst({
      where: {
        id,
        userId
      }
    });
    if (!subscription2) {
      throw new Error("Push subscription not found");
    }
    return await this.prisma.pushSubscription.delete({
      where: { id }
    });
  }
  async deleteByEndpoint(endpoint, userId) {
    return await this.prisma.pushSubscription.deleteMany({
      where: {
        endpoint,
        userId
      }
    });
  }
  async deleteByUser(userId) {
    return await this.prisma.pushSubscription.deleteMany({
      where: {
        userId
      }
    });
  }
};

// src/features/push-subscription/queries/push-subscription.queries.ts
var PushSubscriptionQueries = class {
  constructor(prisma2) {
    this.prisma = prisma2;
  }
  async getById(id, userId) {
    const subscription2 = await this.prisma.pushSubscription.findFirst({
      where: {
        id,
        userId
      }
    });
    if (!subscription2) {
      throw new Error("Push subscription not found");
    }
    return subscription2;
  }
  async listByUser(userId) {
    return await this.prisma.pushSubscription.findMany({
      where: {
        userId
      },
      orderBy: {
        createdAt: "desc"
      }
    });
  }
  async list(page = 1, limit = 10) {
    const skip2 = (page - 1) * limit;
    const [items, total] = await Promise.all([
      this.prisma.pushSubscription.findMany({
        skip: skip2,
        take: limit,
        orderBy: {
          createdAt: "desc"
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      this.prisma.pushSubscription.count()
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  }
};

// src/features/push-subscription/push-subscription.controller.ts
var PushSubscriptionController = {
  async create(request, reply) {
    try {
      const { endpoint, keys, userAgent, deviceInfo } = request.body;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const prisma2 = request.server.prisma;
      const commands = new PushSubscriptionCommands(prisma2);
      const result = await commands.create(
        {
          endpoint,
          keys,
          userAgent,
          deviceInfo
        },
        userId
      );
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Push subscription not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const prisma2 = request.server.prisma;
      const commands = new PushSubscriptionCommands(prisma2);
      await commands.delete(id, userId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Push subscription not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async listByUser(request, reply) {
    try {
      const { userId } = request.params;
      const currentUserId = request.user?.id;
      if (!currentUserId || currentUserId !== userId) {
        return reply.status(403).send({
          error: "Forbidden"
        });
      }
      const prisma2 = request.server.prisma;
      const queries = new PushSubscriptionQueries(prisma2);
      const result = await queries.listByUser(userId);
      return reply.send({ subscriptions: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10 } = request.query;
      const prisma2 = request.server.prisma;
      const queries = new PushSubscriptionQueries(prisma2);
      const result = await queries.list(page, limit);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getVapidKey(request, reply) {
    try {
      const fastify2 = request.server;
      const publicKey = fastify2.getVapidPublicKey();
      return reply.send({
        publicKey
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/push-subscription/push-subscription.schema.ts
var createPushSubscriptionSchema = {
  body: {
    type: "object",
    required: ["endpoint", "keys"],
    properties: {
      endpoint: { type: "string" },
      keys: {
        type: "object",
        required: ["p256dh", "auth"],
        properties: {
          p256dh: { type: "string" },
          auth: { type: "string" }
        }
      },
      userAgent: { type: "string" },
      deviceInfo: {}
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        endpoint: { type: "string" },
        createdAt: { type: "string" },
        updatedAt: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var deletePushSubscriptionSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listPushSubscriptionsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1 },
      limit: { type: "number", minimum: 1, maximum: 100 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: { type: "array" },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getVapidKeySchema = {
  response: {
    200: {
      type: "object",
      properties: {
        publicKey: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var PushSubscriptionSchemas = {
  create: createPushSubscriptionSchema,
  delete: deletePushSubscriptionSchema,
  list: listPushSubscriptionsSchema,
  getVapidKey: getVapidKeySchema
};

// src/features/push-subscription/push-subscription.routes.ts
async function PushSubscriptionRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: PushSubscriptionSchemas.create,
    handler: PushSubscriptionController.create
  });
  fastify2.delete("/:id", {
    schema: PushSubscriptionSchemas.delete,
    handler: PushSubscriptionController.delete
  });
  fastify2.get("/user/:userId", {
    handler: PushSubscriptionController.listByUser
  });
  fastify2.get("/vapid-key", {
    schema: PushSubscriptionSchemas.getVapidKey,
    handler: PushSubscriptionController.getVapidKey
  });
}

// src/features/quote/commands/quote.commands.ts
var import_library = require("@prisma/client/runtime/library");
var QuoteCommands = {
  async create(data) {
    const { items, installments, ...quoteData } = data;
    const productIds = items.map((item) => item.productId);
    const existingProducts = await db.product.findMany({
      where: { id: { in: productIds } },
      select: { id: true, name: true }
    });
    if (existingProducts.length !== productIds.length) {
      const foundIds = existingProducts.map((p) => p.id);
      const notFoundIds = productIds.filter((id) => !foundIds.includes(id));
      throw new Error(`Products not found: ${notFoundIds.join(", ")}`);
    }
    let subtotal = new import_library.Decimal(0);
    const itemsWithSubtotal = items.map((item) => {
      const itemSubtotal = new import_library.Decimal(item.quantity * item.unitPrice).minus(item.discount || 0);
      subtotal = subtotal.plus(itemSubtotal);
      return {
        ...item,
        subtotal: itemSubtotal.toNumber()
      };
    });
    const total = subtotal.minus(quoteData.discount || 0).plus(quoteData.interest || 0);
    const { userId, ...restQuoteData } = quoteData;
    const user = await db.user.findUnique({
      where: { id: userId },
      select: { storeId: true }
    });
    if (!user || !user.storeId) {
      throw new Error("User must be associated with a store");
    }
    const quote = await db.quote.create({
      data: {
        ...restQuoteData,
        user: { connect: { id: userId } },
        store: { connect: { id: user.storeId } },
        subtotal: new import_library.Decimal(subtotal),
        total: new import_library.Decimal(total),
        expiresAt: quoteData.expiresAt ? new Date(quoteData.expiresAt) : null,
        discount: quoteData.discount ? new import_library.Decimal(quoteData.discount) : null,
        interest: quoteData.interest ? new import_library.Decimal(quoteData.interest) : null,
        items: {
          create: itemsWithSubtotal.map((item) => ({
            productId: item.productId,
            quantity: item.quantity,
            unitPrice: item.unitPrice,
            subtotal: new import_library.Decimal(item.subtotal),
            discount: item.discount ? new import_library.Decimal(item.discount) : null,
            note: item.note
          }))
        },
        ...installments && installments.length > 0 && {
          installments: {
            create: installments.map((installment) => ({
              number: installment.number,
              dueDate: new Date(installment.dueDate),
              amount: new import_library.Decimal(installment.amount),
              interest: installment.interest ? new import_library.Decimal(installment.interest) : null
            }))
          }
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async update(id, data) {
    const existingQuote = await db.quote.findUnique({
      where: { id },
      include: { items: true, installments: true }
    });
    if (!existingQuote) {
      throw new Error("Quote not found");
    }
    if (existingQuote.status !== "DRAFT") {
      throw new Error("Only DRAFT quotes can be updated");
    }
    const { items, installments, ...updateData } = data;
    let subtotal = existingQuote.subtotal;
    let total = existingQuote.total;
    if (items) {
      const productIds = items.map((item) => item.productId);
      const existingProducts = await db.product.findMany({
        where: { id: { in: productIds } },
        select: { id: true }
      });
      if (existingProducts.length !== productIds.length) {
        const foundIds = existingProducts.map((p) => p.id);
        const notFoundIds = productIds.filter((id2) => !foundIds.includes(id2));
        throw new Error(`Products not found: ${notFoundIds.join(", ")}`);
      }
      subtotal = new import_library.Decimal(0);
      const discount = updateData.discount || existingQuote.discount || 0;
      const interest = updateData.interest || existingQuote.interest || 0;
      total = subtotal.minus(discount).plus(interest);
    }
    const quote = await db.quote.update({
      where: { id },
      data: {
        ...updateData,
        subtotal: new import_library.Decimal(subtotal),
        total: new import_library.Decimal(total),
        expiresAt: updateData.expiresAt ? new Date(updateData.expiresAt) : void 0,
        ...items && {
          items: {
            deleteMany: {},
            create: items.map((item) => ({
              productId: item.productId,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              subtotal: new import_library.Decimal(item.quantity * item.unitPrice - (item.discount || 0)),
              discount: item.discount,
              note: item.note
            }))
          }
        },
        ...installments && {
          installments: {
            deleteMany: {},
            create: installments.map((installment) => ({
              number: installment.number,
              dueDate: new Date(installment.dueDate),
              amount: new import_library.Decimal(installment.amount),
              interest: installment.interest ? new import_library.Decimal(installment.interest) : null
            }))
          }
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async delete(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "DRAFT" && quote.status !== "CANCELED") {
      throw new Error("Only DRAFT or CANCELED quotes can be deleted");
    }
    return await db.quote.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    return await db.quote.update({
      where: { id },
      data: { status },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async approve(publicId, authCode) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode,
        status: { in: ["PUBLISHED", "SENT", "VIEWED"] }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                storeId: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found or not available for approval");
    }
    if (quote.expiresAt && /* @__PURE__ */ new Date() > quote.expiresAt) {
      throw new Error("Quote has expired");
    }
    const movements = await this.convertToMovements(quote.id);
    await db.quote.update({
      where: { id: quote.id },
      data: { status: "APPROVED" }
    });
    return {
      quote: {
        ...quote,
        status: "APPROVED"
      },
      movements
    };
  },
  async reject(publicId, authCode, reason) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode,
        status: { in: ["PUBLISHED", "SENT", "VIEWED"] }
      }
    });
    if (!quote) {
      throw new Error("Quote not found or not available for rejection");
    }
    const updatedQuote = await db.quote.update({
      where: { id: quote.id },
      data: {
        status: "REJECTED",
        observations: reason ? `${quote.observations || ""}
Rejection reason: ${reason}`.trim() : quote.observations
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return updatedQuote;
  },
  async convertToMovements(quoteId) {
    const quote = await db.quote.findUnique({
      where: { id: quoteId },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                storeId: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (!["PUBLISHED", "SENT", "VIEWED", "APPROVED"].includes(quote.status)) {
      throw new Error("Quote cannot be converted to movements");
    }
    const movements = [];
    for (const item of quote.items) {
      try {
        const movement = await MovementCommands.create({
          type: "OUTBOUND",
          quantity: item.quantity,
          storeId: item.product.storeId,
          productId: item.productId,
          note: `Quote conversion - ${quote.title} (Item: ${item.product.name})`,
          userId: quote.userId
        });
        movements.push(movement);
      } catch (error) {
        console.error(`Error creating movement for item ${item.id}:`, error);
        throw new Error(`Failed to create movement for product ${item.product.name}`);
      }
    }
    await db.quote.update({
      where: { id: quoteId },
      data: { status: "CONVERTED" }
    });
    return movements;
  },
  async publish(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "DRAFT") {
      throw new Error("Only DRAFT quotes can be published");
    }
    return await db.quote.update({
      where: { id },
      data: { status: "PUBLISHED" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async send(id) {
    const quote = await db.quote.findUnique({
      where: { id }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    if (quote.status !== "PUBLISHED") {
      throw new Error("Only PUBLISHED quotes can be sent");
    }
    return await db.quote.update({
      where: { id },
      data: { status: "SENT" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
};

// src/features/quote/queries/quote.queries.ts
var QuoteQueries = {
  async getById(id) {
    const quote = await db.quote.findUnique({
      where: { id },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quote;
  },
  async getByPublicId(publicId, authCode) {
    const quote = await db.quote.findFirst({
      where: {
        publicId,
        authCode
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            name: true
          }
        }
      }
    });
    return quote;
  },
  async list(params) {
    const { page = 1, limit = 10, search, status, userId, startDate, endDate } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status) {
      where.status = status;
    }
    if (userId) {
      where.userId = userId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate);
      }
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByUser(userId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip2 = (page - 1) * limit;
    const where = { userId };
    if (status) {
      where.status = status;
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByStatus(status, params) {
    const { page = 1, limit = 10, userId } = params;
    const skip2 = (page - 1) * limit;
    const where = { status };
    if (userId) {
      where.userId = userId;
    }
    const [quotes, total] = await Promise.all([
      db.quote.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          items: {
            include: {
              product: {
                select: {
                  id: true,
                  name: true,
                  description: true,
                  unitOfMeasure: true,
                  referencePrice: true
                }
              }
            }
          },
          installments: true,
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.quote.count({ where })
    ]);
    return {
      items: quotes,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStats(userId) {
    const where = userId ? { userId } : {};
    const [
      total,
      draft,
      published,
      sent,
      viewed,
      approved,
      rejected,
      expired,
      converted,
      canceled,
      totalValue,
      averageValue,
      recentCount
    ] = await Promise.all([
      db.quote.count({ where }),
      db.quote.count({ where: { ...where, status: "DRAFT" } }),
      db.quote.count({ where: { ...where, status: "PUBLISHED" } }),
      db.quote.count({ where: { ...where, status: "SENT" } }),
      db.quote.count({ where: { ...where, status: "VIEWED" } }),
      db.quote.count({ where: { ...where, status: "APPROVED" } }),
      db.quote.count({ where: { ...where, status: "REJECTED" } }),
      db.quote.count({ where: { ...where, status: "EXPIRED" } }),
      db.quote.count({ where: { ...where, status: "CONVERTED" } }),
      db.quote.count({ where: { ...where, status: "CANCELED" } }),
      db.quote.aggregate({
        where,
        _sum: { total: true }
      }),
      db.quote.aggregate({
        where,
        _avg: { total: true }
      }),
      db.quote.count({
        where: {
          ...where,
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
            // ltimos 30 dias
          }
        }
      })
    ]);
    return {
      total,
      byStatus: {
        DRAFT: draft,
        PUBLISHED: published,
        SENT: sent,
        VIEWED: viewed,
        APPROVED: approved,
        REJECTED: rejected,
        EXPIRED: expired,
        CONVERTED: converted,
        CANCELED: canceled
      },
      totalValue: totalValue._sum.total || 0,
      averageValue: averageValue._avg.total || 0,
      recentCount
    };
  },
  async search(term, limit = 10, userId) {
    const where = {
      OR: [
        { title: { contains: term, mode: "insensitive" } },
        { description: { contains: term, mode: "insensitive" } },
        { observations: { contains: term, mode: "insensitive" } }
      ]
    };
    if (userId) {
      where.userId = userId;
    }
    const quotes = await db.quote.findMany({
      where,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                description: true,
                unitOfMeasure: true,
                referencePrice: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async getExpiredQuotes() {
    const now = /* @__PURE__ */ new Date();
    const quotes = await db.quote.findMany({
      where: {
        expiresAt: {
          lt: now
        },
        status: {
          in: ["PUBLISHED", "SENT", "VIEWED"]
        }
      },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async markAsExpired() {
    const now = /* @__PURE__ */ new Date();
    const result = await db.quote.updateMany({
      where: {
        expiresAt: {
          lt: now
        },
        status: {
          in: ["PUBLISHED", "SENT", "VIEWED"]
        }
      },
      data: {
        status: "EXPIRED"
      }
    });
    return result.count;
  },
  async getRecentQuotes(limit = 5, userId) {
    const where = userId ? { userId } : {};
    const quotes = await db.quote.findMany({
      where,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return quotes;
  },
  async getQuoteAnalytics(quoteId) {
    const quote = await db.quote.findUnique({
      where: { id: quoteId },
      include: {
        items: {
          include: {
            product: {
              select: {
                id: true,
                name: true,
                unitOfMeasure: true
              }
            }
          }
        },
        installments: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!quote) {
      throw new Error("Quote not found");
    }
    const totalItems = quote.items.length;
    const totalQuantity = quote.items.reduce((sum, item) => sum + item.quantity, 0);
    const totalInstallments = quote.installments.length;
    const averageItemValue = quote.items.length > 0 ? quote.total / quote.items.length : 0;
    const isExpired = quote.expiresAt ? /* @__PURE__ */ new Date() > quote.expiresAt : false;
    const daysUntilExpiry = quote.expiresAt ? Math.ceil((quote.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime()) / (1e3 * 60 * 60 * 24)) : null;
    return {
      quote,
      analytics: {
        totalItems,
        totalQuantity,
        totalInstallments,
        averageItemValue,
        isExpired,
        daysUntilExpiry,
        status: quote.status,
        createdAt: quote.createdAt,
        updatedAt: quote.updatedAt
      }
    };
  }
};

// src/features/quote/quote.controller.ts
var QuoteController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const {
        title,
        description,
        paymentType,
        paymentTerms,
        paymentDueDays,
        expiresAt,
        observations,
        discount,
        interest,
        items,
        installments
      } = request.body;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Authentication required"
        });
      }
      const result = await QuoteCommands.create({
        userId,
        title,
        description,
        paymentType,
        paymentTerms,
        paymentDueDays,
        expiresAt,
        observations,
        discount,
        interest,
        items,
        installments
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("Products not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Quote not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await QuoteCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT quotes can be updated") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Products not found")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await QuoteCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT or CANCELED quotes can be deleted") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status, userId, startDate, endDate } = request.query;
      const result = await QuoteQueries.list({
        page,
        limit,
        search,
        status,
        userId,
        startDate,
        endDate
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES PBLICAS (sem autenticao) ===
  async getPublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode } = request.query;
      const result = await QuoteQueries.getByPublicId(publicId, authCode);
      if (!result) {
        return reply.status(404).send({
          error: "Quote not found or invalid authorization code"
        });
      }
      if (result.expiresAt && /* @__PURE__ */ new Date() > result.expiresAt) {
        return reply.status(410).send({
          error: "Quote has expired"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async approvePublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode } = request.body;
      const result = await QuoteCommands.approve(publicId, authCode);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found or not available for approval") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Quote has expired") {
        return reply.status(410).send({
          error: error.message
        });
      }
      if (error.message.includes("Failed to create movement")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async rejectPublic(request, reply) {
    try {
      const { publicId } = request.params;
      const { authCode, reason } = request.body;
      const result = await QuoteCommands.reject(publicId, authCode, reason);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found or not available for rejection") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (autenticadas) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await QuoteCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async publish(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteCommands.publish(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only DRAFT quotes can be published") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async send(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteCommands.send(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Only PUBLISHED quotes can be sent") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async convertToMovements(request, reply) {
    try {
      const { id } = request.params;
      const movements = await QuoteCommands.convertToMovements(id);
      return reply.send({
        message: "Quote converted to movements successfully",
        movements
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Quote cannot be converted to movements") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message.includes("Failed to create movement")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { userId } = request.query;
      const result = await QuoteQueries.getStats(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByUser(request, reply) {
    try {
      const { userId } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await QuoteQueries.getByUser(userId, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10, userId } = request.query;
      const result = await QuoteQueries.search(q, limit, userId);
      return reply.send({ quotes: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByStatus(request, reply) {
    try {
      const { status } = request.params;
      const { page = 1, limit = 10, userId } = request.query;
      const result = await QuoteQueries.getByStatus(status, {
        page,
        limit,
        userId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { limit = 5, userId } = request.query;
      const result = await QuoteQueries.getRecentQuotes(limit, userId);
      return reply.send({ quotes: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getAnalytics(request, reply) {
    try {
      const { id } = request.params;
      const result = await QuoteQueries.getQuoteAnalytics(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Quote not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async markExpired(request, reply) {
    try {
      const count = await QuoteQueries.markAsExpired();
      return reply.send({
        message: `${count} quotes marked as expired`,
        expiredCount: count
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/quote/quote.schema.ts
var createQuoteSchema = {
  body: {
    type: "object",
    required: ["title", "paymentType", "items"],
    properties: {
      title: { type: "string", minLength: 1 },
      description: { type: "string" },
      paymentType: {
        type: "string",
        enum: ["UNDEFINED", "PIX", "BOLETO", "CREDIT_CARD", "CASH", "TRANSFER"]
      },
      paymentTerms: { type: "string" },
      paymentDueDays: { type: "number", minimum: 1 },
      expiresAt: { type: "string", format: "date-time" },
      observations: { type: "string" },
      discount: { type: "number", minimum: 0 },
      interest: { type: "number", minimum: 0 },
      items: {
        type: "array",
        minItems: 1,
        items: {
          type: "object",
          required: ["productId", "quantity", "unitPrice"],
          properties: {
            productId: { type: "string", minLength: 1 },
            quantity: { type: "number", minimum: 0.01 },
            unitPrice: { type: "number", minimum: 0.01 },
            discount: { type: "number", minimum: 0 },
            note: { type: "string" }
          }
        }
      },
      installments: {
        type: "array",
        items: {
          type: "object",
          required: ["number", "dueDate", "amount"],
          properties: {
            number: { type: "number", minimum: 1 },
            dueDate: { type: "string", format: "date-time" },
            amount: { type: "number", minimum: 0.01 },
            interest: { type: "number", minimum: 0 }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var updateQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1 },
      description: { type: "string" },
      paymentType: {
        type: "string",
        enum: ["UNDEFINED", "PIX", "BOLETO", "CREDIT_CARD", "CASH", "TRANSFER"]
      },
      paymentTerms: { type: "string" },
      paymentDueDays: { type: "number", minimum: 1 },
      expiresAt: { type: "string", format: "date-time" },
      observations: { type: "string" },
      discount: { type: "number", minimum: 0 },
      interest: { type: "number", minimum: 0 },
      items: {
        type: "array",
        minItems: 1,
        items: {
          type: "object",
          required: ["productId", "quantity", "unitPrice"],
          properties: {
            id: { type: "string" },
            productId: { type: "string", minLength: 1 },
            quantity: { type: "number", minimum: 0.01 },
            unitPrice: { type: "number", minimum: 0.01 },
            discount: { type: "number", minimum: 0 },
            note: { type: "string" }
          }
        }
      },
      installments: {
        type: "array",
        items: {
          type: "object",
          required: ["number", "dueDate", "amount"],
          properties: {
            id: { type: "string" },
            number: { type: "number", minimum: 1 },
            dueDate: { type: "string", format: "date-time" },
            amount: { type: "number", minimum: 0.01 },
            interest: { type: "number", minimum: 0 }
          }
        }
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var getQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        publicId: { type: "string" },
        authCode: { type: "string" },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              productId: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var getPublicQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        title: { type: "string" },
        description: { type: "string", nullable: true },
        status: { type: "string" },
        total: { type: "number" },
        subtotal: { type: "number" },
        discount: { type: "number", nullable: true },
        interest: { type: "number", nullable: true },
        paymentType: { type: "string" },
        paymentTerms: { type: "string", nullable: true },
        paymentDueDays: { type: "number", nullable: true },
        expiresAt: { type: "string", format: "date-time", nullable: true },
        observations: { type: "string", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              quantity: { type: "number" },
              unitPrice: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              note: { type: "string", nullable: true },
              product: { type: "object" }
            }
          }
        },
        installments: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              number: { type: "number" },
              dueDate: { type: "string", format: "date-time" },
              amount: { type: "number" },
              interest: { type: "number", nullable: true }
            }
          }
        },
        user: { type: "object" }
      }
    }
  }
};
var listQuotesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: {
        type: "string",
        enum: [
          "DRAFT",
          "PUBLISHED",
          "SENT",
          "VIEWED",
          "APPROVED",
          "REJECTED",
          "EXPIRED",
          "CONVERTED",
          "CANCELED"
        ]
      },
      userId: { type: "string" },
      startDate: { type: "string", format: "date" },
      endDate: { type: "string", format: "date" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              title: { type: "string" },
              description: { type: "string", nullable: true },
              publicId: { type: "string" },
              authCode: { type: "string" },
              status: { type: "string" },
              total: { type: "number" },
              subtotal: { type: "number" },
              discount: { type: "number", nullable: true },
              interest: { type: "number", nullable: true },
              paymentType: { type: "string" },
              paymentTerms: { type: "string", nullable: true },
              paymentDueDays: { type: "number", nullable: true },
              expiresAt: { type: "string", format: "date-time", nullable: true },
              observations: { type: "string", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              items: { type: "array" },
              installments: { type: "array" },
              user: { type: "object" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteQuoteSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateQuoteStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: [
          "DRAFT",
          "PUBLISHED",
          "SENT",
          "VIEWED",
          "APPROVED",
          "REJECTED",
          "EXPIRED",
          "CONVERTED",
          "CANCELED"
        ]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var approveQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        quote: { type: "object" },
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              productId: { type: "string" },
              storeId: { type: "string" },
              note: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var rejectQuoteSchema = {
  params: {
    type: "object",
    required: ["publicId"],
    properties: {
      publicId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["authCode"],
    properties: {
      authCode: { type: "string", minLength: 1 },
      reason: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        observations: { type: "string", nullable: true },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var convertToMovementSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        quote: { type: "object" },
        movements: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              type: { type: "string" },
              quantity: { type: "number" },
              productId: { type: "string" },
              storeId: { type: "string" },
              note: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getQuoteStatsSchema = {
  querystring: {
    type: "object",
    properties: {
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        byStatus: {
          type: "object",
          properties: {
            DRAFT: { type: "number" },
            PUBLISHED: { type: "number" },
            SENT: { type: "number" },
            VIEWED: { type: "number" },
            APPROVED: { type: "number" },
            REJECTED: { type: "number" },
            EXPIRED: { type: "number" },
            CONVERTED: { type: "number" },
            CANCELED: { type: "number" }
          }
        },
        totalValue: { type: "number" },
        averageValue: { type: "number" },
        recentCount: { type: "number" }
      }
    }
  }
};
var QuoteSchemas = {
  create: createQuoteSchema,
  update: updateQuoteSchema,
  get: getQuoteSchema,
  getPublic: getPublicQuoteSchema,
  list: listQuotesSchema,
  delete: deleteQuoteSchema,
  updateStatus: updateQuoteStatusSchema,
  approve: approveQuoteSchema,
  reject: rejectQuoteSchema,
  convertToMovement: convertToMovementSchema,
  getStats: getQuoteStatsSchema
};

// src/features/quote/quote.routes.ts
async function QuoteRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: QuoteSchemas.create,
    handler: QuoteController.create
  });
  fastify2.get("/", {
    schema: QuoteSchemas.list,
    handler: QuoteController.list
  });
  fastify2.get("/:id", {
    schema: QuoteSchemas.get,
    handler: QuoteController.get
  });
  fastify2.put("/:id", {
    schema: QuoteSchemas.update,
    handler: QuoteController.update
  });
  fastify2.delete("/:id", {
    schema: QuoteSchemas.delete,
    handler: QuoteController.delete
  });
  fastify2.patch("/:id/status", {
    schema: QuoteSchemas.updateStatus,
    handler: QuoteController.updateStatus
  });
  fastify2.patch("/:id/publish", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    handler: QuoteController.publish
  });
  fastify2.patch("/:id/send", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    handler: QuoteController.send
  });
  fastify2.post("/:id/convert", {
    schema: QuoteSchemas.convertToMovement,
    handler: QuoteController.convertToMovements
  });
  fastify2.get("/stats", {
    schema: QuoteSchemas.getStats,
    handler: QuoteController.getStats
  });
  fastify2.get("/user/:userId", {
    schema: {
      params: {
        type: "object",
        required: ["userId"],
        properties: {
          userId: { type: "string" }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1, default: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          status: {
            type: "string",
            enum: [
              "DRAFT",
              "PUBLISHED",
              "SENT",
              "VIEWED",
              "APPROVED",
              "REJECTED",
              "EXPIRED",
              "CONVERTED",
              "CANCELED"
            ]
          }
        }
      }
    },
    handler: QuoteController.getByUser
  });
  fastify2.get("/status/:status", {
    schema: {
      params: {
        type: "object",
        required: ["status"],
        properties: {
          status: {
            type: "string",
            enum: [
              "DRAFT",
              "PUBLISHED",
              "SENT",
              "VIEWED",
              "APPROVED",
              "REJECTED",
              "EXPIRED",
              "CONVERTED",
              "CANCELED"
            ]
          }
        }
      },
      querystring: {
        type: "object",
        properties: {
          page: { type: "number", minimum: 1, default: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          userId: { type: "string" }
        }
      }
    },
    handler: QuoteController.getByStatus
  });
  fastify2.get("/search", {
    schema: {
      querystring: {
        type: "object",
        required: ["q"],
        properties: {
          q: { type: "string", minLength: 1 },
          limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
          userId: { type: "string" }
        }
      }
    },
    handler: QuoteController.search
  });
  fastify2.get("/recent", {
    schema: {
      querystring: {
        type: "object",
        properties: {
          limit: { type: "number", minimum: 1, maximum: 50, default: 5 },
          userId: { type: "string" }
        }
      }
    },
    handler: QuoteController.getRecent
  });
  fastify2.get("/:id/analytics", {
    schema: {
      params: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" }
        }
      }
    },
    handler: QuoteController.getAnalytics
  });
  fastify2.post("/mark-expired", {
    handler: QuoteController.markExpired
  });
  fastify2.get("/public/:publicId", {
    schema: QuoteSchemas.getPublic,
    handler: QuoteController.getPublic
  });
  fastify2.post("/public/:publicId/approve", {
    schema: QuoteSchemas.approve,
    handler: QuoteController.approvePublic
  });
  fastify2.post("/public/:publicId/reject", {
    schema: QuoteSchemas.reject,
    handler: QuoteController.rejectPublic
  });
}

// src/features/roadmap/commands/milestone.commands.ts
var MilestoneCommands = {
  async create(data) {
    const roadmap = await db.roadmap.findUnique({
      where: { id: data.roadmapId }
    });
    if (!roadmap) {
      throw new Error("Roadmap not found");
    }
    if (data.order === void 0) {
      const lastMilestone = await db.milestone.findFirst({
        where: { roadmapId: data.roadmapId },
        orderBy: { order: "desc" }
      });
      data.order = lastMilestone ? lastMilestone.order + 1 : 0;
    }
    return await db.milestone.create({
      data: {
        roadmapId: data.roadmapId,
        title: data.title,
        description: data.description,
        status: data.status || "PENDING",
        progress: data.progress || 0,
        order: data.order,
        startDate: data.startDate,
        endDate: data.endDate
      },
      include: {
        roadmap: {
          select: {
            id: true,
            title: true
          }
        }
      }
    });
  },
  async update(id, roadmapId, data) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { ...data };
    if (data.status === "COMPLETED" && milestone.status !== "COMPLETED") {
      updateData.completedAt = /* @__PURE__ */ new Date();
      updateData.progress = 100;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData,
      include: {
        roadmap: {
          select: {
            id: true,
            title: true
          }
        }
      }
    });
  },
  async delete(id, roadmapId) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    return await db.milestone.delete({
      where: { id }
    });
  },
  async updateProgress(id, roadmapId, progress) {
    if (progress < 0 || progress > 100) {
      throw new Error("Progress must be between 0 and 100");
    }
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { progress };
    if (progress === 100 && milestone.status !== "COMPLETED") {
      updateData.status = "COMPLETED";
      updateData.completedAt = /* @__PURE__ */ new Date();
    }
    if (progress < 100 && milestone.status === "COMPLETED") {
      updateData.status = "IN_PROGRESS";
      updateData.completedAt = null;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData
    });
  },
  async updateStatus(id, roadmapId, status) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    const updateData = { status };
    if (status === "COMPLETED" && milestone.status !== "COMPLETED") {
      updateData.completedAt = /* @__PURE__ */ new Date();
      updateData.progress = 100;
    }
    if (status !== "COMPLETED" && milestone.status === "COMPLETED") {
      updateData.completedAt = null;
    }
    return await db.milestone.update({
      where: { id },
      data: updateData
    });
  },
  async reorder(roadmapId, milestoneIds) {
    const milestones = await db.milestone.findMany({
      where: {
        id: { in: milestoneIds },
        roadmapId
      }
    });
    if (milestones.length !== milestoneIds.length) {
      throw new Error("Some milestones not found or do not belong to this roadmap");
    }
    const updates = milestoneIds.map(
      (id, index) => db.milestone.update({
        where: { id },
        data: { order: index }
      })
    );
    return await db.$transaction(updates);
  }
};

// src/features/roadmap/queries/milestone.queries.ts
var MilestoneQueries = {
  async getById(id, roadmapId) {
    const milestone = await db.milestone.findFirst({
      where: {
        id,
        roadmapId
      },
      include: {
        roadmap: {
          select: {
            id: true,
            title: true,
            status: true
          }
        }
      }
    });
    if (!milestone) {
      throw new Error("Milestone not found");
    }
    return milestone;
  },
  async listByRoadmap(roadmapId, params) {
    const { status, page = 1, limit = 50 } = params || {};
    const skip2 = (page - 1) * limit;
    const where = { roadmapId };
    if (status) {
      where.status = status;
    }
    const [items, total] = await Promise.all([
      db.milestone.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { order: "asc" }
      }),
      db.milestone.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByStatus(roadmapId, status) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status
      },
      orderBy: { order: "asc" }
    });
  },
  async getStats(roadmapId) {
    const [total, pending, inProgress, completed, blocked, avgProgress] = await Promise.all([
      db.milestone.count({ where: { roadmapId } }),
      db.milestone.count({ where: { roadmapId, status: "PENDING" } }),
      db.milestone.count({ where: { roadmapId, status: "IN_PROGRESS" } }),
      db.milestone.count({ where: { roadmapId, status: "COMPLETED" } }),
      db.milestone.count({ where: { roadmapId, status: "BLOCKED" } }),
      db.milestone.aggregate({
        where: { roadmapId },
        _avg: { progress: true }
      })
    ]);
    return {
      total,
      byStatus: {
        pending,
        inProgress,
        completed,
        blocked
      },
      averageProgress: Math.round(avgProgress._avg.progress || 0),
      completionRate: total > 0 ? Math.round(completed / total * 100) : 0
    };
  },
  async getUpcoming(roadmapId, limit = 5) {
    const now = /* @__PURE__ */ new Date();
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: {
          in: ["PENDING", "IN_PROGRESS"]
        },
        startDate: {
          gte: now
        }
      },
      orderBy: { startDate: "asc" },
      take: limit
    });
  },
  async getOverdue(roadmapId) {
    const now = /* @__PURE__ */ new Date();
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: {
          notIn: ["COMPLETED"]
        },
        endDate: {
          lt: now
        }
      },
      orderBy: { endDate: "asc" }
    });
  },
  async getInProgress(roadmapId) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        status: "IN_PROGRESS"
      },
      orderBy: { order: "asc" }
    });
  },
  async search(roadmapId, term, limit = 10) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        OR: [
          { title: { contains: term, mode: "insensitive" } },
          { description: { contains: term, mode: "insensitive" } }
        ]
      },
      orderBy: { order: "asc" },
      take: limit
    });
  },
  // Query para pegar todas as milestones ordenadas (til para drag & drop)
  async getAllOrdered(roadmapId) {
    return await db.milestone.findMany({
      where: { roadmapId },
      orderBy: { order: "asc" }
    });
  },
  // Query para verificar se h milestones bloqueadas
  async hasBlocked(roadmapId) {
    const count = await db.milestone.count({
      where: {
        roadmapId,
        status: "BLOCKED"
      }
    });
    return count > 0;
  },
  // Query para pegar timeline completa
  async getTimeline(roadmapId) {
    return await db.milestone.findMany({
      where: {
        roadmapId,
        OR: [{ startDate: { not: null } }, { endDate: { not: null } }]
      },
      orderBy: [{ startDate: "asc" }, { order: "asc" }]
    });
  }
};

// src/features/roadmap/milestone.controller.ts
var MilestoneController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { title, description, status, progress, order, startDate, endDate } = request.body;
      const result = await MilestoneCommands.create({
        roadmapId,
        title,
        description,
        status,
        progress,
        order,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const result = await MilestoneQueries.getById(id, roadmapId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const updateData = { ...request.body };
      if (updateData.startDate) {
        updateData.startDate = new Date(updateData.startDate).toISOString();
      }
      if (updateData.endDate) {
        updateData.endDate = new Date(updateData.endDate).toISOString();
      }
      const result = await MilestoneCommands.update(id, roadmapId, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      await MilestoneCommands.delete(id, roadmapId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { status, page = 1, limit = 50 } = request.query;
      const result = await MilestoneQueries.listByRoadmap(roadmapId, {
        status,
        page,
        limit
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getByStatus(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { status } = request.query;
      const result = await MilestoneQueries.getByStatus(roadmapId, status);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getStats(roadmapId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUpcoming(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { limit = 5 } = request.query;
      const result = await MilestoneQueries.getUpcoming(roadmapId, limit);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getOverdue(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getOverdue(roadmapId);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getInProgress(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getInProgress(roadmapId);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getTimeline(request, reply) {
    try {
      const { roadmapId } = request.params;
      const result = await MilestoneQueries.getTimeline(roadmapId);
      return reply.send({ timeline: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { q, limit = 10 } = request.query;
      const result = await MilestoneQueries.search(roadmapId, q, limit);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async updateProgress(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const { progress } = request.body;
      const result = await MilestoneCommands.updateProgress(id, roadmapId, progress);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Progress must be between 0 and 100") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateStatus(request, reply) {
    try {
      const { roadmapId, id } = request.params;
      const { status } = request.body;
      const result = await MilestoneCommands.updateStatus(id, roadmapId, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Milestone not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async reorder(request, reply) {
    try {
      const { roadmapId } = request.params;
      const { milestoneIds } = request.body;
      const result = await MilestoneCommands.reorder(roadmapId, milestoneIds);
      return reply.send({ milestones: result });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("not found")) {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/roadmap/milestone.schema.ts
var createMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["title"],
    properties: {
      title: { type: "string", minLength: 1, maxLength: 200 },
      description: { type: "string", maxLength: 1e3 },
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"],
        default: "PENDING"
      },
      progress: { type: "number", minimum: 0, maximum: 100, default: 0 },
      order: { type: "number", minimum: 0 },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      title: { type: "string", minLength: 1, maxLength: 200 },
      description: { type: "string", maxLength: 1e3 },
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      },
      progress: { type: "number", minimum: 0, maximum: 100 },
      order: { type: "number", minimum: 0 },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        roadmapId: { type: "string" },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        progress: { type: "number" },
        order: { type: "number" },
        startDate: { type: ["string", "null"], format: "date-time" },
        endDate: { type: ["string", "null"], format: "date-time" },
        completedAt: { type: ["string", "null"], format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listMilestonesSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      },
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 50 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              roadmapId: { type: "string" },
              title: { type: "string" },
              description: { type: ["string", "null"] },
              status: { type: "string" },
              progress: { type: "number" },
              order: { type: "number" },
              startDate: { type: ["string", "null"], format: "date-time" },
              endDate: { type: ["string", "null"], format: "date-time" },
              completedAt: { type: ["string", "null"], format: "date-time" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteMilestoneSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneProgressSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["progress"],
    properties: {
      progress: { type: "number", minimum: 0, maximum: 100 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        progress: { type: "number" },
        status: { type: "string" },
        completedAt: { type: ["string", "null"], format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateMilestoneStatusSchema = {
  params: {
    type: "object",
    required: ["roadmapId", "id"],
    properties: {
      roadmapId: { type: "string" },
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["status"],
    properties: {
      status: {
        type: "string",
        enum: ["PENDING", "IN_PROGRESS", "COMPLETED", "BLOCKED"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        status: { type: "string" },
        completedAt: { type: ["string", "null"], format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var reorderMilestonesSchema = {
  params: {
    type: "object",
    required: ["roadmapId"],
    properties: {
      roadmapId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["milestoneIds"],
    properties: {
      milestoneIds: {
        type: "array",
        items: { type: "string" },
        minItems: 1
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        milestones: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              order: { type: "number" }
            }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var MilestoneSchemas = {
  create: createMilestoneSchema,
  update: updateMilestoneSchema,
  get: getMilestoneSchema,
  delete: deleteMilestoneSchema,
  list: listMilestonesSchema,
  updateProgress: updateMilestoneProgressSchema,
  updateStatus: updateMilestoneStatusSchema,
  reorder: reorderMilestonesSchema
};

// src/features/roadmap/commands/roadmap.commands.ts
var RoadmapCommands = {
  async create(data) {
    return await db.roadmap.create({ data });
  },
  async update(id, data) {
    return await db.roadmap.update({
      where: { id },
      data
    });
  },
  async delete(id) {
    return await db.roadmap.delete({
      where: { id }
    });
  },
  async updateStatus(id, status) {
    return await db.roadmap.update({
      where: { id },
      data: { status }
    });
  }
};

// src/features/roadmap/queries/roadmap.queries.ts
var RoadmapQueries = {
  async getById(id) {
    return await db.roadmap.findUnique({
      where: { id },
      include: {
        milestones: {
          orderBy: { order: "asc" }
        },
        store: {
          select: {
            id: true,
            name: true
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async list(params) {
    const { page = 1, limit = 10, search, status } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (status !== void 0) {
      where.status = status;
    }
    if (search) {
      where.OR = [
        { title: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [items, total] = await Promise.all([
      db.roadmap.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          _count: {
            select: { milestones: true }
          },
          store: {
            select: {
              id: true,
              name: true
            }
          },
          user: {
            select: {
              id: true,
              name: true
            }
          }
        }
      }),
      db.roadmap.count({ where })
    ]);
    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async search(term, limit = 10) {
    return await db.roadmap.findMany({
      where: {
        OR: [
          { title: { contains: term, mode: "insensitive" } },
          { description: { contains: term, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
  },
  async getActive() {
    return await db.roadmap.findMany({
      where: { status: "ACTIVE" },
      orderBy: { createdAt: "desc" },
      include: {
        _count: {
          select: { milestones: true }
        },
        milestones: {
          where: {
            status: {
              in: ["IN_PROGRESS", "PENDING"]
            }
          },
          orderBy: { order: "asc" },
          take: 5
        }
      }
    });
  },
  async getStats() {
    const [total, active, inactive] = await Promise.all([
      db.roadmap.count(),
      db.roadmap.count({ where: { status: "ACTIVE" } }),
      db.roadmap.count({ where: { status: "COMPLETED" } })
    ]);
    return {
      total,
      active,
      inactive
    };
  }
};

// src/features/roadmap/roadmap.controller.ts
var RoadmapController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const data = { ...request.body };
      if (data.startDate) {
        data.startDate = new Date(data.startDate);
      }
      if (data.endDate) {
        data.endDate = new Date(data.endDate);
      }
      const result = await RoadmapCommands.create(data);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Specific error message") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await RoadmapQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Roadmap not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      if (updateData.startDate) {
        updateData.startDate = new Date(updateData.startDate);
      }
      if (updateData.endDate) {
        updateData.endDate = new Date(updateData.endDate);
      }
      const result = await RoadmapCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await RoadmapCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const result = await RoadmapQueries.list({
        page,
        limit,
        search,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await RoadmapQueries.getActive();
      return reply.send({ roadmaps: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await RoadmapQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await RoadmapQueries.search(q, limit);
      return reply.send({ roadmaps: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { status } = request.body;
      const result = await RoadmapCommands.updateStatus(id, status);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Roadmap not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/roadmap/roadmap.schema.ts
var createRoadmapSchema = {
  body: {
    type: "object",
    required: ["title"],
    properties: {
      storeId: { type: "string" },
      userId: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      storeId: { type: "string" },
      userId: { type: "string" },
      title: { type: "string" },
      description: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] },
      startDate: { type: "string", format: "date-time" },
      endDate: { type: "string", format: "date-time" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: ["string", "null"] },
        userId: { type: ["string", "null"] },
        title: { type: "string" },
        description: { type: ["string", "null"] },
        status: { type: "string" },
        startDate: { type: ["string", "null"] },
        endDate: { type: ["string", "null"] },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listRoadmapsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "string", enum: ["ACTIVE", "COMPLETED", "ARCHIVED"] }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: ["string", "null"] },
              userId: { type: ["string", "null"] },
              title: { type: "string" },
              description: { type: ["string", "null"] },
              status: { type: "string" },
              startDate: { type: ["string", "null"] },
              endDate: { type: ["string", "null"] },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteRoadmapSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var RoadmapSchemas = {
  create: createRoadmapSchema,
  update: updateRoadmapSchema,
  get: getRoadmapSchema,
  delete: deleteRoadmapSchema,
  list: listRoadmapsSchema
};

// src/features/roadmap/roadmap.routes.ts
async function RoadmapRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.get("/active", {
    handler: RoadmapController.getActive
  });
  fastify2.get("/stats", {
    handler: RoadmapController.getStats
  });
  fastify2.get("/search", {
    handler: RoadmapController.search
  });
  fastify2.post("/", {
    schema: RoadmapSchemas.create,
    handler: RoadmapController.create
  });
  fastify2.get("/", {
    schema: RoadmapSchemas.list,
    handler: RoadmapController.list
  });
  fastify2.get("/:id", {
    schema: RoadmapSchemas.get,
    handler: RoadmapController.get
  });
  fastify2.put("/:id", {
    schema: RoadmapSchemas.update,
    handler: RoadmapController.update
  });
  fastify2.delete("/:id", {
    schema: RoadmapSchemas.delete,
    handler: RoadmapController.delete
  });
  fastify2.patch("/:id/status", {
    handler: RoadmapController.updateStatus
  });
  fastify2.get("/:roadmapId/milestones/stats", {
    handler: MilestoneController.getStats
  });
  fastify2.get("/:roadmapId/milestones/upcoming", {
    handler: MilestoneController.getUpcoming
  });
  fastify2.get("/:roadmapId/milestones/overdue", {
    handler: MilestoneController.getOverdue
  });
  fastify2.get("/:roadmapId/milestones/in-progress", {
    handler: MilestoneController.getInProgress
  });
  fastify2.get("/:roadmapId/milestones/timeline", {
    handler: MilestoneController.getTimeline
  });
  fastify2.get("/:roadmapId/milestones/search", {
    handler: MilestoneController.search
  });
  fastify2.post("/:roadmapId/milestones", {
    schema: MilestoneSchemas.create,
    handler: MilestoneController.create
  });
  fastify2.get("/:roadmapId/milestones", {
    schema: MilestoneSchemas.list,
    handler: MilestoneController.list
  });
  fastify2.get("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.get,
    handler: MilestoneController.get
  });
  fastify2.put("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.update,
    handler: MilestoneController.update
  });
  fastify2.delete("/:roadmapId/milestones/:id", {
    schema: MilestoneSchemas.delete,
    handler: MilestoneController.delete
  });
  fastify2.patch("/:roadmapId/milestones/:id/progress", {
    schema: MilestoneSchemas.updateProgress,
    handler: MilestoneController.updateProgress
  });
  fastify2.patch("/:roadmapId/milestones/:id/status", {
    schema: MilestoneSchemas.updateStatus,
    handler: MilestoneController.updateStatus
  });
  fastify2.post("/:roadmapId/milestones/reorder", {
    schema: MilestoneSchemas.reorder,
    handler: MilestoneController.reorder
  });
}

// src/features/store/commands/store.commands.ts
var StoreCommands = {
  async create(data) {
    const existingStore = await db.store.findUnique({
      where: { cnpj: data.cnpj }
    });
    if (existingStore) {
      throw new Error("CNPJ already exists");
    }
    const owner = await db.user.findUnique({
      where: { id: data.ownerId }
    });
    if (!owner) {
      throw new Error("Owner not found");
    }
    return await db.store.create({
      data: {
        ownerId: data.ownerId,
        name: data.name,
        cnpj: data.cnpj,
        email: data.email || null,
        phone: data.phone || null,
        cep: data.cep || null,
        city: data.city || null,
        state: data.state || null,
        address: data.address || null,
        status: data.status !== void 0 ? data.status : true
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingStore = await db.store.findUnique({
      where: { id }
    });
    if (!existingStore) {
      throw new Error("Store not found");
    }
    if (data.cnpj && data.cnpj !== existingStore.cnpj) {
      const cnpjExists = await db.store.findUnique({
        where: { cnpj: data.cnpj }
      });
      if (cnpjExists) {
        throw new Error("CNPJ already exists");
      }
    }
    return await db.store.update({
      where: { id },
      data: {
        ...data,
        email: data.email === "" ? null : data.email,
        phone: data.phone === "" ? null : data.phone,
        cep: data.cep === "" ? null : data.cep,
        city: data.city === "" ? null : data.city,
        state: data.state === "" ? null : data.state,
        address: data.address === "" ? null : data.address
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  },
  async delete(id) {
    const existingStore = await db.store.findUnique({
      where: { id }
    });
    if (!existingStore) {
      throw new Error("Store not found");
    }
    const productCount = await db.product.count({
      where: { storeId: id }
    });
    if (productCount > 0) {
      throw new Error("Cannot delete store with existing products");
    }
    return await db.store.delete({
      where: { id }
    });
  }
};

// src/features/store/queries/store.queries.ts
var StoreQueries = {
  async getById(id) {
    const store = await db.store.findUnique({
      where: { id },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        products: {
          select: {
            id: true,
            name: true,
            referencePrice: true,
            status: true,
            createdAt: true
          }
        },
        _count: {
          select: {
            products: true,
            users: true
          }
        }
      }
    });
    if (!store) {
      throw new Error("Store not found");
    }
    return store;
  }
};

// src/features/store/store.controller.ts
var StoreController = {
  async create(request, reply) {
    try {
      const { name, cnpj, email, phone, cep, city, state, address, status } = request.body;
      const ownerId = request.user?.id;
      const result = await StoreCommands.create({
        ownerId,
        name,
        cnpj,
        email,
        phone,
        cep,
        city,
        state,
        address,
        status
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "Owner not found") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const id = request.store?.id;
      const result = await StoreQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const id = request.store?.id;
      const updateData = { ...request.body };
      const result = await StoreCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const id = request.store?.id;
      await StoreCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Store not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete store with existing products") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/store/store.schema.ts
var createStoreSchema = {
  body: {
    type: "object",
    required: ["name", "cnpj"],
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      cnpj: { type: "string", minLength: 14, maxLength: 18 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      status: { type: "boolean", default: true }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var updateStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      cnpj: { type: "string", minLength: 14, maxLength: 18 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var getStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        },
        products: { type: "array" },
        _count: {
          type: "object",
          properties: {
            products: { type: "number" },
            users: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listStoresSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stores: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              cnpj: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              owner: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  users: { type: "number" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoreByCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        },
        _count: {
          type: "object",
          properties: {
            products: { type: "number" },
            users: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoresByOwnerSchema = {
  params: {
    type: "object",
    required: ["ownerId"],
    properties: {
      ownerId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        stores: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              cnpj: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              owner: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              },
              _count: {
                type: "object",
                properties: {
                  products: { type: "number" },
                  users: { type: "number" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var verifyCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        available: { type: "boolean" },
        message: { type: "string" }
      }
    }
  }
};
var toggleStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var addUserToStoreSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["userId", "role"],
    properties: {
      userId: { type: "string", minLength: 1 },
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var removeUserFromStoreSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateUserRoleSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["role"],
    properties: {
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var listStoreUsersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      role: {
        type: "string",
        enum: ["OWNER", "ADMIN", "MANAGER", "STAFF"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        storeUsers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true },
                  createdAt: { type: "string", format: "date-time" }
                }
              },
              store: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  cnpj: { type: "string" }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getStoreUserSchema = {
  params: {
    type: "object",
    required: ["id", "userId"],
    properties: {
      id: { type: "string" },
      userId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true },
            createdAt: { type: "string", format: "date-time" }
          }
        },
        store: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            cnpj: { type: "string" }
          }
        }
      }
    }
  }
};
var getStoreOwnerSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        storeId: { type: "string" },
        userId: { type: "string" },
        role: { type: "string" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" },
            status: { type: "boolean" },
            lastLoginAt: { type: "string", format: "date-time", nullable: true }
          }
        }
      }
    }
  }
};
var getStoreAdminsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        admins: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreManagersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        managers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreStaffSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        staff: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var getStoreUserStatsSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        byRole: {
          type: "array",
          items: {
            type: "object",
            properties: {
              role: { type: "string" },
              _count: {
                type: "object",
                properties: {
                  id: { type: "number" }
                }
              }
            }
          }
        },
        active: { type: "number" },
        inactive: { type: "number" }
      }
    }
  }
};
var searchStoreUsersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        storeUsers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              storeId: { type: "string" },
              userId: { type: "string" },
              role: { type: "string" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  status: { type: "boolean" },
                  lastLoginAt: { type: "string", format: "date-time", nullable: true }
                }
              }
            }
          }
        }
      }
    }
  }
};
var transferOwnershipSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["newOwnerId"],
    properties: {
      newOwnerId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        cnpj: { type: "string" },
        ownerId: { type: "string" },
        owner: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    }
  }
};
var StoreSchemas = {
  create: createStoreSchema,
  update: updateStoreSchema,
  get: getStoreSchema,
  delete: deleteStoreSchema,
  list: listStoresSchema,
  getByCnpj: getStoreByCnpjSchema,
  getByOwner: getStoresByOwnerSchema,
  verifyCnpj: verifyCnpjSchema,
  toggleStatus: toggleStatusSchema,
  // Gerenciamento de usurios
  addUser: addUserToStoreSchema,
  removeUser: removeUserFromStoreSchema,
  updateUserRole: updateUserRoleSchema,
  listUsers: listStoreUsersSchema,
  getStoreUser: getStoreUserSchema,
  getStoreOwner: getStoreOwnerSchema,
  getStoreAdmins: getStoreAdminsSchema,
  getStoreManagers: getStoreManagersSchema,
  getStoreStaff: getStoreStaffSchema,
  getStoreUserStats: getStoreUserStatsSchema,
  searchStoreUsers: searchStoreUsersSchema,
  transferOwnership: transferOwnershipSchema
};

// src/features/store/store.routes.ts
async function StoreRoutes(fastify2) {
  fastify2.post("/", {
    schema: StoreSchemas.create,
    preHandler: [Middlewares.auth],
    handler: StoreController.create
  });
  fastify2.get("/", {
    preHandler: [Middlewares.auth, Middlewares.store],
    handler: StoreController.get
  });
  fastify2.put("/", {
    schema: StoreSchemas.update,
    preHandler: [Middlewares.auth, Middlewares.store],
    handler: StoreController.update
  });
  fastify2.delete("/", {
    schema: StoreSchemas.delete,
    preHandler: [Middlewares.auth, Middlewares.store],
    handler: StoreController.delete
  });
}

// src/features/subscription/commands/subscription.commands.ts
var SubscriptionCommands = {
  async create(data) {
    const existingSubscription = await db.subscription.findFirst({
      where: { userId: data.userId }
    });
    if (existingSubscription) {
      throw new Error("Subscription with this user already exists");
    }
    return await db.subscription.create({
      data: {
        ...data,
        priceInterval: data.interval
      },
      include: {
        user: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingSubscription = await db.subscription.findUnique({
      where: { id }
    });
    if (!existingSubscription) {
      throw new Error("Plan not found");
    }
    return await db.subscription.update({
      where: { id },
      data: {
        ...data,
        ...data.interval && { priceInterval: data.interval }
      },
      include: {
        user: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  },
  async delete(id) {
    const subscription2 = await db.subscription.findUnique({
      where: { id },
      include: {
        user: {
          select: { id: true }
        }
      }
    });
    if (!subscription2) {
      throw new Error("Plan not found");
    }
    if (subscription2.user) {
      throw new Error(
        `Cannot delete subscription. It has ${subscription2.user} associated customers. Please reassign or delete the customers first.`
      );
    }
    return await db.subscription.delete({
      where: { id }
    });
  },
  async forceDelete(id) {
    const subscription2 = await db.subscription.findUnique({
      where: { id }
    });
    if (!subscription2) {
      throw new Error("Plan not found");
    }
    await db.subscription.updateMany({
      where: { userId: id },
      data: { userId: null }
    });
    return await db.subscription.delete({
      where: { id }
    });
  },
  async updateStatus(id, active) {
    const subscription2 = await db.subscription.findUnique({
      where: { id }
    });
    if (!subscription2) {
      throw new Error("Subscription not found");
    }
    return await db.subscription.update({
      where: { id },
      data: {
        status: active ? "ACTIVE" : "INACTIVE"
      },
      include: {
        user: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  }
};

// src/features/subscription/queries/subscription.queries.ts
var SubscriptionQueries = {
  async getById(id) {
    const subscription2 = await db.subscription.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (!subscription2) {
      return null;
    }
    return {
      ...subscription2
    };
  },
  async list(params) {
    const { page = 1, limit = 10, search, interval } = params;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (interval) {
      where.interval = interval;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } }
      ];
    }
    const [subscriptions, total] = await Promise.all([
      db.subscription.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      }),
      db.subscription.count({ where })
    ]);
    const itemsWithCount = subscriptions.map((subscription2) => ({
      ...subscription2
    }));
    return {
      items: itemsWithCount,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getActive() {
    const subscriptions = await db.subscription.findMany({
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    return subscriptions.map((subscription2) => ({
      ...subscription2
    }));
  },
  async compare(planIds) {
    if (!planIds || planIds.length === 0) {
      throw new Error("At least one plan ID is required for comparison");
    }
    const subscriptions = await db.subscription.findMany({
      where: { id: { in: planIds } },
      orderBy: { createdAt: "desc" },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
    if (subscriptions.length === 0) {
      throw new Error("No plans found for comparison");
    }
    return subscriptions;
  },
  async getCustomers(planId, params) {
    const { page = 1, limit = 10, status } = params;
    const skip2 = (page - 1) * limit;
    const plan = await db.subscription.findUnique({
      where: { id: planId }
    });
    if (!plan) {
      throw new Error("Plan not found");
    }
    const where = {
      userId: planId
    };
    if (status) {
      where.status = status;
    }
    const [customers, total] = await Promise.all([
      db.subscription.findMany({
        where,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          },
          invoices: {
            select: {
              id: true,
              amount: true,
              status: true,
              createdAt: true
            },
            orderBy: { createdAt: "desc" },
            take: 5
            // ltimas 5 faturas
          }
        }
      }),
      db.subscription.count({ where })
    ]);
    return {
      customers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getStats() {
    const [total, active, inactive, cancelled, trial] = await Promise.all([
      db.subscription.count(),
      db.subscription.count({ where: { status: "ACTIVE" } }),
      db.subscription.count({ where: { status: "INACTIVE" } }),
      db.subscription.count({ where: { status: "CANCELLED" } }),
      db.subscription.count({ where: { status: "TRIAL" } })
    ]);
    return {
      total,
      active,
      inactive,
      cancelled,
      trial
    };
  }
};

// src/features/subscription/subscription.controller.ts
var SubscriptionController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { userId, description, price, interval, features } = request.body;
      const result = await SubscriptionCommands.create({
        userId,
        description,
        price,
        interval,
        features
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await SubscriptionQueries.getById(id);
      if (!result) {
        return reply.status(404).send({
          error: "Plan not found"
        });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await SubscriptionCommands.update(
        id,
        updateData
      );
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Plan with this name already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await SubscriptionCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Subscription not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("Cannot delete subscription") && error.message.includes("associated customers")) {
        return reply.status(400).send({
          error: error.message,
          suggestion: "Use DELETE /subscriptions/:id/force to delete the subscription and remove all customer associations"
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async forceDelete(request, reply) {
    try {
      const { id } = request.params;
      await SubscriptionCommands.forceDelete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Subscription not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, interval } = request.query;
      const result = await SubscriptionQueries.list({
        page,
        limit,
        search,
        interval
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getActive(request, reply) {
    try {
      const result = await SubscriptionQueries.getActive();
      return reply.send({ subscriptions: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async compare(request, reply) {
    try {
      const { subscriptionIds } = request.query;
      const result = await SubscriptionQueries.compare(subscriptionIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "At least one subscription ID is required for comparison") {
        return reply.status(400).send({
          error: error.message
        });
      }
      if (error.message === "No subscriptions found for comparison") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getCustomers(request, reply) {
    try {
      const { id } = request.params;
      const { page = 1, limit = 10, status } = request.query;
      const result = await SubscriptionQueries.getCustomers(id, {
        page,
        limit,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Plan not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await SubscriptionQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async updateStatus(request, reply) {
    try {
      const { id } = request.params;
      const { active } = request.body;
      const result = await SubscriptionCommands.updateStatus(id, active);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Subscription not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/subscription/subscription.schema.ts
var createSubscriptionSchema = {
  body: {
    type: "object",
    required: ["userId", "price", "interval"],
    properties: {
      userId: { type: "string" },
      description: { type: "string" },
      price: { type: "number", minimum: 0.01 },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      },
      features: { type: "object" }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var updateSubscriptionSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      description: { type: "string" },
      price: { type: "number", minimum: 0.01 },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      },
      features: { type: "object" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getSubscriptionSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        customersCount: { type: "number" },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" }
                }
              }
            }
          }
        }
      }
    }
  }
};
var listSubscriptionsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      interval: {
        type: "string",
        enum: ["MONTHLY", "YEARLY"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              price: { type: "number" },
              interval: { type: "string" },
              features: { type: "object", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              customersCount: { type: "number" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var deleteSubscriptionSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var updateSubscriptionStatusSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["active"],
    properties: {
      active: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        description: { type: "string", nullable: true },
        price: { type: "number" },
        interval: { type: "string" },
        features: { type: "object", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var compareSubscriptionsSchema = {
  querystring: {
    type: "object",
    required: ["subscriptionIds"],
    properties: {
      subscriptionIds: {
        type: "array",
        items: { type: "string", minLength: 1 },
        minItems: 1,
        uniqueItems: true
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        subscriptions: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              description: { type: "string", nullable: true },
              price: { type: "number" },
              interval: { type: "string" },
              features: { type: "object", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              customersCount: { type: "number" }
            }
          }
        },
        comparison: {
          type: "object",
          properties: {
            priceRange: {
              type: "object",
              properties: {
                min: { type: "number" },
                max: { type: "number" }
              }
            },
            intervals: {
              type: "array",
              items: {
                type: "string",
                enum: ["MONTHLY", "YEARLY"]
              }
            },
            features: {
              type: "array",
              items: { type: "string" }
            }
          }
        }
      }
    }
  }
};
var getSubscriptionCustomersSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      status: {
        type: "string",
        enum: ["ACTIVE", "INACTIVE", "CANCELLED", "TRIAL"]
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        subscription: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            price: { type: "number" },
            interval: { type: "string" }
          }
        },
        customers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              status: { type: "string" },
              renewalDate: { type: "string", format: "date-time", nullable: true },
              trialEndsAt: { type: "string", format: "date-time", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              user: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  email: { type: "string" },
                  phone: { type: "string", nullable: true }
                }
              },
              subscription: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  price: { type: "number" },
                  interval: { type: "string" }
                }
              },
              invoices: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    amount: { type: "number" },
                    status: { type: "string" },
                    createdAt: { type: "string", format: "date-time" }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSubscriptionStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        total: { type: "number" },
        active: { type: "number" },
        inactive: { type: "number" },
        monthlySubscriptions: { type: "number" },
        yearlySubscriptions: { type: "number" },
        totalCustomers: { type: "number" },
        totalRevenue: { type: "number" },
        averagePrice: { type: "number" }
      }
    }
  }
};
var SubscriptionSchemas = {
  create: createSubscriptionSchema,
  update: updateSubscriptionSchema,
  get: getSubscriptionSchema,
  delete: deleteSubscriptionSchema,
  list: listSubscriptionsSchema,
  updateStatus: updateSubscriptionStatusSchema,
  compare: compareSubscriptionsSchema,
  getCustomers: getSubscriptionCustomersSchema,
  getStats: getSubscriptionStatsSchema
};

// src/features/subscription/subscription.routes.ts
async function SubscriptionRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: SubscriptionSchemas.create,
    handler: SubscriptionController.create
  });
  fastify2.get("/", {
    schema: SubscriptionSchemas.list,
    handler: SubscriptionController.list
  });
  fastify2.get("/:id", {
    schema: SubscriptionSchemas.get,
    handler: SubscriptionController.get
  });
  fastify2.put("/:id", {
    schema: SubscriptionSchemas.update,
    handler: SubscriptionController.update
  });
  fastify2.delete("/:id", {
    schema: SubscriptionSchemas.delete,
    handler: SubscriptionController.delete
  });
  fastify2.delete("/:id/force", {
    schema: SubscriptionSchemas.delete,
    handler: SubscriptionController.forceDelete
  });
  fastify2.get("/active", {
    handler: SubscriptionController.getActive
  });
  fastify2.get("/stats", {
    handler: SubscriptionController.getStats
  });
  fastify2.get("/compare", {
    schema: SubscriptionSchemas.compare,
    handler: SubscriptionController.compare
  });
  fastify2.get("/:id/customers", {
    schema: SubscriptionSchemas.getCustomers,
    handler: SubscriptionController.getCustomers
  });
  fastify2.patch("/:id/status", {
    schema: SubscriptionSchemas.updateStatus,
    handler: SubscriptionController.updateStatus
  });
}

// src/features/supplier/commands/supplier-responsible.commands.ts
var SupplierResponsibleCommands = {
  async create({
    supplierId,
    data
  }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    if (data.email) {
      const existingEmail = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          email: data.email
        }
      });
      if (existingEmail) {
        throw new Error("Email already exists for this supplier");
      }
    }
    if (data.cpf) {
      const existingCpf = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          cpf: data.cpf
        }
      });
      if (existingCpf) {
        throw new Error("CPF already exists for this supplier");
      }
    }
    return await db.supplierResponsible.create({
      data: {
        ...data,
        supplierId,
        status: true
      }
    });
  },
  async update({
    supplierId,
    responsibleId,
    data
  }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    if (data.email) {
      const existingEmail = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          email: data.email,
          id: { not: responsibleId }
        }
      });
      if (existingEmail) {
        throw new Error("Email already exists for another responsible of this supplier");
      }
    }
    if (data.cpf) {
      const existingCpf = await db.supplierResponsible.findFirst({
        where: {
          supplierId,
          cpf: data.cpf,
          id: { not: responsibleId }
        }
      });
      if (existingCpf) {
        throw new Error("CPF already exists for another responsible of this supplier");
      }
    }
    return await db.supplierResponsible.update({
      where: { id: responsibleId },
      data
    });
  },
  async delete({ supplierId, responsibleId }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    await db.supplierResponsible.delete({
      where: { id: responsibleId }
    });
  },
  async toggleStatus({ supplierId, responsibleId }) {
    const existingResponsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!existingResponsible) {
      throw new Error("Responsible not found for this supplier");
    }
    return await db.supplierResponsible.update({
      where: { id: responsibleId },
      data: {
        status: !existingResponsible.status
      }
    });
  },
  async bulkCreate({
    supplierId,
    responsibles
  }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const emails = responsibles.filter((r) => r.email).map((r) => r.email);
    const cpfs = responsibles.filter((r) => r.cpf).map((r) => r.cpf);
    if (new Set(emails).size !== emails.length) {
      throw new Error("Duplicate emails found in the provided data");
    }
    if (new Set(cpfs).size !== cpfs.length) {
      throw new Error("Duplicate CPFs found in the provided data");
    }
    if (emails.length > 0) {
      const existingEmails = await db.supplierResponsible.findMany({
        where: {
          supplierId,
          email: { in: emails }
        },
        select: { email: true }
      });
      if (existingEmails.length > 0) {
        throw new Error(`Emails already exist: ${existingEmails.map((e) => e.email).join(", ")}`);
      }
    }
    if (cpfs.length > 0) {
      const existingCpfs = await db.supplierResponsible.findMany({
        where: {
          supplierId,
          cpf: { in: cpfs }
        },
        select: { cpf: true }
      });
      if (existingCpfs.length > 0) {
        throw new Error(`CPFs already exist: ${existingCpfs.map((c) => c.cpf).join(", ")}`);
      }
    }
    return await db.supplierResponsible.createMany({
      data: responsibles.map((responsible) => ({
        ...responsible,
        supplierId,
        status: true
      }))
    });
  }
};

// src/features/supplier/queries/supplier-responsible.queries.ts
var SupplierResponsibleQueries = {
  async getById({ supplierId, responsibleId }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        id: responsibleId,
        supplierId
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found for this supplier");
    }
    return responsible;
  },
  async list({
    supplierId,
    params
  }) {
    const { page = 1, limit = 10, search, status } = params;
    const skip2 = (page - 1) * limit;
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const where = {
      supplierId
    };
    if (status !== void 0) {
      where.status = status;
    }
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } },
        { phone: { contains: search, mode: "insensitive" } },
        { cpf: { contains: search, mode: "insensitive" } }
      ];
    }
    const [responsibles, total] = await Promise.all([
      db.supplierResponsible.findMany({
        where,
        skip: skip2,
        take: limit
      }),
      db.supplierResponsible.count({ where })
    ]);
    const totalPages = Math.ceil(total / limit);
    return {
      responsibles,
      pagination: {
        page,
        limit,
        total,
        totalPages
      }
    };
  },
  async getByEmail({ supplierId, email }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        supplierId,
        email
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found with this email for this supplier");
    }
    return responsible;
  },
  async getByCpf({ supplierId, cpf }) {
    const responsible = await db.supplierResponsible.findFirst({
      where: {
        supplierId,
        cpf
      }
    });
    if (!responsible) {
      throw new Error("Responsible not found with this CPF for this supplier");
    }
    return responsible;
  },
  async getActive({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: {
        supplierId,
        status: true
      },
      orderBy: { name: "asc" }
    });
  },
  async getStats({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    const [total, active, inactive] = await Promise.all([
      db.supplierResponsible.count({
        where: { supplierId }
      }),
      db.supplierResponsible.count({
        where: { supplierId, status: true }
      }),
      db.supplierResponsible.count({
        where: { supplierId, status: false }
      })
    ]);
    return {
      total,
      active,
      inactive
    };
  },
  async search({
    supplierId,
    searchTerm,
    limit
  }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: {
        supplierId,
        OR: [
          { name: { contains: searchTerm, mode: "insensitive" } },
          { email: { contains: searchTerm, mode: "insensitive" } },
          { phone: { contains: searchTerm, mode: "insensitive" } },
          { cpf: { contains: searchTerm, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { name: "asc" }
    });
  },
  async getBySupplier({ supplierId }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: { supplierId },
      orderBy: { name: "asc" }
    });
  },
  async getRecent({ supplierId, limit }) {
    const supplier = await db.supplier.findUnique({
      where: { id: supplierId }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplierResponsible.findMany({
      where: { supplierId },
      take: limit
    });
  }
};

// src/features/supplier/supplier-responsible.controller.ts
var SupplierResponsibleController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { supplierId } = request.params;
      const { name, email, phone, cpf } = request.body;
      const createData = { name, email, phone, cpf };
      const result = await SupplierResponsibleCommands.create({ supplierId, data: createData });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists for this supplier" || error.message === "CPF already exists for this supplier") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const result = await SupplierResponsibleQueries.getById({ supplierId, responsibleId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const { name, email, phone, cpf, status } = request.body;
      const updateData = {};
      if (name !== void 0) updateData.name = name;
      if (email !== void 0) updateData.email = email;
      if (phone !== void 0) updateData.phone = phone;
      if (cpf !== void 0) updateData.cpf = cpf;
      if (status !== void 0) updateData.status = status;
      const result = await SupplierResponsibleCommands.update({
        supplierId,
        responsibleId,
        data: updateData
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists for another responsible of this supplier" || error.message === "CPF already exists for another responsible of this supplier") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      await SupplierResponsibleCommands.delete({ supplierId, responsibleId });
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { supplierId } = request.params;
      const { page = 1, limit = 10, search, status } = request.query;
      const result = await SupplierResponsibleQueries.list({
        supplierId,
        params: { page, limit, search, status }
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getByEmail(request, reply) {
    try {
      const { supplierId, email } = request.params;
      const result = await SupplierResponsibleQueries.getByEmail({ supplierId, email });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found with this email for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCpf(request, reply) {
    try {
      const { supplierId, cpf } = request.params;
      const result = await SupplierResponsibleQueries.getByCpf({ supplierId, cpf });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found with this CPF for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const { supplierId } = request.params;
      const result = await SupplierResponsibleQueries.getActive({ supplierId });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const { supplierId } = request.params;
      const result = await SupplierResponsibleQueries.getStats({ supplierId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { supplierId } = request.params;
      const { q, limit = 10 } = request.query;
      const result = await SupplierResponsibleQueries.search({ supplierId, searchTerm: q, limit });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { supplierId } = request.params;
      const { limit = 5 } = request.query;
      const result = await SupplierResponsibleQueries.getRecent({ supplierId, limit });
      return reply.send({ responsibles: result });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async toggleStatus(request, reply) {
    try {
      const { supplierId, responsibleId } = request.params;
      const result = await SupplierResponsibleCommands.toggleStatus({ supplierId, responsibleId });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Responsible not found for this supplier") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkCreate(request, reply) {
    try {
      const { supplierId } = request.params;
      const responsibles = request.body;
      const filteredResponsibles = responsibles.map((responsible) => ({
        name: responsible.name,
        email: responsible.email,
        phone: responsible.phone,
        cpf: responsible.cpf
      }));
      const result = await SupplierResponsibleCommands.bulkCreate({
        supplierId,
        responsibles: filteredResponsibles
      });
      return reply.status(201).send({
        message: `${result.count} responsibles created successfully`,
        count: result.count
      });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message.includes("already exist") || error.message.includes("Duplicate")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/supplier/supplier-responsible.schema.ts
var createSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  body: {
    type: "object",
    required: ["name"],
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var updateSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1 },
      email: { type: "string", format: "email" },
      phone: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteSupplierResponsibleSchema = {
  params: {
    type: "object",
    required: ["supplierId", "responsibleId"],
    properties: {
      supplierId: { type: "string" },
      responsibleId: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listSupplierResponsiblesSchema = {
  params: {
    type: "object",
    required: ["supplierId"],
    properties: {
      supplierId: { type: "string" }
    }
  },
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        responsibles: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              email: { type: "string", nullable: true },
              phone: { type: "string", nullable: true },
              cpf: { type: "string", nullable: true },
              status: { type: "boolean" },
              supplierId: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSupplierResponsibleByEmailSchema = {
  params: {
    type: "object",
    required: ["supplierId", "email"],
    properties: {
      supplierId: { type: "string" },
      email: { type: "string", format: "email" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierResponsibleByCpfSchema = {
  params: {
    type: "object",
    required: ["supplierId", "cpf"],
    properties: {
      supplierId: { type: "string" },
      cpf: { type: "string", minLength: 11, maxLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        email: { type: "string", nullable: true },
        phone: { type: "string", nullable: true },
        cpf: { type: "string", nullable: true },
        status: { type: "boolean" },
        supplierId: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var SupplierResponsibleSchemas = {
  create: createSupplierResponsibleSchema,
  update: updateSupplierResponsibleSchema,
  get: getSupplierResponsibleSchema,
  delete: deleteSupplierResponsibleSchema,
  list: listSupplierResponsiblesSchema,
  getByEmail: getSupplierResponsibleByEmailSchema,
  getByCpf: getSupplierResponsibleByCpfSchema
};

// src/features/supplier/supplier-responsible.routes.ts
async function SupplierResponsibleRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/:supplierId/responsibles", {
    schema: SupplierResponsibleSchemas.create,
    handler: SupplierResponsibleController.create
  });
  fastify2.get("/:supplierId/responsibles", {
    schema: SupplierResponsibleSchemas.list,
    handler: SupplierResponsibleController.list
  });
  fastify2.get("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.get,
    handler: SupplierResponsibleController.get
  });
  fastify2.put("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.update,
    handler: SupplierResponsibleController.update
  });
  fastify2.delete("/:supplierId/responsibles/:responsibleId", {
    schema: SupplierResponsibleSchemas.delete,
    handler: SupplierResponsibleController.delete
  });
  fastify2.get("/:supplierId/responsibles/email/:email", {
    schema: SupplierResponsibleSchemas.getByEmail,
    handler: SupplierResponsibleController.getByEmail
  });
  fastify2.get("/:supplierId/responsibles/cpf/:cpf", {
    schema: SupplierResponsibleSchemas.getByCpf,
    handler: SupplierResponsibleController.getByCpf
  });
  fastify2.get("/:supplierId/responsibles/active", {
    handler: SupplierResponsibleController.getActive
  });
  fastify2.get("/:supplierId/responsibles/stats", {
    handler: SupplierResponsibleController.getStats
  });
  fastify2.get("/:supplierId/responsibles/search", {
    handler: SupplierResponsibleController.search
  });
  fastify2.get("/:supplierId/responsibles/recent", {
    handler: SupplierResponsibleController.getRecent
  });
  fastify2.patch("/:supplierId/responsibles/:responsibleId/toggle-status", {
    handler: SupplierResponsibleController.toggleStatus
  });
  fastify2.post("/:supplierId/responsibles/bulk", {
    handler: SupplierResponsibleController.bulkCreate
  });
}

// src/features/supplier/commands/supplier.commands.ts
var SupplierCommands = {
  async create(data) {
    const existingSupplier = await db.supplier.findUnique({
      where: {
        cnpj_storeId: {
          cnpj: data.cnpj,
          storeId: data.storeId || null
        }
      }
    });
    if (existingSupplier) {
      throw new Error("CNPJ already exists");
    }
    const responsiblesData = data.responsibles?.map((responsible) => ({
      name: responsible.name,
      phone: responsible.phone,
      email: responsible.email,
      cpf: responsible.cpf,
      status: true
    })) || [];
    return await db.supplier.create({
      data: {
        corporateName: data.corporateName,
        cnpj: data.cnpj,
        tradeName: data.tradeName,
        cep: data.cep,
        city: data.city,
        state: data.state,
        address: data.address,
        storeId: data.storeId,
        status: true,
        responsibles: {
          create: responsiblesData
        }
      },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  },
  async update(id, data) {
    const existingSupplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!existingSupplier) {
      throw new Error("Supplier not found");
    }
    if (data.cnpj && data.cnpj !== existingSupplier.cnpj) {
      const cnpjExists = await db.supplier.findUnique({
        where: {
          cnpj_storeId: {
            cnpj: data.cnpj,
            storeId: existingSupplier.storeId
          }
        }
      });
      if (cnpjExists) {
        throw new Error("CNPJ already exists");
      }
    }
    return await db.supplier.update({
      where: { id },
      data,
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  },
  async delete(id) {
    const existingSupplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!existingSupplier) {
      throw new Error("Supplier not found");
    }
    const productsCount = await db.product.count({
      where: { supplierId: id }
    });
    if (productsCount > 0) {
      throw new Error("Cannot delete supplier with associated products");
    }
    return await db.supplier.delete({
      where: { id }
    });
  },
  async toggleStatus(id) {
    const supplier = await db.supplier.findUnique({
      where: { id }
    });
    if (!supplier) {
      throw new Error("Supplier not found");
    }
    return await db.supplier.update({
      where: { id },
      data: { status: !supplier.status },
      include: {
        responsibles: true,
        products: {
          select: {
            id: true,
            name: true,
            status: true
          }
        }
      }
    });
  }
};

// src/features/supplier/supplier.controller.ts
var SupplierController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { corporateName, cnpj, tradeName, cep, city, state, address, storeId, responsibles } = request.body;
      const contextStoreId = request.store?.id;
      const result = await SupplierCommands.create({
        corporateName,
        cnpj,
        tradeName,
        cep,
        city,
        state,
        address,
        storeId: storeId || contextStoreId,
        responsibles
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await SupplierQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await SupplierCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "CNPJ already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await SupplierCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Cannot delete supplier with associated products") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await SupplierQueries.list({
        page,
        limit,
        search,
        status,
        storeId
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getByCnpj(request, reply) {
    try {
      const { cnpj } = request.params;
      const storeId = request.store?.id;
      const result = await SupplierQueries.getByCnpj(cnpj, storeId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCity(request, reply) {
    try {
      const { city } = request.params;
      const result = await SupplierQueries.getByCity(city);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByState(request, reply) {
    try {
      const { state } = request.params;
      const result = await SupplierQueries.getByState(state);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const result = await SupplierQueries.getActive();
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await SupplierQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { search, page = 1, limit = 10 } = request.query;
      const storeId = request.store?.id;
      if (!storeId) {
        return reply.status(400).send({
          error: "Store context required"
        });
      }
      const result = await SupplierQueries.search(search, storeId, { page, limit });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getTopSuppliers(request, reply) {
    try {
      const { limit = 5 } = request.query;
      const result = await SupplierQueries.getTopSuppliers(limit);
      return reply.send({ suppliers: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async toggleStatus(request, reply) {
    try {
      const { id } = request.params;
      const result = await SupplierCommands.toggleStatus(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Supplier not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/supplier/supplier.schema.ts
var createSupplierSchema = {
  body: {
    type: "object",
    required: ["corporateName", "cnpj"],
    properties: {
      corporateName: { type: "string", minLength: 1 },
      cnpj: { type: "string", minLength: 14 },
      tradeName: { type: "string" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" },
      storeId: { type: "string" },
      responsibles: {
        type: "array",
        items: {
          type: "object",
          required: ["name"],
          properties: {
            name: { type: "string", minLength: 1 },
            phone: { type: "string" },
            email: { type: "string", format: "email" },
            cpf: { type: "string" }
          }
        }
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        responsibles: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              name: { type: "string" },
              phone: { type: "string", nullable: true },
              email: { type: "string", nullable: true },
              cpf: { type: "string", nullable: true },
              status: { type: "boolean" }
            }
          }
        }
      }
    }
  }
};
var updateSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      corporateName: { type: "string", minLength: 1 },
      cnpj: { type: "string", minLength: 14 },
      tradeName: { type: "string" },
      status: { type: "boolean" },
      cep: { type: "string" },
      city: { type: "string" },
      state: { type: "string" },
      address: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteSupplierSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listSuppliersSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" },
              responsibles: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    email: { type: "string" },
                    phone: { type: "string", nullable: true },
                    status: { type: "boolean" }
                  }
                }
              },
              products: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    name: { type: "string" },
                    status: { type: "boolean" }
                  }
                }
              }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var getSupplierByCnpjSchema = {
  params: {
    type: "object",
    required: ["cnpj"],
    properties: {
      cnpj: { type: "string", minLength: 14 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        corporateName: { type: "string" },
        cnpj: { type: "string" },
        tradeName: { type: "string", nullable: true },
        cep: { type: "string", nullable: true },
        city: { type: "string", nullable: true },
        state: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getSuppliersByCitySchema = {
  params: {
    type: "object",
    required: ["city"],
    properties: {
      city: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var getSuppliersByStateSchema = {
  params: {
    type: "object",
    required: ["state"],
    properties: {
      state: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var searchSuppliersSchema = {
  querystring: {
    type: "object",
    required: ["q"],
    properties: {
      q: { type: "string", minLength: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        suppliers: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              corporateName: { type: "string" },
              cnpj: { type: "string" },
              tradeName: { type: "string", nullable: true },
              cep: { type: "string", nullable: true },
              city: { type: "string", nullable: true },
              state: { type: "string", nullable: true },
              address: { type: "string", nullable: true },
              status: { type: "boolean" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    }
  }
};
var SupplierSchemas = {
  create: createSupplierSchema,
  update: updateSupplierSchema,
  get: getSupplierSchema,
  delete: deleteSupplierSchema,
  list: listSuppliersSchema,
  getByCnpj: getSupplierByCnpjSchema,
  getByCity: getSuppliersByCitySchema,
  getByState: getSuppliersByStateSchema,
  search: searchSuppliersSchema
};

// src/features/supplier/supplier.routes.ts
async function SupplierRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: SupplierSchemas.create,
    handler: SupplierController.create
  });
  fastify2.get("/", {
    schema: SupplierSchemas.list,
    handler: SupplierController.list
  });
  fastify2.get("/:id", {
    schema: SupplierSchemas.get,
    handler: SupplierController.get
  });
  fastify2.put("/:id", {
    schema: SupplierSchemas.update,
    handler: SupplierController.update
  });
  fastify2.delete("/:id", {
    schema: SupplierSchemas.delete,
    handler: SupplierController.delete
  });
  fastify2.get("/cnpj/:cnpj", {
    schema: SupplierSchemas.getByCnpj,
    handler: SupplierController.getByCnpj
  });
  fastify2.get("/city/:city", {
    schema: SupplierSchemas.getByCity,
    handler: SupplierController.getByCity
  });
  fastify2.get("/state/:state", {
    schema: SupplierSchemas.getByState,
    handler: SupplierController.getByState
  });
  fastify2.get("/active", {
    handler: SupplierController.getActive
  });
  fastify2.get("/stats", {
    handler: SupplierController.getStats
  });
  fastify2.get("/search", {
    schema: SupplierSchemas.search,
    handler: SupplierController.search
  });
  fastify2.get("/top", {
    handler: SupplierController.getTopSuppliers
  });
  fastify2.patch("/:id/toggle-status", {
    schema: SupplierSchemas.get,
    handler: SupplierController.toggleStatus
  });
  await fastify2.register(SupplierResponsibleRoutes);
}

// src/features/upload/upload.controller.ts
var import_node_path2 = __toESM(require("path"));
var import_promises = __toESM(require("fs/promises"));
var import_node_os2 = __toESM(require("os"));

// src/features/upload/commands/upload.commands.ts
var UploadCommands = {
  async create(data) {
    const upload = await db.media.create({
      data: {
        url: data.url,
        name: data.name,
        type: data.type,
        size: data.size
      }
    });
    return upload;
  },
  async update(id, data) {
    const upload = await db.media.update({
      where: { id },
      data: {
        ...data.url && { url: data.url },
        ...data.name && { name: data.name },
        ...data.type && { type: data.type },
        ...data.size && { size: data.size }
      }
    });
    return upload;
  },
  async delete(id) {
    await db.productMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.supplierMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.userMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.storeMedia.deleteMany({
      where: { mediaId: id }
    });
    await db.media.delete({
      where: { id }
    });
  },
  async attachToProduct(data) {
    if (data.entityType !== "product") {
      throw new Error("Invalid entity type for product attachment");
    }
    const attachment = await db.productMedia.create({
      data: {
        productId: data.entityId,
        mediaId: data.mediaId,
        isPrimary: data.isPrimary || false
      }
    });
    if (data.isPrimary) {
      await db.productMedia.updateMany({
        where: {
          productId: data.entityId,
          id: { not: attachment.id }
        },
        data: { isPrimary: false }
      });
    }
    return attachment;
  },
  async attachToSupplier(data) {
    if (data.entityType !== "supplier") {
      throw new Error("Invalid entity type for supplier attachment");
    }
    const attachment = await db.supplierMedia.create({
      data: {
        supplierId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async attachToUser(data) {
    if (data.entityType !== "user") {
      throw new Error("Invalid entity type for user attachment");
    }
    const attachment = await db.userMedia.create({
      data: {
        userId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async attachToStore(data) {
    if (data.entityType !== "store") {
      throw new Error("Invalid entity type for store attachment");
    }
    const attachment = await db.storeMedia.create({
      data: {
        storeId: data.entityId,
        mediaId: data.mediaId
      }
    });
    return attachment;
  },
  async detachFromProduct(mediaId, entityId) {
    const attachment = await db.productMedia.findFirst({
      where: {
        mediaId,
        productId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.productMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromSupplier(mediaId, entityId) {
    const attachment = await db.supplierMedia.findFirst({
      where: {
        mediaId,
        supplierId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.supplierMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromUser(mediaId, entityId) {
    const attachment = await db.userMedia.findFirst({
      where: {
        mediaId,
        userId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.userMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async detachFromStore(mediaId, entityId) {
    const attachment = await db.storeMedia.findFirst({
      where: {
        mediaId,
        storeId: entityId
      }
    });
    if (!attachment) {
      throw new Error("Media attachment not found");
    }
    await db.storeMedia.delete({
      where: { id: attachment.id }
    });
    return attachment;
  },
  async setPrimaryForProduct(mediaId, productId) {
    await db.productMedia.updateMany({
      where: {
        productId,
        mediaId: { not: mediaId }
      },
      data: { isPrimary: false }
    });
    const attachment = await db.productMedia.updateMany({
      where: {
        mediaId,
        productId
      },
      data: { isPrimary: true }
    });
    return attachment;
  },
  async bulkDelete(mediaIds) {
    await Promise.all([
      db.productMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.supplierMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.userMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      }),
      db.storeMedia.deleteMany({
        where: { mediaId: { in: mediaIds } }
      })
    ]);
    await db.media.deleteMany({
      where: { id: { in: mediaIds } }
    });
    return { deletedCount: mediaIds.length };
  }
};

// src/features/upload/queries/upload.queries.ts
var UploadQueries = {
  async getById(id) {
    const upload = await db.media.findUnique({
      where: { id }
    });
    if (!upload) {
      throw new Error("Media not found");
    }
    return upload;
  },
  async list(filters) {
    const { page, limit, search, type, entityType, entityId } = filters;
    const skip2 = (page - 1) * limit;
    const where = {};
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { type: { contains: search, mode: "insensitive" } }
      ];
    }
    if (type) {
      where.type = { contains: type, mode: "insensitive" };
    }
    const include = {};
    if (entityType && entityId) {
      switch (entityType) {
        case "product":
          include.productMedia = {
            where: { productId: entityId }
          };
          break;
        case "supplier":
          include.supplierMedia = {
            where: { supplierId: entityId }
          };
          break;
        case "user":
          include.userMedia = {
            where: { userId: entityId }
          };
          break;
        case "store":
          include.storeMedia = {
            where: { storeId: entityId }
          };
          break;
      }
    }
    const [uploads, total] = await Promise.all([
      db.media.findMany({
        where,
        include,
        skip: skip2,
        take: limit,
        orderBy: { createdAt: "desc" }
      }),
      db.media.count({ where })
    ]);
    const filteredUploads = entityType && entityId ? uploads.filter((upload) => {
      switch (entityType) {
        case "product":
          return upload.productMedia && upload.productMedia.length > 0;
        case "supplier":
          return upload.supplierMedia && upload.supplierMedia.length > 0;
        case "user":
          return upload.userMedia && upload.userMedia.length > 0;
        case "store":
          return upload.storeMedia && upload.storeMedia.length > 0;
        default:
          return true;
      }
    }) : uploads;
    return {
      uploads: filteredUploads,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  },
  async getByType(type, limit = 10) {
    const uploads = await db.media.findMany({
      where: {
        type: { contains: type, mode: "insensitive" }
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getRecent(limit = 20) {
    const uploads = await db.media.findMany({
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getEntityMedia(entityType, entityId) {
    let media = [];
    switch (entityType) {
      case "product":
        media = await db.productMedia.findMany({
          where: { productId: entityId },
          include: {
            media: true
          },
          orderBy: [{ isPrimary: "desc" }]
        });
        break;
      case "supplier":
        media = await db.supplierMedia.findMany({
          where: { supplierId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      case "user":
        media = await db.userMedia.findMany({
          where: { userId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      case "store":
        media = await db.storeMedia.findMany({
          where: { storeId: entityId },
          include: {
            media: true
          },
          orderBy: { id: "desc" }
        });
        break;
      default:
        throw new Error("Invalid entity type");
    }
    return media.map((item) => ({
      id: item.id,
      mediaId: item.mediaId,
      entityType,
      entityId,
      isPrimary: "isPrimary" in item ? item.isPrimary : null,
      createdAt: item.createdAt,
      media: item.media
    }));
  },
  async getPrimaryMedia(entityType, entityId) {
    let media = null;
    switch (entityType) {
      case "product": {
        const productMedia = await db.productMedia.findFirst({
          where: {
            productId: entityId,
            isPrimary: true
          },
          include: {
            media: true
          }
        });
        media = productMedia;
        break;
      }
      case "supplier":
      case "user":
      case "store": {
        const firstMedia = await this.getEntityMedia(entityType, entityId);
        media = firstMedia[0] || null;
        break;
      }
      default:
        throw new Error("Invalid entity type");
    }
    return media;
  },
  async search(query, limit = 10) {
    const uploads = await db.media.findMany({
      where: {
        OR: [
          { name: { contains: query, mode: "insensitive" } },
          { type: { contains: query, mode: "insensitive" } }
        ]
      },
      take: limit,
      orderBy: { createdAt: "desc" }
    });
    return uploads;
  },
  async getStats() {
    const [total, byType, recentCount] = await Promise.all([
      db.media.count(),
      db.media.groupBy({
        by: ["type"],
        _count: { type: true },
        orderBy: { _count: { type: "desc" } }
      }),
      db.media.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1e3)
            // ltimas 24h
          }
        }
      })
    ]);
    return {
      total,
      byType: byType.map((item) => ({
        type: item.type || "unknown",
        count: item._count.type
      })),
      recentCount
    };
  },
  async getUnusedMedia(daysOld = 30) {
    const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1e3);
    const unusedMedia = await db.media.findMany({
      where: {
        createdAt: { lt: cutoffDate },
        AND: [
          { productMedia: { none: {} } },
          { supplierMedia: { none: {} } },
          { userMedia: { none: {} } },
          { storeMedia: { none: {} } }
        ]
      },
      orderBy: { createdAt: "asc" }
    });
    return unusedMedia;
  },
  async getMediaUsage(mediaId) {
    const [productUsage, supplierUsage, userUsage, storeUsage] = await Promise.all([
      db.productMedia.findMany({
        where: { mediaId },
        include: {
          product: {
            select: { id: true, name: true }
          }
        }
      }),
      db.supplierMedia.findMany({
        where: { mediaId },
        include: {
          supplier: {
            select: { id: true, corporateName: true }
          }
        }
      }),
      db.userMedia.findMany({
        where: { mediaId },
        include: {
          user: {
            select: { id: true, name: true, email: true }
          }
        }
      }),
      db.storeMedia.findMany({
        where: { mediaId },
        include: {
          store: {
            select: { id: true, name: true }
          }
        }
      })
    ]);
    return {
      products: productUsage,
      suppliers: supplierUsage,
      users: userUsage,
      stores: storeUsage,
      totalUsage: productUsage.length + supplierUsage.length + userUsage.length + storeUsage.length
    };
  },
  async getAllUsedFilePaths() {
    const media = await db.media.findMany({
      select: { url: true }
    });
    return media.map((m) => m.url);
  }
};

// src/features/upload/upload.service.ts
var import_node_crypto3 = require("crypto");
var import_node_fs = require("fs");
var import_node_path = __toESM(require("path"));
var UPLOAD_DIR = import_node_path.default.join(process.cwd(), "src", "uploads");
var MAX_FILE_SIZE = 10 * 1024 * 1024;
var ALLOWED_TYPES = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/svg+xml",
  "application/pdf",
  "application/msword",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "text/plain"
];
var UploadService = class _UploadService {
  constructor() {
    this.uploadDir = UPLOAD_DIR;
    this.ensureUploadDirectories();
  }
  static getInstance() {
    if (!_UploadService.instance) {
      _UploadService.instance = new _UploadService();
    }
    return _UploadService.instance;
  }
  // === INICIALIZAO ===
  async ensureUploadDirectories() {
    const directories = [
      UPLOAD_DIR,
      import_node_path.default.join(UPLOAD_DIR, "product"),
      import_node_path.default.join(UPLOAD_DIR, "supplier"),
      import_node_path.default.join(UPLOAD_DIR, "user"),
      import_node_path.default.join(UPLOAD_DIR, "store"),
      import_node_path.default.join(UPLOAD_DIR, "general")
    ];
    for (const dir of directories) {
      try {
        await import_node_fs.promises.access(dir);
      } catch {
        await import_node_fs.promises.mkdir(dir, { recursive: true });
      }
    }
  }
  // === CRIAR DIRETRIO DO USURIO ===
  async ensureUserDirectory(userId) {
    const userDir = import_node_path.default.join(UPLOAD_DIR, "users", userId);
    try {
      await import_node_fs.promises.access(userDir);
    } catch {
      await import_node_fs.promises.mkdir(userDir, { recursive: true });
    }
    return userDir;
  }
  // === VALIDAO ===
  validateFile(file, config = {}) {
    const allowedTypes = config.allowedTypes || ALLOWED_TYPES;
    const maxFileSize = config.maxFileSize || MAX_FILE_SIZE;
    if (!allowedTypes.includes(file.mimetype)) {
      throw new Error(`Tipo de arquivo n\xE3o permitido: ${file.mimetype}`);
    }
    if (file.size > maxFileSize) {
      throw new Error(`Arquivo muito grande. M\xE1ximo permitido: ${maxFileSize / 1024 / 1024}MB`);
    }
  }
  // === GERAR NOME NICO ===
  generateUniqueFilename(originalName) {
    const ext = import_node_path.default.extname(originalName);
    const name = import_node_path.default.basename(originalName, ext);
    const uuid = (0, import_node_crypto3.randomUUID)();
    return `${name}-${uuid}${ext}`;
  }
  // === UPLOAD NICO ===
  async uploadSingle(file, config = {}) {
    try {
      this.validateFile(file, config);
      if (!file.path || typeof file.path !== "string") {
        throw new Error("Caminho do arquivo inv\xE1lido ou n\xE3o fornecido");
      }
      try {
        await import_node_fs.promises.access(file.path);
      } catch (error) {
        throw new Error(`Arquivo tempor\xE1rio n\xE3o encontrado: ${file.path} ${error}`);
      }
      const entityType = config.entityType || "general";
      let destinationDir;
      let publicUrl;
      if (config.userId) {
        const userDir = await this.ensureUserDirectory(config.userId);
        destinationDir = import_node_path.default.join(userDir, entityType);
        try {
          await import_node_fs.promises.access(destinationDir);
        } catch {
          await import_node_fs.promises.mkdir(destinationDir, { recursive: true });
        }
        publicUrl = `/uploads/users/${config.userId}/${entityType}`;
      } else {
        destinationDir = import_node_path.default.join(this.uploadDir, entityType);
        publicUrl = `/uploads/${entityType}`;
      }
      const uniqueFilename = this.generateUniqueFilename(file.originalname);
      const destination = import_node_path.default.join(destinationDir, uniqueFilename);
      await import_node_fs.promises.copyFile(file.path, destination);
      publicUrl = `${publicUrl}/${uniqueFilename}`;
      const result = {
        id: (0, import_node_crypto3.randomUUID)(),
        url: publicUrl,
        name: file.originalname,
        type: file.mimetype,
        size: file.size,
        path: destination
      };
      return result;
    } catch (error) {
      throw new Error(`Erro no upload: ${error.message}`);
    }
  }
  // === UPLOAD MLTIPLOS ===
  async uploadMultiple(files, config = {}) {
    const maxFiles = config.maxFiles || 10;
    if (files.length > maxFiles) {
      throw new Error(`M\xE1ximo de ${maxFiles} arquivos permitidos`);
    }
    const results = [];
    for (const file of files) {
      try {
        const result = await this.uploadSingle(file, config);
        results.push(result);
      } catch (error) {
        await this.cleanupFailedUploads(results);
        throw error;
      }
    }
    return results;
  }
  // === LIMPEZA DE ARQUIVOS FALHADOS ===
  async cleanupFailedUploads(uploadedFiles) {
    for (const file of uploadedFiles) {
      try {
        await import_node_fs.promises.unlink(file.path);
      } catch (error) {
        console.error(`Erro ao deletar arquivo ${file.path}:`, error);
      }
    }
  }
  // === DELETAR ARQUIVO ===
  async deleteFile(filePath) {
    try {
      await import_node_fs.promises.unlink(filePath);
    } catch (error) {
      throw new Error(`Erro ao deletar arquivo: ${error.message}`);
    }
  }
  // === DELETAR MLTIPLOS ARQUIVOS ===
  async deleteMultipleFiles(filePaths) {
    let deleted = 0;
    let failed = 0;
    for (const filePath of filePaths) {
      try {
        await this.deleteFile(filePath);
        deleted++;
      } catch (error) {
        failed++;
        console.error(`Erro ao deletar ${filePath}:`, error);
      }
    }
    return { deleted, failed };
  }
  // === OBTER INFORMAES DO ARQUIVO ===
  async getFileInfo(filePath) {
    try {
      const stats = await import_node_fs.promises.stat(filePath);
      return {
        exists: true,
        size: stats.size,
        stats
      };
    } catch (error) {
      console.error(error);
      return { exists: false };
    }
  }
  // === LISTAR ARQUIVOS DE UMA ENTIDADE ===
  async listEntityFiles(entityType) {
    try {
      const entityDir = import_node_path.default.join(this.uploadDir, entityType);
      const files = await import_node_fs.promises.readdir(entityDir);
      return files.filter((file) => {
        const filePath = import_node_path.default.join(entityDir, file);
        const stats = import_node_fs.promises.stat(filePath);
        return stats.then((s) => s.isFile()).catch(() => false);
      });
    } catch (error) {
      console.error(error);
      throw new Error(`Erro ao listar arquivos da entidade: ${error.message}`);
    }
  }
  // === LIMPEZA DE ARQUIVOS RFOS ===
  async cleanupOrphanedFiles(usedFilePaths) {
    const allFiles = [];
    const directories = ["product", "supplier", "user", "store", "general"];
    for (const dir of directories) {
      const files = await this.listEntityFiles(dir);
      allFiles.push(...files.map((file) => import_node_path.default.join(this.uploadDir, dir, file)));
    }
    const orphanedFiles = allFiles.filter((file) => !usedFilePaths.includes(file));
    return await this.deleteMultipleFiles(orphanedFiles);
  }
  // === OBTER ESTATSTICAS ===
  async getStats() {
    const stats = {
      totalFiles: 0,
      totalSize: 0,
      byEntityType: {},
      byFileType: {}
    };
    const directories = ["product", "supplier", "user", "store", "general"];
    for (const dir of directories) {
      const files = await this.listEntityFiles(dir);
      let dirSize = 0;
      for (const file of files) {
        const filePath = import_node_path.default.join(this.uploadDir, dir, file);
        const fileInfo = await this.getFileInfo(filePath);
        if (fileInfo.exists && fileInfo.size) {
          dirSize += fileInfo.size;
          stats.totalSize += fileInfo.size;
          stats.totalFiles++;
          const ext = import_node_path.default.extname(file).toLowerCase();
          stats.byFileType[ext] = (stats.byFileType[ext] || 0) + 1;
        }
      }
      stats.byEntityType[dir] = {
        count: files.length,
        size: dirSize
      };
    }
    return stats;
  }
  // === UTILITRIOS ===
  // Verificar se  imagem
  isImage(mimetype) {
    return mimetype.startsWith("image/");
  }
  // Verificar se  vdeo
  isVideo(mimetype) {
    return mimetype.startsWith("video/");
  }
  // Verificar se  documento
  isDocument(mimetype) {
    const documentTypes = [
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.ms-excel",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "text/plain"
    ];
    return documentTypes.includes(mimetype);
  }
  // Formatar tamanho do arquivo
  formatFileSize(bytes) {
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${Math.round(bytes / 1024 ** i * 100) / 100} ${sizes[i]}`;
  }
  // Obter cone baseado no tipo
  getUploadDir() {
    return this.uploadDir;
  }
  getFileIcon(mimetype) {
    if (mimetype.startsWith("image/")) return "\u{1F5BC}\uFE0F";
    if (mimetype.startsWith("video/")) return "\u{1F3A5}";
    if (mimetype.startsWith("audio/")) return "\u{1F3B5}";
    if (mimetype === "application/pdf") return "\u{1F4D5}";
    if (mimetype.includes("word")) return "\u{1F4DD}";
    if (mimetype.includes("excel") || mimetype.includes("spreadsheet")) return "\u{1F4CA}";
    if (mimetype.includes("powerpoint") || mimetype.includes("presentation")) return "\u{1F4FD}\uFE0F";
    if (mimetype.includes("zip") || mimetype.includes("rar")) return "\u{1F4E6}";
    return "\u{1F4C4}";
  }
};
var uploadService = UploadService.getInstance();

// src/features/upload/upload.controller.ts
var UploadController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const { name, type, size } = request.body;
      const result = await UploadCommands.create({
        url: "",
        // Ser preenchida pelo service
        name,
        type,
        size
      });
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await UploadQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await UploadCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Validation error") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      const media = await UploadQueries.getById(id);
      if (!media) {
        return reply.status(404).send({
          error: "Media not found"
        });
      }
      await UploadCommands.delete(id);
      try {
        const filePath = import_node_path2.default.join(
          process.cwd(),
          "src",
          "uploads",
          media.url.replace("/uploads/", "")
        );
        await uploadService.deleteFile(filePath);
      } catch {
        request.log.warn(`Arquivo f\xEDsico n\xE3o encontrado: ${media.url}`);
      }
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, type, entityType, entityId } = request.query;
      const result = await UploadQueries.list({
        page,
        limit,
        search,
        type,
        entityType,
        entityId
      });
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const responseData = {
        ...result,
        uploads: result.uploads?.map((upload) => ({
          ...upload,
          fullUrl: `${protocol}://${host}${upload.url}`
        })) || []
      };
      return reply.send(responseData);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getByType(request, reply) {
    try {
      const { type, limit = 10 } = request.query;
      const result = await UploadQueries.getByType(type, limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getRecent(request, reply) {
    try {
      const { limit = 20 } = request.query;
      const result = await UploadQueries.getRecent(limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getEntityMedia(request, reply) {
    try {
      const { entityType, entityId } = request.params;
      const result = await UploadQueries.getEntityMedia(entityType, entityId);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const mediaWithFullUrl = result.map((media) => ({
        ...media,
        fullUrl: `${protocol}://${host}${media.url}`
      }));
      return reply.send({ media: mediaWithFullUrl });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getPrimaryMedia(request, reply) {
    try {
      const { entityType, entityId } = request.params;
      const result = await UploadQueries.getPrimaryMedia(entityType, entityId);
      if (!result) {
        return reply.status(404).send({
          error: "No media found"
        });
      }
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const resultWithFullUrl = {
        ...result,
        fullUrl: `${protocol}://${host}${result.url}`
      };
      return reply.send(resultWithFullUrl);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await UploadQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await UploadQueries.search(q, limit);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getMediaUsage(request, reply) {
    try {
      const { id } = request.params;
      const result = await UploadQueries.getMediaUsage(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getUnusedMedia(request, reply) {
    try {
      const { daysOld = 30 } = request.query;
      const result = await UploadQueries.getUnusedMedia(daysOld);
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const uploadsWithFullUrl = result.map((upload) => ({
        ...upload,
        fullUrl: `${protocol}://${host}${upload.url}`
      }));
      return reply.send({ uploads: uploadsWithFullUrl });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async attachMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId, isPrimary } = request.body;
      let result;
      switch (entityType) {
        case "product":
          result = await UploadCommands.attachToProduct({
            mediaId: id,
            entityType,
            entityId,
            isPrimary
          });
          break;
        case "supplier":
          result = await UploadCommands.attachToSupplier({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        case "user":
          result = await UploadCommands.attachToUser({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        case "store":
          result = await UploadCommands.attachToStore({
            mediaId: id,
            entityType,
            entityId
          });
          break;
        default:
          return reply.status(400).send({
            error: "Invalid entity type"
          });
      }
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "Invalid entity type for attachment") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async detachMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId } = request.body;
      switch (entityType) {
        case "product":
          await UploadCommands.detachFromProduct(id, entityId);
          break;
        case "supplier":
          await UploadCommands.detachFromSupplier(id, entityId);
          break;
        case "user":
          await UploadCommands.detachFromUser(id, entityId);
          break;
        case "store":
          await UploadCommands.detachFromStore(id, entityId);
          break;
        default:
          return reply.status(400).send({
            error: "Invalid entity type"
          });
      }
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media attachment not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async setPrimaryMedia(request, reply) {
    try {
      const { id } = request.params;
      const { entityType, entityId } = request.body;
      if (entityType === "product") {
        await UploadCommands.setPrimaryForProduct(id, entityId);
      } else {
        return reply.status(400).send({
          error: "Primary media is only supported for products"
        });
      }
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      if (error.message === "Media not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async bulkDelete(request, reply) {
    try {
      const { mediaIds } = request.body;
      const result = await UploadCommands.bulkDelete(mediaIds);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === UPLOAD DE ARQUIVOS FSICOS ===
  async uploadSingle(request, reply) {
    try {
      const data = await request.file();
      if (!data) {
        return reply.status(400).send({
          error: "Nenhum arquivo enviado"
        });
      }
      console.log(
        "Estrutura do objeto data:",
        JSON.stringify(
          {
            fieldname: data.fieldname,
            filename: data.filename,
            mimetype: data.mimetype,
            encoding: data.encoding,
            hasFile: !!data.file,
            fileKeys: data.file ? Object.keys(data.file) : "no file object",
            filePath: data.file?.path,
            fileFilename: data.file?.filename,
            // Verificar se  um stream
            isStream: data.file?.toBuffer ? "yes" : "no",
            // Verificar outras propriedades possveis
            allKeys: Object.keys(data)
          },
          null,
          2
        )
      );
      const { entityType = "general" } = request.body || request.query;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Usu\xE1rio n\xE3o autenticado"
        });
      }
      let filePath;
      let fileSize = 0;
      if (data.toBuffer) {
        console.log("Convertendo stream para buffer usando data.toBuffer...");
        const buffer = await data.toBuffer();
        fileSize = buffer.length;
        const tempPath = import_node_path2.default.join(import_node_os2.default.tmpdir(), `temp-${Date.now()}-${data.filename}`);
        await import_promises.default.writeFile(tempPath, buffer);
        filePath = tempPath;
        console.log(`Arquivo tempor\xE1rio criado: ${tempPath}`);
      } else if (data.file?.toBuffer) {
        console.log("Convertendo stream para buffer usando data.file.toBuffer...");
        const buffer = await data.file.toBuffer();
        fileSize = buffer.length;
        const tempPath = import_node_path2.default.join(import_node_os2.default.tmpdir(), `temp-${Date.now()}-${data.filename}`);
        await import_promises.default.writeFile(tempPath, buffer);
        filePath = tempPath;
        console.log(`Arquivo tempor\xE1rio criado: ${tempPath}`);
      } else if (data.file?.bytesRead) {
        filePath = data.file.path || data.file.filepath || data.file.filename;
        fileSize = data.file.bytesRead;
      } else {
        filePath = data.path || data.filepath || data.filename;
        fileSize = data.size || data.bytesRead || 0;
      }
      const fileData = {
        fieldname: data.fieldname || "file",
        filename: data.filename || "unknown",
        originalname: data.filename || "unknown",
        encoding: data.encoding || "7bit",
        mimetype: data.mimetype || "application/octet-stream",
        size: fileSize,
        destination: "",
        // Ser definido pelo service
        path: filePath,
        url: ""
        // Ser definido pelo service
      };
      if (!fileData.path) {
        console.error("Estrutura completa do data:", JSON.stringify(data, null, 2));
        return reply.status(400).send({
          error: "N\xE3o foi poss\xEDvel determinar o caminho do arquivo. Estrutura do objeto inesperada."
        });
      }
      const uploadResult = await uploadService.uploadSingle(fileData, {
        entityType,
        userId
      });
      const dbResult = await UploadCommands.create({
        url: uploadResult.url,
        name: uploadResult.name,
        type: uploadResult.type,
        size: uploadResult.size
      });
      if (filePath?.includes("temp-")) {
        try {
          await import_promises.default.unlink(filePath);
          console.log(`Arquivo tempor\xE1rio removido: ${filePath}`);
        } catch (cleanupError) {
          console.warn(`Erro ao remover arquivo tempor\xE1rio ${filePath}:`, cleanupError);
        }
      }
      const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
      const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
      const fullUrl = `${protocol}://${host}${uploadResult.url}`;
      return reply.status(201).send({
        ...dbResult,
        path: uploadResult.path,
        fullUrl
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("n\xE3o permitido") || error.message.includes("muito grande")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async uploadMultiple(request, reply) {
    try {
      const files = request.files();
      const uploadedFiles = [];
      const { entityType = "general", maxFiles = 10 } = request.body || request.query;
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "Usu\xE1rio n\xE3o autenticado"
        });
      }
      for await (const file of files) {
        if (file.file) {
          const fileData = {
            fieldname: file.fieldname,
            filename: file.filename,
            originalname: file.filename,
            encoding: file.encoding,
            mimetype: file.mimetype,
            size: file.file.bytesRead,
            destination: "",
            // Ser definido pelo service
            path: file.file.path || file.file.filename,
            // Usar filename se path no estiver disponvel
            url: ""
            // Ser definido pelo service
          };
          uploadedFiles.push(fileData);
        }
      }
      if (uploadedFiles.length === 0) {
        return reply.status(400).send({
          error: "Nenhum arquivo v\xE1lido enviado"
        });
      }
      const uploadResults = await uploadService.uploadMultiple(uploadedFiles, {
        entityType,
        userId,
        maxFiles
      });
      const dbResults = [];
      for (const uploadResult of uploadResults) {
        const dbResult = await UploadCommands.create({
          url: uploadResult.url,
          name: uploadResult.name,
          type: uploadResult.type,
          size: uploadResult.size
        });
        const protocol = request.headers["x-forwarded-proto"] || request.server.https ? "https" : "http";
        const host = request.headers["x-forwarded-host"] || request.headers.host || "localhost:3000";
        const fullUrl = `${protocol}://${host}${uploadResult.url}`;
        dbResults.push({
          ...dbResult,
          path: uploadResult.path,
          fullUrl
        });
      }
      return reply.status(201).send({
        uploads: dbResults,
        count: dbResults.length
      });
    } catch (error) {
      request.log.error(error);
      if (error.message.includes("n\xE3o permitido") || error.message.includes("muito grande") || error.message.includes("M\xE1ximo")) {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === SERVIOS DE MANUTENO ===
  async cleanupOrphanedFiles(request, reply) {
    try {
      const usedFiles = await UploadQueries.getAllUsedFilePaths();
      const result = await uploadService.cleanupOrphanedFiles(usedFiles);
      return reply.send({
        message: "Limpeza conclu\xEDda",
        ...result
      });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getServiceConfig(request, reply) {
    try {
      const config = {
        maxFileSize: 10 * 1024 * 1024,
        // 10MB
        maxFiles: 10,
        allowedTypes: [
          "image/jpeg",
          "image/png",
          "image/gif",
          "image/webp",
          "image/svg+xml",
          "application/pdf",
          "application/msword",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          "application/vnd.ms-excel",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          "text/plain"
        ],
        uploadDir: uploadService.getUploadDir(),
        entityTypes: ["product", "supplier", "user", "store", "general"]
      };
      return reply.send(config);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getFileSystemStats(request, reply) {
    try {
      const stats = await uploadService.getStats();
      return reply.send(stats);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/upload/upload.schema.ts
var createUploadSchema = {
  body: {
    type: "object",
    properties: {
      name: { type: "string", minLength: 1, maxLength: 255 },
      type: { type: "string", minLength: 1, maxLength: 100 },
      size: { type: "number", minimum: 0 }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        url: { type: "string" },
        name: { type: "string", nullable: true },
        type: { type: "string", nullable: true },
        size: { type: "number", nullable: true },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    400: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listUploadsSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      type: { type: "string" },
      entityType: {
        type: "string",
        enum: ["product", "supplier", "user", "store"]
      },
      entityId: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        uploads: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              url: { type: "string" },
              name: { type: "string", nullable: true },
              type: { type: "string", nullable: true },
              size: { type: "number", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getEntityMediaSchema = {
  params: {
    type: "object",
    required: ["entityType", "entityId"],
    properties: {
      entityType: {
        type: "string",
        enum: ["product", "supplier", "user", "store"]
      },
      entityId: { type: "string", minLength: 1 }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        media: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              mediaId: { type: "string" },
              entityType: { type: "string" },
              entityId: { type: "string" },
              isPrimary: { type: "boolean", nullable: true },
              createdAt: { type: "string", format: "date-time" },
              media: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  url: { type: "string" },
                  name: { type: "string", nullable: true },
                  type: { type: "string", nullable: true },
                  size: { type: "number", nullable: true }
                }
              }
            }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};

// src/features/upload/upload.route.ts
async function UploadRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  await fastify2.register(require("@fastify/multipart"), {
    limits: {
      fileSize: 10 * 1024 * 1024,
      // 10MB
      files: 10
      // mximo 10 arquivos por request
    },
    attachFieldsToBody: false,
    // Manter arquivos separados do body
    sharedSchemaId: "MultipartFileType"
    // Schema para validao
  });
  fastify2.post("/", {
    schema: createUploadSchema,
    handler: UploadController.create
  });
  fastify2.get("/", {
    schema: listUploadsSchema,
    handler: UploadController.list
  });
  fastify2.get("/:id", {
    handler: UploadController.get
  });
  fastify2.put("/:id", {
    handler: UploadController.update
  });
  fastify2.delete("/:id", {
    handler: UploadController.delete
  });
  fastify2.post("/upload", {
    handler: UploadController.uploadSingle
  });
  fastify2.post("/upload-multiple", {
    handler: UploadController.uploadMultiple
  });
  fastify2.get("/type/:type", {
    handler: UploadController.getByType
  });
  fastify2.get("/recent", {
    handler: UploadController.getRecent
  });
  fastify2.get("/stats", {
    handler: UploadController.getStats
  });
  fastify2.get("/search", {
    handler: UploadController.search
  });
  fastify2.get("/:id/usage", {
    handler: UploadController.getMediaUsage
  });
  fastify2.get("/unused", {
    handler: UploadController.getUnusedMedia
  });
  fastify2.post("/:id/attach", {
    handler: UploadController.attachMedia
  });
  fastify2.post("/:id/detach", {
    handler: UploadController.detachMedia
  });
  fastify2.patch("/:id/set-primary", {
    handler: UploadController.setPrimaryMedia
  });
  fastify2.get("/entity/:entityType/:entityId", {
    schema: getEntityMediaSchema,
    handler: UploadController.getEntityMedia
  });
  fastify2.get("/entity/:entityType/:entityId/primary", {
    handler: UploadController.getPrimaryMedia
  });
  fastify2.post("/bulk-delete", {
    handler: UploadController.bulkDelete
  });
  fastify2.post("/cleanup-orphaned", {
    handler: UploadController.cleanupOrphanedFiles
  });
  fastify2.get("/service/config", {
    handler: UploadController.getServiceConfig
  });
  fastify2.get("/service/stats", {
    handler: UploadController.getFileSystemStats
  });
}

// src/features/user-preferences/commands/user-preferences.commands.ts
var UserPreferencesCommands = {
  async create(data) {
    try {
      const user = await db.user.findUnique({
        where: { id: data.userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId: data.userId }
      });
      if (existingPreferences) {
        throw new Error("User preferences already exist for this user");
      }
      const preferences = await db.userPreferences.create({
        data: {
          userId: data.userId,
          theme: data.theme || "light",
          primaryColor: data.primaryColor,
          sidebarCollapsed: data.sidebarCollapsed || false,
          compactMode: data.compactMode || false,
          language: data.language || "pt-BR",
          currency: data.currency || "BRL",
          timezone: data.timezone || "America/Sao_Paulo",
          dateFormat: data.dateFormat || "DD/MM/YYYY",
          timeFormat: data.timeFormat || "24h",
          numberFormat: data.numberFormat || "pt-BR",
          emailNotifications: data.emailNotifications !== void 0 ? data.emailNotifications : true,
          pushNotifications: data.pushNotifications !== void 0 ? data.pushNotifications : true,
          smsNotifications: data.smsNotifications || false,
          notificationTypes: data.notificationTypes,
          dashboardLayout: data.dashboardLayout,
          defaultPage: data.defaultPage,
          itemsPerPage: data.itemsPerPage || 20,
          autoRefresh: data.autoRefresh !== void 0 ? data.autoRefresh : true,
          refreshInterval: data.refreshInterval || 30,
          customSettings: data.customSettings
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to create user preferences: ${error.message}`);
    }
  },
  // ================================
  // UPDATE OPERATIONS
  // ================================
  async update(id, data) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const updatedPreferences = await db.userPreferences.update({
        where: { id },
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return updatedPreferences;
    } catch (error) {
      throw new Error(`Failed to update user preferences: ${error.message}`);
    }
  },
  async updateByUserId(userId, data) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        return await UserPreferencesCommands.create({ ...data, userId });
      }
      const updatedPreferences = await db.userPreferences.update({
        where: { userId },
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return updatedPreferences;
    } catch (error) {
      throw new Error(`Failed to update user preferences: ${error.message}`);
    }
  },
  // ================================
  // DELETE OPERATIONS
  // ================================
  async delete(id) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      await db.userPreferences.delete({
        where: { id }
      });
      return { success: true, message: "User preferences deleted successfully" };
    } catch (error) {
      throw new Error(`Failed to delete user preferences: ${error.message}`);
    }
  },
  async deleteByUserId(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      await db.userPreferences.delete({
        where: { userId }
      });
      return { success: true, message: "User preferences deleted successfully" };
    } catch (error) {
      throw new Error(`Failed to delete user preferences: ${error.message}`);
    }
  },
  // ================================
  // RESET OPERATIONS
  // ================================
  async resetToDefaults(id) {
    try {
      const existingPreferences = await db.userPreferences.findUnique({
        where: { id }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const resetPreferences = await db.userPreferences.update({
        where: { id },
        data: {
          theme: "light",
          primaryColor: null,
          sidebarCollapsed: false,
          compactMode: false,
          language: "pt-BR",
          currency: "BRL",
          timezone: "America/Sao_Paulo",
          dateFormat: "DD/MM/YYYY",
          timeFormat: "24h",
          numberFormat: "pt-BR",
          emailNotifications: true,
          pushNotifications: true,
          smsNotifications: false,
          notificationTypes: null,
          dashboardLayout: null,
          defaultPage: null,
          itemsPerPage: 20,
          autoRefresh: true,
          refreshInterval: 30,
          customSettings: null,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return resetPreferences;
    } catch (error) {
      throw new Error(`Failed to reset user preferences: ${error.message}`);
    }
  },
  async resetToDefaultsByUserId(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user) {
        throw new Error("User not found");
      }
      const existingPreferences = await db.userPreferences.findUnique({
        where: { userId }
      });
      if (!existingPreferences) {
        throw new Error("User preferences not found");
      }
      const resetPreferences = await db.userPreferences.update({
        where: { userId },
        data: {
          theme: "light",
          primaryColor: null,
          sidebarCollapsed: false,
          compactMode: false,
          language: "pt-BR",
          currency: "BRL",
          timezone: "America/Sao_Paulo",
          dateFormat: "DD/MM/YYYY",
          timeFormat: "24h",
          numberFormat: "pt-BR",
          emailNotifications: true,
          pushNotifications: true,
          smsNotifications: false,
          notificationTypes: null,
          dashboardLayout: null,
          defaultPage: null,
          itemsPerPage: 20,
          autoRefresh: true,
          refreshInterval: 30,
          customSettings: null,
          updatedAt: /* @__PURE__ */ new Date()
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return resetPreferences;
    } catch (error) {
      throw new Error(`Failed to reset user preferences: ${error.message}`);
    }
  },
  // ================================
  // BULK OPERATIONS
  // ================================
  async bulkUpdate(filters, data) {
    try {
      const result = await db.userPreferences.updateMany({
        where: filters,
        data: {
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      return {
        success: true,
        count: result.count,
        message: `${result.count} user preferences updated successfully`
      };
    } catch (error) {
      throw new Error(`Failed to bulk update user preferences: ${error.message}`);
    }
  },
  async bulkDelete(filters) {
    try {
      const result = await db.userPreferences.deleteMany({
        where: filters
      });
      return {
        success: true,
        count: result.count,
        message: `${result.count} user preferences deleted successfully`
      };
    } catch (error) {
      throw new Error(`Failed to bulk delete user preferences: ${error.message}`);
    }
  }
};

// src/features/user-preferences/queries/user-preferences.query.ts
var UserPreferencesQueries = {
  // ================================
  // GET OPERATIONS
  // ================================
  async getById(id) {
    try {
      const preferences = await db.userPreferences.findUnique({
        where: { id },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        throw new Error("User preferences not found");
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences: ${error.message}`);
    }
  },
  async getByUserId(userId) {
    try {
      const preferences = await db.userPreferences.findUnique({
        where: { userId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        throw new Error("User preferences not found");
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences: ${error.message}`);
    }
  },
  async getByUserIdOrCreate(userId) {
    try {
      const user = await db.user.findUnique({
        where: { id: userId },
        select: { id: true, name: true, email: true }
      });
      if (!user) {
        throw new Error("User not found");
      }
      let preferences = await db.userPreferences.findUnique({
        where: { userId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      if (!preferences) {
        preferences = await db.userPreferences.create({
          data: {
            userId,
            theme: "light",
            language: "pt-BR",
            currency: "BRL",
            timezone: "America/Sao_Paulo",
            dateFormat: "DD/MM/YYYY",
            timeFormat: "24h",
            numberFormat: "pt-BR",
            emailNotifications: true,
            pushNotifications: true,
            smsNotifications: false,
            itemsPerPage: 20,
            autoRefresh: true,
            refreshInterval: 30
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        });
      }
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get or create user preferences: ${error.message}`);
    }
  },
  // ================================
  // LIST OPERATIONS
  // ================================
  async list(filters = {}) {
    try {
      const {
        page = 1,
        limit = 10,
        search,
        theme,
        language,
        currency,
        timezone,
        hasCustomSettings,
        notificationsEnabled
      } = filters;
      const skip2 = (page - 1) * limit;
      const where = {};
      if (search) {
        where.OR = [
          {
            user: {
              name: {
                contains: search,
                mode: "insensitive"
              }
            }
          },
          {
            user: {
              email: {
                contains: search,
                mode: "insensitive"
              }
            }
          }
        ];
      }
      if (theme) {
        where.theme = theme;
      }
      if (language) {
        where.language = language;
      }
      if (currency) {
        where.currency = currency;
      }
      if (timezone) {
        where.timezone = timezone;
      }
      if (hasCustomSettings !== void 0) {
        if (hasCustomSettings) {
          where.customSettings = {
            not: null
          };
        } else {
          where.customSettings = null;
        }
      }
      if (notificationsEnabled !== void 0) {
        where.emailNotifications = notificationsEnabled;
      }
      const [preferences, total] = await Promise.all([
        db.userPreferences.findMany({
          where,
          skip: skip2,
          take: limit,
          orderBy: {
            updatedAt: "desc"
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true
              }
            }
          }
        }),
        db.userPreferences.count({ where })
      ]);
      return {
        preferences,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        }
      };
    } catch (error) {
      throw new Error(`Failed to list user preferences: ${error.message}`);
    }
  },
  // ================================
  // SEARCH OPERATIONS
  // ================================
  async search(searchTerm, limit = 10) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: {
          OR: [
            {
              user: {
                name: {
                  contains: searchTerm,
                  mode: "insensitive"
                }
              }
            },
            {
              user: {
                email: {
                  contains: searchTerm,
                  mode: "insensitive"
                }
              }
            },
            {
              language: {
                contains: searchTerm,
                mode: "insensitive"
              }
            },
            {
              currency: {
                contains: searchTerm,
                mode: "insensitive"
              }
            }
          ]
        },
        take: limit,
        orderBy: {
          updatedAt: "desc"
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to search user preferences: ${error.message}`);
    }
  },
  // ================================
  // STATS OPERATIONS
  // ================================
  async getStats() {
    try {
      const [
        totalPreferences,
        themeStats,
        languageStats,
        currencyStats,
        itemsPerPageStats,
        notificationsStats
      ] = await Promise.all([
        db.userPreferences.count(),
        db.userPreferences.groupBy({
          by: ["theme"],
          _count: {
            theme: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["language"],
          _count: {
            language: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["currency"],
          _count: {
            currency: true
          }
        }),
        db.userPreferences.aggregate({
          _avg: {
            itemsPerPage: true
          }
        }),
        db.userPreferences.groupBy({
          by: ["emailNotifications"],
          _count: {
            emailNotifications: true
          }
        })
      ]);
      const themeDistribution = {
        light: 0,
        dark: 0,
        auto: 0
      };
      for (const stat of themeStats) {
        if (stat.theme === "light") themeDistribution.light = stat._count.theme;
        if (stat.theme === "dark") themeDistribution.dark = stat._count.theme;
        if (stat.theme === "auto") themeDistribution.auto = stat._count.theme;
      }
      const languageDistribution = {};
      for (const stat of languageStats) {
        languageDistribution[stat.language] = stat._count.language;
      }
      const currencyDistribution = {};
      for (const stat of currencyStats) {
        currencyDistribution[stat.currency] = stat._count.currency;
      }
      let notificationsEnabled = 0;
      let notificationsDisabled = 0;
      for (const stat of notificationsStats) {
        if (stat.emailNotifications) {
          notificationsEnabled = stat._count.emailNotifications;
        } else {
          notificationsDisabled = stat._count.emailNotifications;
        }
      }
      return {
        totalPreferences,
        themeDistribution,
        languageDistribution,
        currencyDistribution,
        averageItemsPerPage: Math.round(itemsPerPageStats._avg.itemsPerPage || 20),
        notificationsEnabled,
        notificationsDisabled
      };
    } catch (error) {
      throw new Error(`Failed to get user preferences stats: ${error.message}`);
    }
  },
  // ================================
  // FILTER OPERATIONS
  // ================================
  async getByTheme(theme) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { theme },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by theme: ${error.message}`);
    }
  },
  async getByLanguage(language) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { language },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by language: ${error.message}`);
    }
  },
  async getByCurrency(currency) {
    try {
      const preferences = await db.userPreferences.findMany({
        where: { currency },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences by currency: ${error.message}`);
    }
  },
  async getWithCustomSettings() {
    try {
      const preferences = await db.userPreferences.findMany({
        where: {
          customSettings: {
            not: null
          }
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: {
          updatedAt: "desc"
        }
      });
      return preferences;
    } catch (error) {
      throw new Error(`Failed to get user preferences with custom settings: ${error.message}`);
    }
  },
  // ================================
  // VALIDATION OPERATIONS
  // ================================
  async validatePreferences(data) {
    try {
      const errors = [];
      const warnings = [];
      if (data.theme && !["light", "dark", "auto"].includes(data.theme)) {
        errors.push("Theme must be one of: light, dark, auto");
      }
      if (data.dateFormat && !["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"].includes(data.dateFormat)) {
        errors.push("Date format must be one of: DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD");
      }
      if (data.timeFormat && !["12h", "24h"].includes(data.timeFormat)) {
        errors.push("Time format must be one of: 12h, 24h");
      }
      if (data.itemsPerPage && (data.itemsPerPage < 5 || data.itemsPerPage > 100)) {
        warnings.push("Items per page should be between 5 and 100");
      }
      if (data.refreshInterval && (data.refreshInterval < 10 || data.refreshInterval > 300)) {
        warnings.push("Refresh interval should be between 10 and 300 seconds");
      }
      return {
        isValid: errors.length === 0,
        errors,
        warnings
      };
    } catch (error) {
      throw new Error(`Failed to validate user preferences: ${error.message}`);
    }
  }
};

// src/features/user-preferences/user-preferences.controller.ts
var UserPreferencesController = {
  // === CRUD BSICO ===
  async create(request, reply) {
    try {
      const preferencesData = request.body;
      const result = await UserPreferencesCommands.create(preferencesData);
      return reply.status(201).send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "User preferences already exist for this user") {
        return reply.status(409).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const result = await UserPreferencesQueries.getById(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const result = await UserPreferencesCommands.update(id, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await UserPreferencesCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, theme, language, currency } = request.query;
      const result = await UserPreferencesQueries.list({
        page,
        limit,
        search,
        theme,
        language,
        currency
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (QUERIES) ===
  async getByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesQueries.getByUserId(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByUserIdOrCreate(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesQueries.getByUserIdOrCreate(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const updateData = request.body;
      const result = await UserPreferencesCommands.updateByUserId(userId, updateData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async deleteByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      await UserPreferencesCommands.deleteByUserId(userId);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found" || error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByTheme(request, reply) {
    try {
      const { theme } = request.query;
      const result = await UserPreferencesQueries.getByTheme(theme);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByLanguage(request, reply) {
    try {
      const { language } = request.query;
      const result = await UserPreferencesQueries.getByLanguage(language);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getByCurrency(request, reply) {
    try {
      const { currency } = request.query;
      const result = await UserPreferencesQueries.getByCurrency(currency);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getWithCustomSettings(request, reply) {
    try {
      const result = await UserPreferencesQueries.getWithCustomSettings();
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const result = await UserPreferencesQueries.getStats();
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const result = await UserPreferencesQueries.search(q, limit);
      return reply.send({ preferences: result });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // === FUNES ADICIONAIS (COMMANDS) ===
  async resetToDefaults(request, reply) {
    try {
      const { id } = request.params;
      const result = await UserPreferencesCommands.resetToDefaults(id);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async resetToDefaultsByUserId(request, reply) {
    try {
      const userId = request.user?.id;
      if (!userId) {
        return reply.status(401).send({
          error: "User not authenticated"
        });
      }
      const result = await UserPreferencesCommands.resetToDefaultsByUserId(userId);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found" || error.message === "User preferences not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async validatePreferences(request, reply) {
    try {
      const preferencesData = request.body;
      const result = await UserPreferencesQueries.validatePreferences(preferencesData);
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/user-preferences/user-preferences.schema.ts
var createUserPreferencesSchema = {
  body: {
    type: "object",
    required: ["userId"],
    properties: {
      userId: {
        type: "string",
        description: "User ID"
      },
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        default: "light",
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        default: false,
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        default: false,
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        default: "pt-BR",
        description: "Language preference"
      },
      currency: {
        type: "string",
        default: "BRL",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        default: "America/Sao_Paulo",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"],
        default: "DD/MM/YYYY",
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        default: "24h",
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        default: "pt-BR",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        default: true,
        description: "Email notifications enabled"
      },
      pushNotifications: {
        type: "boolean",
        default: true,
        description: "Push notifications enabled"
      },
      smsNotifications: {
        type: "boolean",
        default: false,
        description: "SMS notifications enabled"
      },
      notificationTypes: {
        type: "object",
        description: "Specific notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page to load"
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100,
        default: 20,
        description: "Number of items per page"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        default: true,
        description: "Auto refresh enabled"
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300,
        default: 30,
        description: "Refresh interval in seconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        language: { type: "string" },
        currency: { type: "string" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    409: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        description: "Language preference"
      },
      currency: {
        type: "string",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"],
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        description: "Email notifications enabled"
      },
      pushNotifications: {
        type: "boolean",
        description: "Push notifications enabled"
      },
      smsNotifications: {
        type: "boolean",
        description: "SMS notifications enabled"
      },
      notificationTypes: {
        type: "object",
        description: "Specific notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page to load"
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100,
        description: "Number of items per page"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        description: "Auto refresh enabled"
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300,
        description: "Refresh interval in seconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        language: { type: "string" },
        currency: { type: "string" },
        updatedAt: { type: "string", format: "date-time" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "integer" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "integer" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var updateUserPreferencesMeSchema = {
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Theme preference"
      },
      primaryColor: {
        type: "string",
        pattern: "^#[0-9A-Fa-f]{6}$",
        description: "Primary color in hex format"
      },
      sidebarCollapsed: {
        type: "boolean",
        description: "Whether sidebar is collapsed"
      },
      compactMode: {
        type: "boolean",
        description: "Whether to use compact mode"
      },
      language: {
        type: "string",
        description: "Language preference"
      },
      currency: {
        type: "string",
        description: "Currency preference"
      },
      timezone: {
        type: "string",
        description: "Timezone preference"
      },
      dateFormat: {
        type: "string",
        description: "Date format preference"
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"],
        description: "Time format preference"
      },
      numberFormat: {
        type: "string",
        description: "Number format preference"
      },
      emailNotifications: {
        type: "boolean",
        description: "Email notifications preference"
      },
      pushNotifications: {
        type: "boolean",
        description: "Push notifications preference"
      },
      smsNotifications: {
        type: "boolean",
        description: "SMS notifications preference"
      },
      notificationTypes: {
        type: "object",
        description: "Notification types configuration"
      },
      dashboardLayout: {
        type: "object",
        description: "Dashboard layout configuration"
      },
      defaultPage: {
        type: "string",
        description: "Default page preference"
      },
      itemsPerPage: {
        type: "number",
        minimum: 1,
        maximum: 100,
        description: "Items per page preference"
      },
      defaultStoreId: {
        type: "string",
        description: "Default store ID"
      },
      autoRefresh: {
        type: "boolean",
        description: "Auto refresh preference"
      },
      refreshInterval: {
        type: "number",
        minimum: 1e3,
        maximum: 3e5,
        description: "Refresh interval in milliseconds"
      },
      customSettings: {
        type: "object",
        description: "Custom settings configuration"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "number" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "number" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesMeSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        userId: { type: "string" },
        theme: { type: "string" },
        primaryColor: { type: "string" },
        sidebarCollapsed: { type: "boolean" },
        compactMode: { type: "boolean" },
        language: { type: "string" },
        currency: { type: "string" },
        timezone: { type: "string" },
        dateFormat: { type: "string" },
        timeFormat: { type: "string" },
        numberFormat: { type: "string" },
        emailNotifications: { type: "boolean" },
        pushNotifications: { type: "boolean" },
        smsNotifications: { type: "boolean" },
        notificationTypes: { type: "object" },
        dashboardLayout: { type: "object" },
        defaultPage: { type: "string" },
        itemsPerPage: { type: "number" },
        defaultStoreId: { type: "string" },
        autoRefresh: { type: "boolean" },
        refreshInterval: { type: "number" },
        customSettings: { type: "object" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" },
        user: {
          type: "object",
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            email: { type: "string" }
          }
        }
      }
    },
    401: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var deleteUserPreferencesSchema = {
  params: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "User preferences ID"
      }
    },
    required: ["id"]
  },
  response: {
    204: {
      type: "null"
    },
    404: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var listUserPreferencesSchema = {
  querystring: {
    type: "object",
    properties: {
      page: {
        type: "integer",
        minimum: 1,
        default: 1,
        description: "Page number"
      },
      limit: {
        type: "integer",
        minimum: 1,
        maximum: 100,
        default: 10,
        description: "Items per page"
      },
      search: {
        type: "string",
        description: "Search term"
      },
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"],
        description: "Filter by theme"
      },
      language: {
        type: "string",
        description: "Filter by language"
      },
      currency: {
        type: "string",
        description: "Filter by currency"
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        preferences: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              theme: { type: "string" },
              language: { type: "string" },
              currency: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "integer" },
            limit: { type: "integer" },
            total: { type: "integer" },
            totalPages: { type: "integer" }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var getUserPreferencesStatsSchema = {
  response: {
    200: {
      type: "object",
      properties: {
        totalPreferences: { type: "integer" },
        themeDistribution: {
          type: "object",
          properties: {
            light: { type: "integer" },
            dark: { type: "integer" },
            auto: { type: "integer" }
          }
        },
        languageDistribution: {
          type: "object",
          additionalProperties: { type: "integer" }
        },
        currencyDistribution: {
          type: "object",
          additionalProperties: { type: "integer" }
        },
        averageItemsPerPage: { type: "integer" },
        notificationsEnabled: { type: "integer" },
        notificationsDisabled: { type: "integer" }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var searchUserPreferencesSchema = {
  querystring: {
    type: "object",
    properties: {
      q: {
        type: "string",
        description: "Search query"
      },
      limit: {
        type: "integer",
        minimum: 1,
        maximum: 50,
        default: 10,
        description: "Maximum number of results"
      }
    },
    required: ["q"]
  },
  response: {
    200: {
      type: "object",
      properties: {
        preferences: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              theme: { type: "string" },
              language: { type: "string" },
              currency: { type: "string" },
              createdAt: { type: "string", format: "date-time" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};
var validateUserPreferencesSchema = {
  body: {
    type: "object",
    properties: {
      theme: {
        type: "string",
        enum: ["light", "dark", "auto"]
      },
      dateFormat: {
        type: "string",
        enum: ["DD/MM/YYYY", "MM/DD/YYYY", "YYYY-MM-DD"]
      },
      timeFormat: {
        type: "string",
        enum: ["12h", "24h"]
      },
      itemsPerPage: {
        type: "integer",
        minimum: 5,
        maximum: 100
      },
      refreshInterval: {
        type: "integer",
        minimum: 10,
        maximum: 300
      }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        isValid: { type: "boolean" },
        errors: {
          type: "array",
          items: { type: "string" }
        },
        warnings: {
          type: "array",
          items: { type: "string" }
        }
      }
    },
    500: {
      type: "object",
      properties: {
        error: { type: "string" }
      }
    }
  }
};

// src/features/user-preferences/user-preferences.routes.ts
async function UserPreferencesRoutes(fastify2) {
  fastify2.addHook("preHandler", Middlewares.auth);
  fastify2.addHook("preHandler", Middlewares.store);
  fastify2.post("/", {
    schema: createUserPreferencesSchema,
    handler: UserPreferencesController.create
  });
  fastify2.get("/", {
    schema: listUserPreferencesSchema,
    handler: UserPreferencesController.list
  });
  fastify2.get("/:id", {
    schema: getUserPreferencesSchema,
    handler: UserPreferencesController.get
  });
  fastify2.put("/:id", {
    schema: updateUserPreferencesSchema,
    handler: UserPreferencesController.update
  });
  fastify2.delete("/:id", {
    schema: deleteUserPreferencesSchema,
    handler: UserPreferencesController.delete
  });
  fastify2.get("/me", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.getByUserId
  });
  fastify2.get("/me/or-create", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.getByUserIdOrCreate
  });
  fastify2.put("/me", {
    schema: updateUserPreferencesMeSchema,
    handler: UserPreferencesController.updateByUserId
  });
  fastify2.delete("/me", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.deleteByUserId
  });
  fastify2.get("/theme/:theme", {
    handler: UserPreferencesController.getByTheme
  });
  fastify2.get("/language/:language", {
    handler: UserPreferencesController.getByLanguage
  });
  fastify2.get("/currency/:currency", {
    handler: UserPreferencesController.getByCurrency
  });
  fastify2.get("/custom-settings", {
    handler: UserPreferencesController.getWithCustomSettings
  });
  fastify2.get("/stats", {
    schema: getUserPreferencesStatsSchema,
    handler: UserPreferencesController.getStats
  });
  fastify2.get("/search", {
    schema: searchUserPreferencesSchema,
    handler: UserPreferencesController.search
  });
  fastify2.patch("/:id/reset", {
    schema: getUserPreferencesSchema,
    handler: UserPreferencesController.resetToDefaults
  });
  fastify2.patch("/me/reset", {
    schema: getUserPreferencesMeSchema,
    handler: UserPreferencesController.resetToDefaultsByUserId
  });
  fastify2.post("/validate", {
    schema: validateUserPreferencesSchema,
    handler: UserPreferencesController.validatePreferences
  });
}

// src/features/user/commands/user.commands.ts
var import_bcryptjs = __toESM(require("bcryptjs"));
var UserCommands = {
  async create(data) {
    const existingUser = await db.user.findUnique({
      where: { email: data.email }
    });
    if (existingUser) {
      throw new Error("User with this email already exists");
    }
    const hashedPassword = await import_bcryptjs.default.hash(data.password, 12);
    const user = await db.user.create({
      data: {
        email: data.email,
        password: hashedPassword,
        name: data.name
      },
      select: {
        id: true,
        email: true,
        name: true,
        status: true,
        createdAt: true
      }
    });
    return user;
  },
  async update(id, data) {
    const existingUser = await db.user.findUnique({
      where: { id }
    });
    if (!existingUser) {
      throw new Error("User not found");
    }
    const updateData = { ...data };
    if (updateData.password) {
      updateData.password = await import_bcryptjs.default.hash(updateData.password, 12);
    }
    if (updateData.email && updateData.email !== existingUser.email) {
      const emailExists = await db.user.findUnique({
        where: { email: updateData.email }
      });
      if (emailExists) {
        throw new Error("Email already exists");
      }
    }
    const user = await db.user.update({
      where: { id },
      data: updateData,
      select: {
        id: true,
        email: true,
        name: true,
        status: true,
        emailVerified: true,
        updatedAt: true,
        isOwner: true
      }
    });
    return user;
  },
  async delete(id) {
    const existingUser = await db.user.findUnique({
      where: { id }
    });
    if (!existingUser) {
      throw new Error("User not found");
    }
    await db.user.update({
      where: { id },
      data: { status: false }
    });
    return { success: true };
  },
  async verifyEmail(id) {
    const user = await db.user.update({
      where: { id },
      data: { emailVerified: true },
      select: {
        id: true,
        email: true,
        emailVerified: true,
        updatedAt: true
      }
    });
    return user;
  },
  async updateLastLogin(id) {
    await db.user.update({
      where: { id },
      data: { lastLoginAt: /* @__PURE__ */ new Date() }
    });
    return { success: true };
  }
};

// src/utils/pagination.ts
var PaginationUtils = {
  /**
   * Normaliza os parmetros de paginao
   */
  normalizeParams(params, options = {}) {
    const { defaultPage = 1, defaultLimit = 10, maxLimit = 100 } = options;
    const page = Math.max(1, params.page || defaultPage);
    const limit = Math.min(maxLimit, Math.max(1, params.limit || defaultLimit));
    const skip2 = (page - 1) * limit;
    return { page, limit, skip: skip2 };
  },
  /**
   * Cria o objeto de paginao com metadados
   */
  createPaginationMeta(page, limit, total) {
    const totalPages = Math.ceil(total / limit);
    return {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1
    };
  },
  /**
   * Executa uma consulta paginada com Prisma
   */
  async paginate(prisma2, model, options) {
    const {
      where = {},
      select,
      include,
      orderBy = { createdAt: "desc" },
      params = {},
      paginationOptions = {}
    } = options;
    const { page, limit, skip: skip2 } = this.normalizeParams(params, paginationOptions);
    const queryOptions = {
      where,
      skip: skip2,
      take: limit,
      orderBy
    };
    if (select) {
      queryOptions.select = select;
    }
    if (include) {
      queryOptions.include = include;
    }
    const [data, total] = await Promise.all([
      prisma2[model].findMany(queryOptions),
      prisma2[model].count({ where })
    ]);
    return {
      data,
      pagination: this.createPaginationMeta(page, limit, total)
    };
  },
  /**
   * Cria um helper para queries especficas com paginao
   */
  createPaginatedQuery(model, defaultOptions = {}) {
    return async (prisma2, params) => {
      const { where, ...paginationParams } = params;
      return this.paginate(prisma2, model, {
        ...defaultOptions,
        where: where || {},
        params: paginationParams
      });
    };
  },
  /**
   * Utilitrio para transformar dados paginados em formato especfico
   */
  transformPaginationResult(result, dataKey, transformer) {
    const transformedData = transformer ? result.data.map(transformer) : result.data;
    return {
      [dataKey]: transformedData,
      pagination: result.pagination
    };
  }
};

// src/features/user/querys/user.query.ts
var UserQueries = {
  async getById(id) {
    const user = await db.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        name: true,
        isOwner: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    if (!user) {
      throw new Error("User not found");
    }
    return user;
  },
  async getByEmail(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        name: true,
        isOwner: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    return user;
  },
  async getByEmailWithPassword(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        password: true,
        name: true,
        isOwner: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true,
        updatedAt: true
      }
    });
    return user;
  },
  async list(filters) {
    const where = {};
    if (filters.search) {
      where.OR = [
        { email: { contains: filters.search, mode: "insensitive" } },
        { name: { contains: filters.search, mode: "insensitive" } }
      ];
    }
    if (filters.status !== void 0) {
      where.status = filters.status;
    }
    if (filters.roles && filters.roles.length > 0) {
      where.roles = {
        hasSome: filters.roles
      };
    }
    const result = await PaginationUtils.paginate(db, "user", {
      where,
      select: {
        id: true,
        email: true,
        name: true,
        isOwner: true,
        status: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true
      },
      orderBy: { createdAt: "desc" },
      params: {
        page: filters.page,
        limit: filters.limit
      },
      paginationOptions: {
        defaultPage: 1,
        defaultLimit: 10,
        maxLimit: 100
      }
    });
    return PaginationUtils.transformPaginationResult(result, "users");
  },
  async getActive() {
    const users = await db.user.findMany({
      where: { status: true },
      select: {
        id: true,
        email: true,
        name: true,
        emailVerified: true,
        lastLoginAt: true,
        createdAt: true
      },
      orderBy: { createdAt: "desc" }
    });
    return users;
  },
  async getStats() {
    const [total, active, inactive, verified, unverified] = await Promise.all([
      db.user.count(),
      db.user.count({ where: { status: true } }),
      db.user.count({ where: { status: false } }),
      db.user.count({ where: { emailVerified: true } }),
      db.user.count({ where: { emailVerified: false } })
    ]);
    return {
      total,
      active,
      inactive,
      verified,
      unverified
    };
  },
  async checkEmailExists(email) {
    const user = await db.user.findUnique({
      where: { email },
      select: { id: true }
    });
    return !!user;
  },
  async search(searchTerm, limit = 10) {
    const users = await db.user.findMany({
      where: {
        OR: [
          { email: { contains: searchTerm, mode: "insensitive" } },
          { name: { contains: searchTerm, mode: "insensitive" } }
        ],
        status: true
      },
      select: {
        id: true,
        email: true,
        name: true,
        emailVerified: true
      },
      take: limit,
      orderBy: { name: "asc" }
    });
    return users;
  }
};

// src/features/user/user.controller.ts
var UserController = {
  async create(request, reply) {
    try {
      const { email, password, name, roles = ["user"] } = request.body;
      const user = await UserCommands.create({
        email,
        password,
        name,
        roles
      });
      return reply.status(201).send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User with this email already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async get(request, reply) {
    try {
      const { id } = request.params;
      const user = await UserQueries.getById(id);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async update(request, reply) {
    try {
      const { id } = request.params;
      const updateData = { ...request.body };
      const user = await UserCommands.update(id, updateData);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      if (error.message === "Email already exists") {
        return reply.status(400).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async delete(request, reply) {
    try {
      const { id } = request.params;
      await UserCommands.delete(id);
      return reply.status(204).send();
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async list(request, reply) {
    try {
      const { page = 1, limit = 10, search, status } = request.query;
      const result = await UserQueries.list({
        page,
        limit,
        search,
        status
      });
      return reply.send(result);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Funes adicionais usando queries
  async getByEmail(request, reply) {
    try {
      const { email } = request.query;
      const user = await UserQueries.getByEmail(email);
      if (!user) {
        return reply.status(404).send({
          error: "User not found"
        });
      }
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getActive(request, reply) {
    try {
      const users = await UserQueries.getActive();
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async getStats(request, reply) {
    try {
      const stats = await UserQueries.getStats();
      return reply.send(stats);
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async search(request, reply) {
    try {
      const { q, limit = 10 } = request.query;
      const users = await UserQueries.search(q, limit);
      return reply.send({ users });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  // Funes adicionais usando commands
  async verifyEmail(request, reply) {
    try {
      const { id } = request.params;
      const user = await UserCommands.verifyEmail(id);
      return reply.send(user);
    } catch (error) {
      request.log.error(error);
      if (error.message === "User not found") {
        return reply.status(404).send({
          error: error.message
        });
      }
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  },
  async updateLastLogin(request, reply) {
    try {
      const { id } = request.params;
      await UserCommands.updateLastLogin(id);
      return reply.send({ success: true });
    } catch (error) {
      request.log.error(error);
      return reply.status(500).send({
        error: "Internal server error"
      });
    }
  }
};

// src/features/user/user.schema.ts
var createUserSchema = {
  body: {
    type: "object",
    required: ["email", "password", "name"],
    properties: {
      email: { type: "string", format: "email" },
      password: { type: "string", minLength: 6 },
      name: { type: "string", minLength: 2 },
      roles: {
        type: "array",
        items: { type: "string" },
        default: ["user"]
      }
    }
  },
  response: {
    201: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        createdAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var getUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        emailVerified: { type: "boolean" },
        lastLoginAt: { type: "string", format: "date-time" },
        createdAt: { type: "string", format: "date-time" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var updateUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  body: {
    type: "object",
    properties: {
      email: { type: "string", format: "email" },
      password: { type: "string", minLength: 6 },
      name: { type: "string", minLength: 2 },
      roles: { type: "array", items: { type: "string" } },
      status: { type: "boolean" },
      emailVerified: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        id: { type: "string" },
        email: { type: "string" },
        name: { type: "string" },
        roles: { type: "array", items: { type: "string" } },
        status: { type: "boolean" },
        emailVerified: { type: "boolean" },
        updatedAt: { type: "string", format: "date-time" }
      }
    }
  }
};
var deleteUserSchema = {
  params: {
    type: "object",
    required: ["id"],
    properties: {
      id: { type: "string" }
    }
  },
  response: {
    204: { type: "null" }
  }
};
var listUsersSchema = {
  querystring: {
    type: "object",
    properties: {
      page: { type: "number", minimum: 1, default: 1 },
      limit: { type: "number", minimum: 1, maximum: 100, default: 10 },
      search: { type: "string" },
      status: { type: "boolean" }
    }
  },
  response: {
    200: {
      type: "object",
      properties: {
        users: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: { type: "string" },
              email: { type: "string" },
              name: { type: "string" },
              roles: { type: "array", items: { type: "string" } },
              status: { type: "boolean" },
              emailVerified: { type: "boolean" },
              lastLoginAt: { type: "string", format: "date-time" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        },
        pagination: {
          type: "object",
          properties: {
            page: { type: "number" },
            limit: { type: "number" },
            total: { type: "number" },
            totalPages: { type: "number" }
          }
        }
      }
    }
  }
};
var UserSchemas = {
  create: createUserSchema,
  get: getUserSchema,
  update: updateUserSchema,
  delete: deleteUserSchema,
  list: listUsersSchema
};

// src/features/user/user.routes.ts
async function UserRoutes(fastify2) {
  fastify2.post("/", {
    schema: UserSchemas.create,
    handler: UserController.create
  });
  fastify2.get("/", {
    schema: UserSchemas.list,
    handler: UserController.list
  });
  fastify2.get("/:id", {
    schema: UserSchemas.get,
    handler: UserController.get
  });
  fastify2.put("/:id", {
    schema: UserSchemas.update,
    handler: UserController.update
  });
  fastify2.delete("/:id", {
    schema: UserSchemas.delete,
    handler: UserController.delete
  });
  fastify2.get("/email", {
    handler: UserController.getByEmail
  });
  fastify2.get("/active", {
    handler: UserController.getActive
  });
  fastify2.get("/stats", {
    handler: UserController.getStats
  });
  fastify2.get("/search", {
    handler: UserController.search
  });
  fastify2.patch("/:id/verify-email", {
    handler: UserController.verifyEmail
  });
  fastify2.patch("/:id/last-login", {
    handler: UserController.updateLastLogin
  });
}

// src/server.ts
var fastify = (0, import_fastify.default)({
  logger: true,
  // Desabilitado - usando bootstrap UI para feedback visual
  requestTimeout: 6e4,
  // 30 segundos para timeout de requisies
  keepAliveTimeout: 5e3,
  // 5 segundos para keep-alive
  bodyLimit: 1048576,
  // 1MB para limite do body
  routerOptions: {
    maxParamLength: 200
    // Limite de caracteres para parmetros de rota
  }
});
fastify.get("/health", async (request, reply) => {
  try {
    return reply.send({
      status: "ok",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: process.uptime(),
      database: "connected"
    });
  } catch (error) {
    request.log.error(error);
    return reply.status(503).send({
      status: "error",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      uptime: process.uptime(),
      database: "disconnected",
      error: "Database connection failed"
    });
  }
});
var PORT = Number(process.env.PORT) || 3e3;
var HOST = "0.0.0.0";
var closeGracefully = async (signal) => {
  console.log(`
\u26A0\uFE0F  Recebido sinal ${signal}, encerrando servidor...`);
  try {
    await fastify.close();
    console.log("\u2705 Servidor encerrado com sucesso");
    process.exit(0);
  } catch (err) {
    console.error("\u274C Erro ao encerrar servidor:", err);
    process.exit(1);
  }
};
process.on("SIGINT", () => closeGracefully("SIGINT"));
process.on("SIGTERM", () => closeGracefully("SIGTERM"));
process.on("uncaughtException", (err) => {
  console.error("Uncaught Exception:", err);
  bootstrapUI.showError("Uncaught Exception", err);
  process.exit(1);
});
process.on("unhandledRejection", (reason) => {
  console.error("Unhandled Rejection:", reason);
  bootstrapUI.showError("Unhandled Rejection", reason);
  process.exit(1);
});
async function startServer() {
  const success = await bootstrapUI.run([
    {
      name: "Conectando ao banco de dados",
      action: async () => {
        await connectDb();
      }
    },
    {
      name: "Registrando plugins",
      action: async () => {
        await fastify.register(dbPlugin);
        await fastify.register(pushPlugin);
      }
    },
    {
      name: "Configurando CORS",
      action: async () => {
        await fastify.register(import_cors.default, {
          origin: true,
          credentials: true,
          methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
          allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"]
        });
      }
    },
    {
      name: "Registrando raw body parser",
      action: async () => {
        await fastify.register(require("fastify-raw-body"), {
          field: "rawBody",
          global: true,
          encoding: "utf8",
          runFirst: true
        });
      }
    },
    {
      name: "Configurando arquivos est\xE1ticos",
      action: async () => {
        await fastify.register(require("@fastify/static"), {
          root: import_node_path3.default.join(process.cwd(), "src", "uploads"),
          prefix: "/uploads/",
          decorateReply: false
        });
      }
    },
    {
      name: "Registrando rotas",
      action: async () => {
        await fastify.register(AuthRoutes, { prefix: "/auth" });
        await fastify.register(UserRoutes, { prefix: "/users" });
        await fastify.register(ProductRoutes, { prefix: "/products" });
        await fastify.register(SupplierRoutes, { prefix: "/suppliers" });
        await fastify.register(CategoryRoutes, { prefix: "/categories" });
        await fastify.register(MovementRoutes, { prefix: "/movements" });
        await fastify.register(NotificationRoutes, { prefix: "/notifications" });
        await fastify.register(ChatRoutes, { prefix: "/chat" });
        await fastify.register(RoadmapRoutes, { prefix: "/roadmaps" });
        await fastify.register(UploadRoutes, { prefix: "/uploads" });
        await fastify.register(QuoteRoutes, { prefix: "/quotes" });
        await fastify.register(InvoiceRoutes, { prefix: "/invoices" });
        await fastify.register(CrmRoutes, { prefix: "/crm" });
        await fastify.register(UserPreferencesRoutes, { prefix: "/preferences" });
        await fastify.register(FlowRoutes, { prefix: "/flows" });
        await fastify.register(FlowExecutionRoutes, { prefix: "" });
        await fastify.register(PushSubscriptionRoutes, { prefix: "/push-subscriptions" });
        await fastify.register(PolarRoutes, { prefix: "/polar" });
        await fastify.register(StoreRoutes, { prefix: "/store" });
        await fastify.register(ProfileRoutes, { prefix: "/profile" });
        await fastify.register(SubscriptionRoutes, { prefix: "/subscriptions" });
      }
    },
    {
      name: "Configurando sistema de logs",
      action: async () => {
        bootstrapUI.setupFastifyHooks(fastify);
      }
    },
    {
      name: "Iniciando servidor",
      action: async () => {
        await fastify.listen({ port: PORT, host: HOST });
      }
    }
  ]);
  if (!success) {
    bootstrapUI.showError("Falha ao inicializar o servidor");
    process.exit(1);
  }
  bootstrapUI.showServerInfo(fastify, PORT, HOST);
}
startServer().catch((err) => {
  console.error("Erro fatal ao iniciar o servidor:", err);
  bootstrapUI.showError("Erro fatal ao iniciar o servidor", err);
  process.exit(1);
});
/*! Bundled license information:

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
